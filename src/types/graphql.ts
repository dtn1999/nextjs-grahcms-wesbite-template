import { useQuery, UseQueryOptions } from '@tanstack/react-query';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };

function fetcher<TData, TVariables>(endpoint: string, requestInit: RequestInit, query: string, variables?: TVariables) {
  return async (): Promise<TData> => {
    const res = await fetch(endpoint, {
      method: 'POST',
      ...requestInit,
      body: JSON.stringify({ query, variables }),
    });

    const json = await res.json();

    if (json.errors) {
      const { message } = json.errors[0];

      throw new Error(message);
    }

    return json.data;
  }
}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  Date: any;
  DateTime: any;
  Hex: any;
  Json: any;
  Long: any;
  RGBAHue: any;
  RGBATransparency: any;
  RichTextAST: any;
};

export type Aggregate = {
  __typename?: 'Aggregate';
  count: Scalars['Int'];
};

/** Asset system model */
export type Asset = Node & {
  __typename?: 'Asset';
  alt?: Maybe<Scalars['String']>;
  /** The time the document was created */
  createdAt: Scalars['DateTime'];
  /** User that created this document */
  createdBy?: Maybe<User>;
  /** Get the document in other stages */
  documentInStages: Array<Asset>;
  /** The file name */
  fileName: Scalars['String'];
  galleryEvent: Array<Event>;
  gelleryProject: Array<Project>;
  /** The file handle */
  handle: Scalars['String'];
  /** The height of the file */
  height?: Maybe<Scalars['Float']>;
  /** List of Asset versions */
  history: Array<Version>;
  /** The unique identifier */
  id: Scalars['ID'];
  imageEvent: Array<Event>;
  imageIconService: Array<Service>;
  imageProject: Array<Project>;
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<Asset>;
  logoSponsor: Array<Sponsor>;
  /** The mime type of the file */
  mimeType?: Maybe<Scalars['String']>;
  personPhoto: Array<Person>;
  /** The time the document was published. Null on documents in draft stage. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** User that last published this document */
  publishedBy?: Maybe<User>;
  scheduledIn: Array<ScheduledOperation>;
  /** The file size */
  size?: Maybe<Scalars['Float']>;
  /** System stage field */
  stage: Stage;
  /** The time the document was updated */
  updatedAt: Scalars['DateTime'];
  /** User that last updated this document */
  updatedBy?: Maybe<User>;
  /** Get the url for the asset with provided transformations applied. */
  url: Scalars['String'];
  /** The file width */
  width?: Maybe<Scalars['Float']>;
};


/** Asset system model */
export type AssetCreatedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


/** Asset system model */
export type AssetCreatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


/** Asset system model */
export type AssetDocumentInStagesArgs = {
  includeCurrent?: Scalars['Boolean'];
  inheritLocale?: Scalars['Boolean'];
  stages?: Array<Stage>;
};


/** Asset system model */
export type AssetGalleryEventArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  orderBy?: InputMaybe<EventOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<EventWhereInput>;
};


/** Asset system model */
export type AssetGelleryProjectArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  orderBy?: InputMaybe<ProjectOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ProjectWhereInput>;
};


/** Asset system model */
export type AssetHistoryArgs = {
  limit?: Scalars['Int'];
  skip?: Scalars['Int'];
  stageOverride?: InputMaybe<Stage>;
};


/** Asset system model */
export type AssetImageEventArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  orderBy?: InputMaybe<EventOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<EventWhereInput>;
};


/** Asset system model */
export type AssetImageIconServiceArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  orderBy?: InputMaybe<ServiceOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ServiceWhereInput>;
};


/** Asset system model */
export type AssetImageProjectArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  orderBy?: InputMaybe<ProjectOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ProjectWhereInput>;
};


/** Asset system model */
export type AssetLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};


/** Asset system model */
export type AssetLogoSponsorArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  orderBy?: InputMaybe<SponsorOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<SponsorWhereInput>;
};


/** Asset system model */
export type AssetPersonPhotoArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  orderBy?: InputMaybe<PersonOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PersonWhereInput>;
};


/** Asset system model */
export type AssetPublishedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


/** Asset system model */
export type AssetPublishedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


/** Asset system model */
export type AssetScheduledInArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ScheduledOperationWhereInput>;
};


/** Asset system model */
export type AssetUpdatedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


/** Asset system model */
export type AssetUpdatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


/** Asset system model */
export type AssetUrlArgs = {
  transformation?: InputMaybe<AssetTransformationInput>;
};

export type AssetConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: AssetWhereUniqueInput;
};

/** A connection to a list of items. */
export type AssetConnection = {
  __typename?: 'AssetConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<AssetEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type AssetCreateInput = {
  /** alt input for default locale (en) */
  alt?: InputMaybe<Scalars['String']>;
  backgroundImageDescriptionSection?: InputMaybe<AssociationProfileSectionCreateManyInlineInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  fileName: Scalars['String'];
  galleryEvent?: InputMaybe<EventCreateManyInlineInput>;
  gelleryProject?: InputMaybe<ProjectCreateManyInlineInput>;
  handle: Scalars['String'];
  height?: InputMaybe<Scalars['Float']>;
  imageCarouselSlide?: InputMaybe<CarouselSlideCreateManyInlineInput>;
  imageEvent?: InputMaybe<EventCreateManyInlineInput>;
  imageHero?: InputMaybe<HeroCreateManyInlineInput>;
  imageIconService?: InputMaybe<ServiceCreateManyInlineInput>;
  imageImageContainer?: InputMaybe<ImageContainerCreateManyInlineInput>;
  imageProject?: InputMaybe<ProjectCreateManyInlineInput>;
  imageSectionImage?: InputMaybe<SectionWithImageCreateManyInlineInput>;
  imageSeo?: InputMaybe<SeoCreateManyInlineInput>;
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<AssetCreateLocalizationsInput>;
  logoNavigation?: InputMaybe<NavigationCreateManyInlineInput>;
  logoSponsor?: InputMaybe<SponsorCreateManyInlineInput>;
  mimeType?: InputMaybe<Scalars['String']>;
  personPhoto?: InputMaybe<PersonCreateManyInlineInput>;
  size?: InputMaybe<Scalars['Float']>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  width?: InputMaybe<Scalars['Float']>;
};

export type AssetCreateLocalizationDataInput = {
  alt?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  fileName: Scalars['String'];
  handle: Scalars['String'];
  height?: InputMaybe<Scalars['Float']>;
  mimeType?: InputMaybe<Scalars['String']>;
  size?: InputMaybe<Scalars['Float']>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  width?: InputMaybe<Scalars['Float']>;
};

export type AssetCreateLocalizationInput = {
  /** Localization input */
  data: AssetCreateLocalizationDataInput;
  locale: Locale;
};

export type AssetCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<AssetCreateLocalizationInput>>;
};

export type AssetCreateManyInlineInput = {
  /** Connect multiple existing Asset documents */
  connect?: InputMaybe<Array<AssetWhereUniqueInput>>;
  /** Create and connect multiple existing Asset documents */
  create?: InputMaybe<Array<AssetCreateInput>>;
};

export type AssetCreateOneInlineInput = {
  /** Connect one existing Asset document */
  connect?: InputMaybe<AssetWhereUniqueInput>;
  /** Create and connect one Asset document */
  create?: InputMaybe<AssetCreateInput>;
};

/** An edge in a connection. */
export type AssetEdge = {
  __typename?: 'AssetEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Asset;
};

/** Identifies documents */
export type AssetManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<AssetWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<AssetWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<AssetWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  galleryEvent_every?: InputMaybe<EventWhereInput>;
  galleryEvent_none?: InputMaybe<EventWhereInput>;
  galleryEvent_some?: InputMaybe<EventWhereInput>;
  gelleryProject_every?: InputMaybe<ProjectWhereInput>;
  gelleryProject_none?: InputMaybe<ProjectWhereInput>;
  gelleryProject_some?: InputMaybe<ProjectWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  imageEvent_every?: InputMaybe<EventWhereInput>;
  imageEvent_none?: InputMaybe<EventWhereInput>;
  imageEvent_some?: InputMaybe<EventWhereInput>;
  imageIconService_every?: InputMaybe<ServiceWhereInput>;
  imageIconService_none?: InputMaybe<ServiceWhereInput>;
  imageIconService_some?: InputMaybe<ServiceWhereInput>;
  imageProject_every?: InputMaybe<ProjectWhereInput>;
  imageProject_none?: InputMaybe<ProjectWhereInput>;
  imageProject_some?: InputMaybe<ProjectWhereInput>;
  logoSponsor_every?: InputMaybe<SponsorWhereInput>;
  logoSponsor_none?: InputMaybe<SponsorWhereInput>;
  logoSponsor_some?: InputMaybe<SponsorWhereInput>;
  personPhoto_every?: InputMaybe<PersonWhereInput>;
  personPhoto_none?: InputMaybe<PersonWhereInput>;
  personPhoto_some?: InputMaybe<PersonWhereInput>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

export enum AssetOrderByInput {
  AltAsc = 'alt_ASC',
  AltDesc = 'alt_DESC',
  CreatedAtAsc = 'createdAt_ASC',
  CreatedAtDesc = 'createdAt_DESC',
  FileNameAsc = 'fileName_ASC',
  FileNameDesc = 'fileName_DESC',
  HandleAsc = 'handle_ASC',
  HandleDesc = 'handle_DESC',
  HeightAsc = 'height_ASC',
  HeightDesc = 'height_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  MimeTypeAsc = 'mimeType_ASC',
  MimeTypeDesc = 'mimeType_DESC',
  PublishedAtAsc = 'publishedAt_ASC',
  PublishedAtDesc = 'publishedAt_DESC',
  SizeAsc = 'size_ASC',
  SizeDesc = 'size_DESC',
  UpdatedAtAsc = 'updatedAt_ASC',
  UpdatedAtDesc = 'updatedAt_DESC',
  WidthAsc = 'width_ASC',
  WidthDesc = 'width_DESC'
}

/** Transformations for Assets */
export type AssetTransformationInput = {
  document?: InputMaybe<DocumentTransformationInput>;
  image?: InputMaybe<ImageTransformationInput>;
  /** Pass true if you want to validate the passed transformation parameters */
  validateOptions?: InputMaybe<Scalars['Boolean']>;
};

export type AssetUpdateInput = {
  /** alt input for default locale (en) */
  alt?: InputMaybe<Scalars['String']>;
  backgroundImageDescriptionSection?: InputMaybe<AssociationProfileSectionUpdateManyInlineInput>;
  fileName?: InputMaybe<Scalars['String']>;
  galleryEvent?: InputMaybe<EventUpdateManyInlineInput>;
  gelleryProject?: InputMaybe<ProjectUpdateManyInlineInput>;
  handle?: InputMaybe<Scalars['String']>;
  height?: InputMaybe<Scalars['Float']>;
  imageCarouselSlide?: InputMaybe<CarouselSlideUpdateManyInlineInput>;
  imageEvent?: InputMaybe<EventUpdateManyInlineInput>;
  imageHero?: InputMaybe<HeroUpdateManyInlineInput>;
  imageIconService?: InputMaybe<ServiceUpdateManyInlineInput>;
  imageImageContainer?: InputMaybe<ImageContainerUpdateManyInlineInput>;
  imageProject?: InputMaybe<ProjectUpdateManyInlineInput>;
  imageSectionImage?: InputMaybe<SectionWithImageUpdateManyInlineInput>;
  imageSeo?: InputMaybe<SeoUpdateManyInlineInput>;
  /** Manage document localizations */
  localizations?: InputMaybe<AssetUpdateLocalizationsInput>;
  logoNavigation?: InputMaybe<NavigationUpdateManyInlineInput>;
  logoSponsor?: InputMaybe<SponsorUpdateManyInlineInput>;
  mimeType?: InputMaybe<Scalars['String']>;
  personPhoto?: InputMaybe<PersonUpdateManyInlineInput>;
  size?: InputMaybe<Scalars['Float']>;
  width?: InputMaybe<Scalars['Float']>;
};

export type AssetUpdateLocalizationDataInput = {
  alt?: InputMaybe<Scalars['String']>;
  fileName?: InputMaybe<Scalars['String']>;
  handle?: InputMaybe<Scalars['String']>;
  height?: InputMaybe<Scalars['Float']>;
  mimeType?: InputMaybe<Scalars['String']>;
  size?: InputMaybe<Scalars['Float']>;
  width?: InputMaybe<Scalars['Float']>;
};

export type AssetUpdateLocalizationInput = {
  data: AssetUpdateLocalizationDataInput;
  locale: Locale;
};

export type AssetUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<AssetCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<AssetUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<AssetUpsertLocalizationInput>>;
};

export type AssetUpdateManyInlineInput = {
  /** Connect multiple existing Asset documents */
  connect?: InputMaybe<Array<AssetConnectInput>>;
  /** Create and connect multiple Asset documents */
  create?: InputMaybe<Array<AssetCreateInput>>;
  /** Delete multiple Asset documents */
  delete?: InputMaybe<Array<AssetWhereUniqueInput>>;
  /** Disconnect multiple Asset documents */
  disconnect?: InputMaybe<Array<AssetWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing Asset documents */
  set?: InputMaybe<Array<AssetWhereUniqueInput>>;
  /** Update multiple Asset documents */
  update?: InputMaybe<Array<AssetUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple Asset documents */
  upsert?: InputMaybe<Array<AssetUpsertWithNestedWhereUniqueInput>>;
};

export type AssetUpdateManyInput = {
  /** alt input for default locale (en) */
  alt?: InputMaybe<Scalars['String']>;
  fileName?: InputMaybe<Scalars['String']>;
  height?: InputMaybe<Scalars['Float']>;
  /** Optional updates to localizations */
  localizations?: InputMaybe<AssetUpdateManyLocalizationsInput>;
  mimeType?: InputMaybe<Scalars['String']>;
  size?: InputMaybe<Scalars['Float']>;
  width?: InputMaybe<Scalars['Float']>;
};

export type AssetUpdateManyLocalizationDataInput = {
  alt?: InputMaybe<Scalars['String']>;
  fileName?: InputMaybe<Scalars['String']>;
  height?: InputMaybe<Scalars['Float']>;
  mimeType?: InputMaybe<Scalars['String']>;
  size?: InputMaybe<Scalars['Float']>;
  width?: InputMaybe<Scalars['Float']>;
};

export type AssetUpdateManyLocalizationInput = {
  data: AssetUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type AssetUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<AssetUpdateManyLocalizationInput>>;
};

export type AssetUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: AssetUpdateManyInput;
  /** Document search */
  where: AssetWhereInput;
};

export type AssetUpdateOneInlineInput = {
  /** Connect existing Asset document */
  connect?: InputMaybe<AssetWhereUniqueInput>;
  /** Create and connect one Asset document */
  create?: InputMaybe<AssetCreateInput>;
  /** Delete currently connected Asset document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected Asset document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single Asset document */
  update?: InputMaybe<AssetUpdateWithNestedWhereUniqueInput>;
  /** Upsert single Asset document */
  upsert?: InputMaybe<AssetUpsertWithNestedWhereUniqueInput>;
};

export type AssetUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: AssetUpdateInput;
  /** Unique document search */
  where: AssetWhereUniqueInput;
};

export type AssetUpsertInput = {
  /** Create document if it didn't exist */
  create: AssetCreateInput;
  /** Update document if it exists */
  update: AssetUpdateInput;
};

export type AssetUpsertLocalizationInput = {
  create: AssetCreateLocalizationDataInput;
  locale: Locale;
  update: AssetUpdateLocalizationDataInput;
};

export type AssetUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: AssetUpsertInput;
  /** Unique document search */
  where: AssetWhereUniqueInput;
};

/** Identifies documents */
export type AssetWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<AssetWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<AssetWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<AssetWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  alt?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  alt_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  alt_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  alt_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  alt_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  alt_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  alt_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  alt_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  alt_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  alt_starts_with?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  fileName?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  fileName_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  fileName_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  fileName_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  fileName_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  fileName_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  fileName_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  fileName_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  fileName_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  fileName_starts_with?: InputMaybe<Scalars['String']>;
  galleryEvent_every?: InputMaybe<EventWhereInput>;
  galleryEvent_none?: InputMaybe<EventWhereInput>;
  galleryEvent_some?: InputMaybe<EventWhereInput>;
  gelleryProject_every?: InputMaybe<ProjectWhereInput>;
  gelleryProject_none?: InputMaybe<ProjectWhereInput>;
  gelleryProject_some?: InputMaybe<ProjectWhereInput>;
  handle?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  handle_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  handle_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  handle_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  handle_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  handle_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  handle_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  handle_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  handle_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  handle_starts_with?: InputMaybe<Scalars['String']>;
  height?: InputMaybe<Scalars['Float']>;
  /** All values greater than the given value. */
  height_gt?: InputMaybe<Scalars['Float']>;
  /** All values greater than or equal the given value. */
  height_gte?: InputMaybe<Scalars['Float']>;
  /** All values that are contained in given list. */
  height_in?: InputMaybe<Array<InputMaybe<Scalars['Float']>>>;
  /** All values less than the given value. */
  height_lt?: InputMaybe<Scalars['Float']>;
  /** All values less than or equal the given value. */
  height_lte?: InputMaybe<Scalars['Float']>;
  /** All values that are not equal to given value. */
  height_not?: InputMaybe<Scalars['Float']>;
  /** All values that are not contained in given list. */
  height_not_in?: InputMaybe<Array<InputMaybe<Scalars['Float']>>>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  imageEvent_every?: InputMaybe<EventWhereInput>;
  imageEvent_none?: InputMaybe<EventWhereInput>;
  imageEvent_some?: InputMaybe<EventWhereInput>;
  imageIconService_every?: InputMaybe<ServiceWhereInput>;
  imageIconService_none?: InputMaybe<ServiceWhereInput>;
  imageIconService_some?: InputMaybe<ServiceWhereInput>;
  imageProject_every?: InputMaybe<ProjectWhereInput>;
  imageProject_none?: InputMaybe<ProjectWhereInput>;
  imageProject_some?: InputMaybe<ProjectWhereInput>;
  logoSponsor_every?: InputMaybe<SponsorWhereInput>;
  logoSponsor_none?: InputMaybe<SponsorWhereInput>;
  logoSponsor_some?: InputMaybe<SponsorWhereInput>;
  mimeType?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  mimeType_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  mimeType_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  mimeType_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  mimeType_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  mimeType_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  mimeType_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  mimeType_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  mimeType_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  mimeType_starts_with?: InputMaybe<Scalars['String']>;
  personPhoto_every?: InputMaybe<PersonWhereInput>;
  personPhoto_none?: InputMaybe<PersonWhereInput>;
  personPhoto_some?: InputMaybe<PersonWhereInput>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  size?: InputMaybe<Scalars['Float']>;
  /** All values greater than the given value. */
  size_gt?: InputMaybe<Scalars['Float']>;
  /** All values greater than or equal the given value. */
  size_gte?: InputMaybe<Scalars['Float']>;
  /** All values that are contained in given list. */
  size_in?: InputMaybe<Array<InputMaybe<Scalars['Float']>>>;
  /** All values less than the given value. */
  size_lt?: InputMaybe<Scalars['Float']>;
  /** All values less than or equal the given value. */
  size_lte?: InputMaybe<Scalars['Float']>;
  /** All values that are not equal to given value. */
  size_not?: InputMaybe<Scalars['Float']>;
  /** All values that are not contained in given list. */
  size_not_in?: InputMaybe<Array<InputMaybe<Scalars['Float']>>>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
  width?: InputMaybe<Scalars['Float']>;
  /** All values greater than the given value. */
  width_gt?: InputMaybe<Scalars['Float']>;
  /** All values greater than or equal the given value. */
  width_gte?: InputMaybe<Scalars['Float']>;
  /** All values that are contained in given list. */
  width_in?: InputMaybe<Array<InputMaybe<Scalars['Float']>>>;
  /** All values less than the given value. */
  width_lt?: InputMaybe<Scalars['Float']>;
  /** All values less than or equal the given value. */
  width_lte?: InputMaybe<Scalars['Float']>;
  /** All values that are not equal to given value. */
  width_not?: InputMaybe<Scalars['Float']>;
  /** All values that are not contained in given list. */
  width_not_in?: InputMaybe<Array<InputMaybe<Scalars['Float']>>>;
};

/** References Asset record uniquely */
export type AssetWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

/** This section contains all important fact about the association */
export type AssociationProfileSection = {
  __typename?: 'AssociationProfileSection';
  backgroundImage?: Maybe<Asset>;
  facts: Array<Fact>;
  /** The unique identifier */
  id: Scalars['ID'];
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<AssociationProfileSection>;
  slogan?: Maybe<Scalars['String']>;
  /** System stage field */
  stage: Stage;
};


/** This section contains all important fact about the association */
export type AssociationProfileSectionBackgroundImageArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


/** This section contains all important fact about the association */
export type AssociationProfileSectionFactsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  orderBy?: InputMaybe<FactOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<FactWhereInput>;
};


/** This section contains all important fact about the association */
export type AssociationProfileSectionLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};

export type AssociationProfileSectionConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: AssociationProfileSectionWhereUniqueInput;
};

/** A connection to a list of items. */
export type AssociationProfileSectionConnection = {
  __typename?: 'AssociationProfileSectionConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<AssociationProfileSectionEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type AssociationProfileSectionCreateInput = {
  backgroundImage?: InputMaybe<AssetCreateOneInlineInput>;
  facts?: InputMaybe<FactCreateManyInlineInput>;
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<AssociationProfileSectionCreateLocalizationsInput>;
  /** slogan input for default locale (en) */
  slogan?: InputMaybe<Scalars['String']>;
};

export type AssociationProfileSectionCreateLocalizationDataInput = {
  slogan?: InputMaybe<Scalars['String']>;
};

export type AssociationProfileSectionCreateLocalizationInput = {
  /** Localization input */
  data: AssociationProfileSectionCreateLocalizationDataInput;
  locale: Locale;
};

export type AssociationProfileSectionCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<AssociationProfileSectionCreateLocalizationInput>>;
};

export type AssociationProfileSectionCreateManyInlineInput = {
  /** Create and connect multiple existing AssociationProfileSection documents */
  create?: InputMaybe<Array<AssociationProfileSectionCreateInput>>;
};

export type AssociationProfileSectionCreateOneInlineInput = {
  /** Create and connect one AssociationProfileSection document */
  create?: InputMaybe<AssociationProfileSectionCreateInput>;
};

export type AssociationProfileSectionCreateWithPositionInput = {
  /** Document to create */
  data: AssociationProfileSectionCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type AssociationProfileSectionEdge = {
  __typename?: 'AssociationProfileSectionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: AssociationProfileSection;
};

/** Identifies documents */
export type AssociationProfileSectionManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<AssociationProfileSectionWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<AssociationProfileSectionWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<AssociationProfileSectionWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  backgroundImage?: InputMaybe<AssetWhereInput>;
  facts_every?: InputMaybe<FactWhereInput>;
  facts_none?: InputMaybe<FactWhereInput>;
  facts_some?: InputMaybe<FactWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
};

export enum AssociationProfileSectionOrderByInput {
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  SloganAsc = 'slogan_ASC',
  SloganDesc = 'slogan_DESC'
}

export type AssociationProfileSectionParent = Page;

export type AssociationProfileSectionParentConnectInput = {
  Page?: InputMaybe<PageConnectInput>;
};

export type AssociationProfileSectionParentCreateInput = {
  Page?: InputMaybe<PageCreateInput>;
};

export type AssociationProfileSectionParentCreateManyInlineInput = {
  /** Connect multiple existing AssociationProfileSectionParent documents */
  connect?: InputMaybe<Array<AssociationProfileSectionParentWhereUniqueInput>>;
  /** Create and connect multiple existing AssociationProfileSectionParent documents */
  create?: InputMaybe<Array<AssociationProfileSectionParentCreateInput>>;
};

export type AssociationProfileSectionParentCreateOneInlineInput = {
  /** Connect one existing AssociationProfileSectionParent document */
  connect?: InputMaybe<AssociationProfileSectionParentWhereUniqueInput>;
  /** Create and connect one AssociationProfileSectionParent document */
  create?: InputMaybe<AssociationProfileSectionParentCreateInput>;
};

export type AssociationProfileSectionParentUpdateInput = {
  Page?: InputMaybe<PageUpdateInput>;
};

export type AssociationProfileSectionParentUpdateManyInlineInput = {
  /** Connect multiple existing AssociationProfileSectionParent documents */
  connect?: InputMaybe<Array<AssociationProfileSectionParentConnectInput>>;
  /** Create and connect multiple AssociationProfileSectionParent documents */
  create?: InputMaybe<Array<AssociationProfileSectionParentCreateInput>>;
  /** Delete multiple AssociationProfileSectionParent documents */
  delete?: InputMaybe<Array<AssociationProfileSectionParentWhereUniqueInput>>;
  /** Disconnect multiple AssociationProfileSectionParent documents */
  disconnect?: InputMaybe<Array<AssociationProfileSectionParentWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing AssociationProfileSectionParent documents */
  set?: InputMaybe<Array<AssociationProfileSectionParentWhereUniqueInput>>;
  /** Update multiple AssociationProfileSectionParent documents */
  update?: InputMaybe<Array<AssociationProfileSectionParentUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple AssociationProfileSectionParent documents */
  upsert?: InputMaybe<Array<AssociationProfileSectionParentUpsertWithNestedWhereUniqueInput>>;
};

export type AssociationProfileSectionParentUpdateManyWithNestedWhereInput = {
  Page?: InputMaybe<PageUpdateManyWithNestedWhereInput>;
};

export type AssociationProfileSectionParentUpdateOneInlineInput = {
  /** Connect existing AssociationProfileSectionParent document */
  connect?: InputMaybe<AssociationProfileSectionParentWhereUniqueInput>;
  /** Create and connect one AssociationProfileSectionParent document */
  create?: InputMaybe<AssociationProfileSectionParentCreateInput>;
  /** Delete currently connected AssociationProfileSectionParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected AssociationProfileSectionParent document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single AssociationProfileSectionParent document */
  update?: InputMaybe<AssociationProfileSectionParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single AssociationProfileSectionParent document */
  upsert?: InputMaybe<AssociationProfileSectionParentUpsertWithNestedWhereUniqueInput>;
};

export type AssociationProfileSectionParentUpdateWithNestedWhereUniqueInput = {
  Page?: InputMaybe<PageUpdateWithNestedWhereUniqueInput>;
};

export type AssociationProfileSectionParentUpsertWithNestedWhereUniqueInput = {
  Page?: InputMaybe<PageUpsertWithNestedWhereUniqueInput>;
};

export type AssociationProfileSectionParentWhereInput = {
  Page?: InputMaybe<PageWhereInput>;
};

export type AssociationProfileSectionParentWhereUniqueInput = {
  Page?: InputMaybe<PageWhereUniqueInput>;
};

export type AssociationProfileSectionUpdateInput = {
  backgroundImage?: InputMaybe<AssetUpdateOneInlineInput>;
  facts?: InputMaybe<FactUpdateManyInlineInput>;
  /** Manage document localizations */
  localizations?: InputMaybe<AssociationProfileSectionUpdateLocalizationsInput>;
  /** slogan input for default locale (en) */
  slogan?: InputMaybe<Scalars['String']>;
};

export type AssociationProfileSectionUpdateLocalizationDataInput = {
  slogan?: InputMaybe<Scalars['String']>;
};

export type AssociationProfileSectionUpdateLocalizationInput = {
  data: AssociationProfileSectionUpdateLocalizationDataInput;
  locale: Locale;
};

export type AssociationProfileSectionUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<AssociationProfileSectionCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<AssociationProfileSectionUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<AssociationProfileSectionUpsertLocalizationInput>>;
};

export type AssociationProfileSectionUpdateManyInlineInput = {
  /** Create and connect multiple AssociationProfileSection component instances */
  create?: InputMaybe<Array<AssociationProfileSectionCreateWithPositionInput>>;
  /** Delete multiple AssociationProfileSection documents */
  delete?: InputMaybe<Array<AssociationProfileSectionWhereUniqueInput>>;
  /** Update multiple AssociationProfileSection component instances */
  update?: InputMaybe<Array<AssociationProfileSectionUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple AssociationProfileSection component instances */
  upsert?: InputMaybe<Array<AssociationProfileSectionUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type AssociationProfileSectionUpdateManyInput = {
  /** Optional updates to localizations */
  localizations?: InputMaybe<AssociationProfileSectionUpdateManyLocalizationsInput>;
  /** slogan input for default locale (en) */
  slogan?: InputMaybe<Scalars['String']>;
};

export type AssociationProfileSectionUpdateManyLocalizationDataInput = {
  slogan?: InputMaybe<Scalars['String']>;
};

export type AssociationProfileSectionUpdateManyLocalizationInput = {
  data: AssociationProfileSectionUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type AssociationProfileSectionUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<AssociationProfileSectionUpdateManyLocalizationInput>>;
};

export type AssociationProfileSectionUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: AssociationProfileSectionUpdateManyInput;
  /** Document search */
  where: AssociationProfileSectionWhereInput;
};

export type AssociationProfileSectionUpdateOneInlineInput = {
  /** Create and connect one AssociationProfileSection document */
  create?: InputMaybe<AssociationProfileSectionCreateInput>;
  /** Delete currently connected AssociationProfileSection document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single AssociationProfileSection document */
  update?: InputMaybe<AssociationProfileSectionUpdateWithNestedWhereUniqueInput>;
  /** Upsert single AssociationProfileSection document */
  upsert?: InputMaybe<AssociationProfileSectionUpsertWithNestedWhereUniqueInput>;
};

export type AssociationProfileSectionUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<AssociationProfileSectionUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: AssociationProfileSectionWhereUniqueInput;
};

export type AssociationProfileSectionUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: AssociationProfileSectionUpdateInput;
  /** Unique document search */
  where: AssociationProfileSectionWhereUniqueInput;
};

export type AssociationProfileSectionUpsertInput = {
  /** Create document if it didn't exist */
  create: AssociationProfileSectionCreateInput;
  /** Update document if it exists */
  update: AssociationProfileSectionUpdateInput;
};

export type AssociationProfileSectionUpsertLocalizationInput = {
  create: AssociationProfileSectionCreateLocalizationDataInput;
  locale: Locale;
  update: AssociationProfileSectionUpdateLocalizationDataInput;
};

export type AssociationProfileSectionUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<AssociationProfileSectionUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: AssociationProfileSectionWhereUniqueInput;
};

export type AssociationProfileSectionUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: AssociationProfileSectionUpsertInput;
  /** Unique document search */
  where: AssociationProfileSectionWhereUniqueInput;
};

/** Identifies documents */
export type AssociationProfileSectionWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<AssociationProfileSectionWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<AssociationProfileSectionWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<AssociationProfileSectionWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  backgroundImage?: InputMaybe<AssetWhereInput>;
  facts_every?: InputMaybe<FactWhereInput>;
  facts_none?: InputMaybe<FactWhereInput>;
  facts_some?: InputMaybe<FactWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  slogan?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  slogan_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  slogan_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  slogan_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  slogan_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  slogan_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  slogan_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  slogan_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  slogan_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  slogan_starts_with?: InputMaybe<Scalars['String']>;
};

/** References AssociationProfileSection record uniquely */
export type AssociationProfileSectionWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export type BatchPayload = {
  __typename?: 'BatchPayload';
  /** The number of nodes that have been affected by the Batch operation. */
  count: Scalars['Long'];
};

export type Button = Node & {
  __typename?: 'Button';
  card?: Maybe<Card>;
  container?: Maybe<Container>;
  /** The time the document was created */
  createdAt: Scalars['DateTime'];
  /** User that created this document */
  createdBy?: Maybe<User>;
  /** Get the document in other stages */
  documentInStages: Array<Button>;
  /** List of Button versions */
  history: Array<Version>;
  href?: Maybe<Scalars['String']>;
  /** The unique identifier */
  id: Scalars['ID'];
  label: Scalars['String'];
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<Button>;
  /** The time the document was published. Null on documents in draft stage. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** User that last published this document */
  publishedBy?: Maybe<User>;
  scheduledIn: Array<ScheduledOperation>;
  /** System stage field */
  stage: Stage;
  theme?: Maybe<Theme>;
  /** The time the document was updated */
  updatedAt: Scalars['DateTime'];
  /** User that last updated this document */
  updatedBy?: Maybe<User>;
};


export type ButtonCardArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type ButtonContainerArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type ButtonCreatedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type ButtonCreatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type ButtonDocumentInStagesArgs = {
  includeCurrent?: Scalars['Boolean'];
  inheritLocale?: Scalars['Boolean'];
  stages?: Array<Stage>;
};


export type ButtonHistoryArgs = {
  limit?: Scalars['Int'];
  skip?: Scalars['Int'];
  stageOverride?: InputMaybe<Stage>;
};


export type ButtonLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};


export type ButtonPublishedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type ButtonPublishedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type ButtonScheduledInArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ScheduledOperationWhereInput>;
};


export type ButtonUpdatedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type ButtonUpdatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};

export type ButtonConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: ButtonWhereUniqueInput;
};

/** A connection to a list of items. */
export type ButtonConnection = {
  __typename?: 'ButtonConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<ButtonEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type ButtonCreateInput = {
  card?: InputMaybe<CardCreateOneInlineInput>;
  cl6img91m4omg01uh6p2qdjpb?: InputMaybe<NavigationCreateManyInlineInput>;
  container?: InputMaybe<ContainerCreateOneInlineInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  href?: InputMaybe<Scalars['String']>;
  /** label input for default locale (en) */
  label: Scalars['String'];
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<ButtonCreateLocalizationsInput>;
  theme?: InputMaybe<Theme>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type ButtonCreateLocalizationDataInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  label: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type ButtonCreateLocalizationInput = {
  /** Localization input */
  data: ButtonCreateLocalizationDataInput;
  locale: Locale;
};

export type ButtonCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<ButtonCreateLocalizationInput>>;
};

export type ButtonCreateManyInlineInput = {
  /** Connect multiple existing Button documents */
  connect?: InputMaybe<Array<ButtonWhereUniqueInput>>;
  /** Create and connect multiple existing Button documents */
  create?: InputMaybe<Array<ButtonCreateInput>>;
};

export type ButtonCreateOneInlineInput = {
  /** Connect one existing Button document */
  connect?: InputMaybe<ButtonWhereUniqueInput>;
  /** Create and connect one Button document */
  create?: InputMaybe<ButtonCreateInput>;
};

/** An edge in a connection. */
export type ButtonEdge = {
  __typename?: 'ButtonEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Button;
};

/** Identifies documents */
export type ButtonManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<ButtonWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<ButtonWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<ButtonWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  card?: InputMaybe<CardWhereInput>;
  container?: InputMaybe<ContainerWhereInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  href?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  href_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  href_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  href_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  href_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  href_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  href_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  href_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  href_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  href_starts_with?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  theme?: InputMaybe<Theme>;
  /** All values that are contained in given list. */
  theme_in?: InputMaybe<Array<InputMaybe<Theme>>>;
  /** All values that are not equal to given value. */
  theme_not?: InputMaybe<Theme>;
  /** All values that are not contained in given list. */
  theme_not_in?: InputMaybe<Array<InputMaybe<Theme>>>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

export enum ButtonOrderByInput {
  CreatedAtAsc = 'createdAt_ASC',
  CreatedAtDesc = 'createdAt_DESC',
  HrefAsc = 'href_ASC',
  HrefDesc = 'href_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  LabelAsc = 'label_ASC',
  LabelDesc = 'label_DESC',
  PublishedAtAsc = 'publishedAt_ASC',
  PublishedAtDesc = 'publishedAt_DESC',
  ThemeAsc = 'theme_ASC',
  ThemeDesc = 'theme_DESC',
  UpdatedAtAsc = 'updatedAt_ASC',
  UpdatedAtDesc = 'updatedAt_DESC'
}

export enum ButtonTheme {
  OutlinePrimary = 'OUTLINE_PRIMARY',
  OutlineWhite = 'OUTLINE_WHITE',
  Solid = 'SOLID'
}

export type ButtonUpdateInput = {
  card?: InputMaybe<CardUpdateOneInlineInput>;
  cl6img91m4omg01uh6p2qdjpb?: InputMaybe<NavigationUpdateManyInlineInput>;
  container?: InputMaybe<ContainerUpdateOneInlineInput>;
  href?: InputMaybe<Scalars['String']>;
  /** label input for default locale (en) */
  label?: InputMaybe<Scalars['String']>;
  /** Manage document localizations */
  localizations?: InputMaybe<ButtonUpdateLocalizationsInput>;
  theme?: InputMaybe<Theme>;
};

export type ButtonUpdateLocalizationDataInput = {
  label?: InputMaybe<Scalars['String']>;
};

export type ButtonUpdateLocalizationInput = {
  data: ButtonUpdateLocalizationDataInput;
  locale: Locale;
};

export type ButtonUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<ButtonCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<ButtonUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<ButtonUpsertLocalizationInput>>;
};

export type ButtonUpdateManyInlineInput = {
  /** Connect multiple existing Button documents */
  connect?: InputMaybe<Array<ButtonConnectInput>>;
  /** Create and connect multiple Button documents */
  create?: InputMaybe<Array<ButtonCreateInput>>;
  /** Delete multiple Button documents */
  delete?: InputMaybe<Array<ButtonWhereUniqueInput>>;
  /** Disconnect multiple Button documents */
  disconnect?: InputMaybe<Array<ButtonWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing Button documents */
  set?: InputMaybe<Array<ButtonWhereUniqueInput>>;
  /** Update multiple Button documents */
  update?: InputMaybe<Array<ButtonUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple Button documents */
  upsert?: InputMaybe<Array<ButtonUpsertWithNestedWhereUniqueInput>>;
};

export type ButtonUpdateManyInput = {
  /** label input for default locale (en) */
  label?: InputMaybe<Scalars['String']>;
  /** Optional updates to localizations */
  localizations?: InputMaybe<ButtonUpdateManyLocalizationsInput>;
  theme?: InputMaybe<Theme>;
};

export type ButtonUpdateManyLocalizationDataInput = {
  label?: InputMaybe<Scalars['String']>;
};

export type ButtonUpdateManyLocalizationInput = {
  data: ButtonUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type ButtonUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<ButtonUpdateManyLocalizationInput>>;
};

export type ButtonUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: ButtonUpdateManyInput;
  /** Document search */
  where: ButtonWhereInput;
};

export type ButtonUpdateOneInlineInput = {
  /** Connect existing Button document */
  connect?: InputMaybe<ButtonWhereUniqueInput>;
  /** Create and connect one Button document */
  create?: InputMaybe<ButtonCreateInput>;
  /** Delete currently connected Button document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected Button document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single Button document */
  update?: InputMaybe<ButtonUpdateWithNestedWhereUniqueInput>;
  /** Upsert single Button document */
  upsert?: InputMaybe<ButtonUpsertWithNestedWhereUniqueInput>;
};

export type ButtonUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: ButtonUpdateInput;
  /** Unique document search */
  where: ButtonWhereUniqueInput;
};

export type ButtonUpsertInput = {
  /** Create document if it didn't exist */
  create: ButtonCreateInput;
  /** Update document if it exists */
  update: ButtonUpdateInput;
};

export type ButtonUpsertLocalizationInput = {
  create: ButtonCreateLocalizationDataInput;
  locale: Locale;
  update: ButtonUpdateLocalizationDataInput;
};

export type ButtonUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: ButtonUpsertInput;
  /** Unique document search */
  where: ButtonWhereUniqueInput;
};

/** Identifies documents */
export type ButtonWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<ButtonWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<ButtonWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<ButtonWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  card?: InputMaybe<CardWhereInput>;
  container?: InputMaybe<ContainerWhereInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  href?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  href_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  href_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  href_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  href_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  href_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  href_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  href_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  href_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  href_starts_with?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  label?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  label_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  label_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  label_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  label_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  label_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  label_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  label_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  label_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  label_starts_with?: InputMaybe<Scalars['String']>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  theme?: InputMaybe<Theme>;
  /** All values that are contained in given list. */
  theme_in?: InputMaybe<Array<InputMaybe<Theme>>>;
  /** All values that are not equal to given value. */
  theme_not?: InputMaybe<Theme>;
  /** All values that are not contained in given list. */
  theme_not_in?: InputMaybe<Array<InputMaybe<Theme>>>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

/** References Button record uniquely */
export type ButtonWhereUniqueInput = {
  href?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
};

export type Card = Node & {
  __typename?: 'Card';
  container?: Maybe<Container>;
  /** The time the document was created */
  createdAt: Scalars['DateTime'];
  /** User that created this document */
  createdBy?: Maybe<User>;
  ctas?: Maybe<CardCtas>;
  /** Get the document in other stages */
  documentInStages: Array<Card>;
  /** List of Card versions */
  history: Array<Version>;
  /** The unique identifier */
  id: Scalars['ID'];
  item: Array<CardItem>;
  /** The time the document was published. Null on documents in draft stage. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** User that last published this document */
  publishedBy?: Maybe<User>;
  scheduledIn: Array<ScheduledOperation>;
  /** System stage field */
  stage: Stage;
  type?: Maybe<CardType>;
  /** The time the document was updated */
  updatedAt: Scalars['DateTime'];
  /** User that last updated this document */
  updatedBy?: Maybe<User>;
};


export type CardContainerArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type CardCreatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type CardCtasArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type CardDocumentInStagesArgs = {
  includeCurrent?: Scalars['Boolean'];
  inheritLocale?: Scalars['Boolean'];
  stages?: Array<Stage>;
};


export type CardHistoryArgs = {
  limit?: Scalars['Int'];
  skip?: Scalars['Int'];
  stageOverride?: InputMaybe<Stage>;
};


export type CardItemArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
};


export type CardPublishedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type CardScheduledInArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ScheduledOperationWhereInput>;
};


export type CardUpdatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};

export type CardConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: CardWhereUniqueInput;
};

/** A connection to a list of items. */
export type CardConnection = {
  __typename?: 'CardConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<CardEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type CardCreateInput = {
  container?: InputMaybe<ContainerCreateOneInlineInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  ctas?: InputMaybe<CardCtasCreateOneInlineInput>;
  item?: InputMaybe<CardItemCreateManyInlineInput>;
  type?: InputMaybe<CardType>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type CardCreateManyInlineInput = {
  /** Connect multiple existing Card documents */
  connect?: InputMaybe<Array<CardWhereUniqueInput>>;
  /** Create and connect multiple existing Card documents */
  create?: InputMaybe<Array<CardCreateInput>>;
};

export type CardCreateOneInlineInput = {
  /** Connect one existing Card document */
  connect?: InputMaybe<CardWhereUniqueInput>;
  /** Create and connect one Card document */
  create?: InputMaybe<CardCreateInput>;
};

export type CardCtas = Button;

export type CardCtasConnectInput = {
  Button?: InputMaybe<ButtonConnectInput>;
};

export type CardCtasCreateInput = {
  Button?: InputMaybe<ButtonCreateInput>;
};

export type CardCtasCreateManyInlineInput = {
  /** Connect multiple existing CardCtas documents */
  connect?: InputMaybe<Array<CardCtasWhereUniqueInput>>;
  /** Create and connect multiple existing CardCtas documents */
  create?: InputMaybe<Array<CardCtasCreateInput>>;
};

export type CardCtasCreateOneInlineInput = {
  /** Connect one existing CardCtas document */
  connect?: InputMaybe<CardCtasWhereUniqueInput>;
  /** Create and connect one CardCtas document */
  create?: InputMaybe<CardCtasCreateInput>;
};

export type CardCtasUpdateInput = {
  Button?: InputMaybe<ButtonUpdateInput>;
};

export type CardCtasUpdateManyInlineInput = {
  /** Connect multiple existing CardCtas documents */
  connect?: InputMaybe<Array<CardCtasConnectInput>>;
  /** Create and connect multiple CardCtas documents */
  create?: InputMaybe<Array<CardCtasCreateInput>>;
  /** Delete multiple CardCtas documents */
  delete?: InputMaybe<Array<CardCtasWhereUniqueInput>>;
  /** Disconnect multiple CardCtas documents */
  disconnect?: InputMaybe<Array<CardCtasWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing CardCtas documents */
  set?: InputMaybe<Array<CardCtasWhereUniqueInput>>;
  /** Update multiple CardCtas documents */
  update?: InputMaybe<Array<CardCtasUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple CardCtas documents */
  upsert?: InputMaybe<Array<CardCtasUpsertWithNestedWhereUniqueInput>>;
};

export type CardCtasUpdateManyWithNestedWhereInput = {
  Button?: InputMaybe<ButtonUpdateManyWithNestedWhereInput>;
};

export type CardCtasUpdateOneInlineInput = {
  /** Connect existing CardCtas document */
  connect?: InputMaybe<CardCtasWhereUniqueInput>;
  /** Create and connect one CardCtas document */
  create?: InputMaybe<CardCtasCreateInput>;
  /** Delete currently connected CardCtas document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected CardCtas document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single CardCtas document */
  update?: InputMaybe<CardCtasUpdateWithNestedWhereUniqueInput>;
  /** Upsert single CardCtas document */
  upsert?: InputMaybe<CardCtasUpsertWithNestedWhereUniqueInput>;
};

export type CardCtasUpdateWithNestedWhereUniqueInput = {
  Button?: InputMaybe<ButtonUpdateWithNestedWhereUniqueInput>;
};

export type CardCtasUpsertWithNestedWhereUniqueInput = {
  Button?: InputMaybe<ButtonUpsertWithNestedWhereUniqueInput>;
};

export type CardCtasWhereInput = {
  Button?: InputMaybe<ButtonWhereInput>;
};

export type CardCtasWhereUniqueInput = {
  Button?: InputMaybe<ButtonWhereUniqueInput>;
};

/** An edge in a connection. */
export type CardEdge = {
  __typename?: 'CardEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Card;
};

export type CardItem = Event | Person | Project | Service | Sponsor;

export type CardItemConnectInput = {
  Event?: InputMaybe<EventConnectInput>;
  Person?: InputMaybe<PersonConnectInput>;
  Project?: InputMaybe<ProjectConnectInput>;
  Service?: InputMaybe<ServiceConnectInput>;
  Sponsor?: InputMaybe<SponsorConnectInput>;
};

export type CardItemCreateInput = {
  Event?: InputMaybe<EventCreateInput>;
  Person?: InputMaybe<PersonCreateInput>;
  Project?: InputMaybe<ProjectCreateInput>;
  Service?: InputMaybe<ServiceCreateInput>;
  Sponsor?: InputMaybe<SponsorCreateInput>;
};

export type CardItemCreateManyInlineInput = {
  /** Connect multiple existing CardItem documents */
  connect?: InputMaybe<Array<CardItemWhereUniqueInput>>;
  /** Create and connect multiple existing CardItem documents */
  create?: InputMaybe<Array<CardItemCreateInput>>;
};

export type CardItemCreateOneInlineInput = {
  /** Connect one existing CardItem document */
  connect?: InputMaybe<CardItemWhereUniqueInput>;
  /** Create and connect one CardItem document */
  create?: InputMaybe<CardItemCreateInput>;
};

export type CardItemUpdateInput = {
  Event?: InputMaybe<EventUpdateInput>;
  Person?: InputMaybe<PersonUpdateInput>;
  Project?: InputMaybe<ProjectUpdateInput>;
  Service?: InputMaybe<ServiceUpdateInput>;
  Sponsor?: InputMaybe<SponsorUpdateInput>;
};

export type CardItemUpdateManyInlineInput = {
  /** Connect multiple existing CardItem documents */
  connect?: InputMaybe<Array<CardItemConnectInput>>;
  /** Create and connect multiple CardItem documents */
  create?: InputMaybe<Array<CardItemCreateInput>>;
  /** Delete multiple CardItem documents */
  delete?: InputMaybe<Array<CardItemWhereUniqueInput>>;
  /** Disconnect multiple CardItem documents */
  disconnect?: InputMaybe<Array<CardItemWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing CardItem documents */
  set?: InputMaybe<Array<CardItemWhereUniqueInput>>;
  /** Update multiple CardItem documents */
  update?: InputMaybe<Array<CardItemUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple CardItem documents */
  upsert?: InputMaybe<Array<CardItemUpsertWithNestedWhereUniqueInput>>;
};

export type CardItemUpdateManyWithNestedWhereInput = {
  Event?: InputMaybe<EventUpdateManyWithNestedWhereInput>;
  Person?: InputMaybe<PersonUpdateManyWithNestedWhereInput>;
  Project?: InputMaybe<ProjectUpdateManyWithNestedWhereInput>;
  Service?: InputMaybe<ServiceUpdateManyWithNestedWhereInput>;
  Sponsor?: InputMaybe<SponsorUpdateManyWithNestedWhereInput>;
};

export type CardItemUpdateOneInlineInput = {
  /** Connect existing CardItem document */
  connect?: InputMaybe<CardItemWhereUniqueInput>;
  /** Create and connect one CardItem document */
  create?: InputMaybe<CardItemCreateInput>;
  /** Delete currently connected CardItem document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected CardItem document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single CardItem document */
  update?: InputMaybe<CardItemUpdateWithNestedWhereUniqueInput>;
  /** Upsert single CardItem document */
  upsert?: InputMaybe<CardItemUpsertWithNestedWhereUniqueInput>;
};

export type CardItemUpdateWithNestedWhereUniqueInput = {
  Event?: InputMaybe<EventUpdateWithNestedWhereUniqueInput>;
  Person?: InputMaybe<PersonUpdateWithNestedWhereUniqueInput>;
  Project?: InputMaybe<ProjectUpdateWithNestedWhereUniqueInput>;
  Service?: InputMaybe<ServiceUpdateWithNestedWhereUniqueInput>;
  Sponsor?: InputMaybe<SponsorUpdateWithNestedWhereUniqueInput>;
};

export type CardItemUpsertWithNestedWhereUniqueInput = {
  Event?: InputMaybe<EventUpsertWithNestedWhereUniqueInput>;
  Person?: InputMaybe<PersonUpsertWithNestedWhereUniqueInput>;
  Project?: InputMaybe<ProjectUpsertWithNestedWhereUniqueInput>;
  Service?: InputMaybe<ServiceUpsertWithNestedWhereUniqueInput>;
  Sponsor?: InputMaybe<SponsorUpsertWithNestedWhereUniqueInput>;
};

export type CardItemWhereInput = {
  Event?: InputMaybe<EventWhereInput>;
  Person?: InputMaybe<PersonWhereInput>;
  Project?: InputMaybe<ProjectWhereInput>;
  Service?: InputMaybe<ServiceWhereInput>;
  Sponsor?: InputMaybe<SponsorWhereInput>;
};

export type CardItemWhereUniqueInput = {
  Event?: InputMaybe<EventWhereUniqueInput>;
  Person?: InputMaybe<PersonWhereUniqueInput>;
  Project?: InputMaybe<ProjectWhereUniqueInput>;
  Service?: InputMaybe<ServiceWhereUniqueInput>;
  Sponsor?: InputMaybe<SponsorWhereUniqueInput>;
};

/** Identifies documents */
export type CardManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<CardWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<CardWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<CardWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  container?: InputMaybe<ContainerWhereInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  type?: InputMaybe<CardType>;
  /** All values that are contained in given list. */
  type_in?: InputMaybe<Array<InputMaybe<CardType>>>;
  /** All values that are not equal to given value. */
  type_not?: InputMaybe<CardType>;
  /** All values that are not contained in given list. */
  type_not_in?: InputMaybe<Array<InputMaybe<CardType>>>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

export enum CardOrderByInput {
  CreatedAtAsc = 'createdAt_ASC',
  CreatedAtDesc = 'createdAt_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  PublishedAtAsc = 'publishedAt_ASC',
  PublishedAtDesc = 'publishedAt_DESC',
  TypeAsc = 'type_ASC',
  TypeDesc = 'type_DESC',
  UpdatedAtAsc = 'updatedAt_ASC',
  UpdatedAtDesc = 'updatedAt_DESC'
}

export enum CardType {
  Bigevent = 'BIGEVENT',
  Fact = 'FACT',
  HomeProject = 'HOME_PROJECT',
  Mediumevent = 'MEDIUMEVENT',
  Project = 'PROJECT',
  Service = 'SERVICE',
  Smallevent = 'SMALLEVENT'
}

export type CardUpdateInput = {
  container?: InputMaybe<ContainerUpdateOneInlineInput>;
  ctas?: InputMaybe<CardCtasUpdateOneInlineInput>;
  item?: InputMaybe<CardItemUpdateManyInlineInput>;
  type?: InputMaybe<CardType>;
};

export type CardUpdateManyInlineInput = {
  /** Connect multiple existing Card documents */
  connect?: InputMaybe<Array<CardConnectInput>>;
  /** Create and connect multiple Card documents */
  create?: InputMaybe<Array<CardCreateInput>>;
  /** Delete multiple Card documents */
  delete?: InputMaybe<Array<CardWhereUniqueInput>>;
  /** Disconnect multiple Card documents */
  disconnect?: InputMaybe<Array<CardWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing Card documents */
  set?: InputMaybe<Array<CardWhereUniqueInput>>;
  /** Update multiple Card documents */
  update?: InputMaybe<Array<CardUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple Card documents */
  upsert?: InputMaybe<Array<CardUpsertWithNestedWhereUniqueInput>>;
};

export type CardUpdateManyInput = {
  type?: InputMaybe<CardType>;
};

export type CardUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: CardUpdateManyInput;
  /** Document search */
  where: CardWhereInput;
};

export type CardUpdateOneInlineInput = {
  /** Connect existing Card document */
  connect?: InputMaybe<CardWhereUniqueInput>;
  /** Create and connect one Card document */
  create?: InputMaybe<CardCreateInput>;
  /** Delete currently connected Card document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected Card document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single Card document */
  update?: InputMaybe<CardUpdateWithNestedWhereUniqueInput>;
  /** Upsert single Card document */
  upsert?: InputMaybe<CardUpsertWithNestedWhereUniqueInput>;
};

export type CardUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: CardUpdateInput;
  /** Unique document search */
  where: CardWhereUniqueInput;
};

export type CardUpsertInput = {
  /** Create document if it didn't exist */
  create: CardCreateInput;
  /** Update document if it exists */
  update: CardUpdateInput;
};

export type CardUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: CardUpsertInput;
  /** Unique document search */
  where: CardWhereUniqueInput;
};

/** Identifies documents */
export type CardWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<CardWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<CardWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<CardWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  container?: InputMaybe<ContainerWhereInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  type?: InputMaybe<CardType>;
  /** All values that are contained in given list. */
  type_in?: InputMaybe<Array<InputMaybe<CardType>>>;
  /** All values that are not equal to given value. */
  type_not?: InputMaybe<CardType>;
  /** All values that are not contained in given list. */
  type_not_in?: InputMaybe<Array<InputMaybe<CardType>>>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

/** References Card record uniquely */
export type CardWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

/** The carousel component contains all the slide we want to run in a loop */
export type Carousel = {
  __typename?: 'Carousel';
  /** The unique identifier */
  id: Scalars['ID'];
  slides: Array<CarouselSlide>;
  /** System stage field */
  stage: Stage;
};


/** The carousel component contains all the slide we want to run in a loop */
export type CarouselSlidesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  orderBy?: InputMaybe<CarouselSlideOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CarouselSlideWhereInput>;
};

export type CarouselConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: CarouselWhereUniqueInput;
};

/** A connection to a list of items. */
export type CarouselConnection = {
  __typename?: 'CarouselConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<CarouselEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type CarouselCreateInput = {
  slides?: InputMaybe<CarouselSlideCreateManyInlineInput>;
};

export type CarouselCreateManyInlineInput = {
  /** Create and connect multiple existing Carousel documents */
  create?: InputMaybe<Array<CarouselCreateInput>>;
};

export type CarouselCreateOneInlineInput = {
  /** Create and connect one Carousel document */
  create?: InputMaybe<CarouselCreateInput>;
};

export type CarouselCreateWithPositionInput = {
  /** Document to create */
  data: CarouselCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type CarouselEdge = {
  __typename?: 'CarouselEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Carousel;
};

/** Identifies documents */
export type CarouselManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<CarouselWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<CarouselWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<CarouselWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  slides_every?: InputMaybe<CarouselSlideWhereInput>;
  slides_none?: InputMaybe<CarouselSlideWhereInput>;
  slides_some?: InputMaybe<CarouselSlideWhereInput>;
};

export enum CarouselOrderByInput {
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC'
}

export type CarouselParent = Page;

export type CarouselParentConnectInput = {
  Page?: InputMaybe<PageConnectInput>;
};

export type CarouselParentCreateInput = {
  Page?: InputMaybe<PageCreateInput>;
};

export type CarouselParentCreateManyInlineInput = {
  /** Connect multiple existing CarouselParent documents */
  connect?: InputMaybe<Array<CarouselParentWhereUniqueInput>>;
  /** Create and connect multiple existing CarouselParent documents */
  create?: InputMaybe<Array<CarouselParentCreateInput>>;
};

export type CarouselParentCreateOneInlineInput = {
  /** Connect one existing CarouselParent document */
  connect?: InputMaybe<CarouselParentWhereUniqueInput>;
  /** Create and connect one CarouselParent document */
  create?: InputMaybe<CarouselParentCreateInput>;
};

export type CarouselParentUpdateInput = {
  Page?: InputMaybe<PageUpdateInput>;
};

export type CarouselParentUpdateManyInlineInput = {
  /** Connect multiple existing CarouselParent documents */
  connect?: InputMaybe<Array<CarouselParentConnectInput>>;
  /** Create and connect multiple CarouselParent documents */
  create?: InputMaybe<Array<CarouselParentCreateInput>>;
  /** Delete multiple CarouselParent documents */
  delete?: InputMaybe<Array<CarouselParentWhereUniqueInput>>;
  /** Disconnect multiple CarouselParent documents */
  disconnect?: InputMaybe<Array<CarouselParentWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing CarouselParent documents */
  set?: InputMaybe<Array<CarouselParentWhereUniqueInput>>;
  /** Update multiple CarouselParent documents */
  update?: InputMaybe<Array<CarouselParentUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple CarouselParent documents */
  upsert?: InputMaybe<Array<CarouselParentUpsertWithNestedWhereUniqueInput>>;
};

export type CarouselParentUpdateManyWithNestedWhereInput = {
  Page?: InputMaybe<PageUpdateManyWithNestedWhereInput>;
};

export type CarouselParentUpdateOneInlineInput = {
  /** Connect existing CarouselParent document */
  connect?: InputMaybe<CarouselParentWhereUniqueInput>;
  /** Create and connect one CarouselParent document */
  create?: InputMaybe<CarouselParentCreateInput>;
  /** Delete currently connected CarouselParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected CarouselParent document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single CarouselParent document */
  update?: InputMaybe<CarouselParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single CarouselParent document */
  upsert?: InputMaybe<CarouselParentUpsertWithNestedWhereUniqueInput>;
};

export type CarouselParentUpdateWithNestedWhereUniqueInput = {
  Page?: InputMaybe<PageUpdateWithNestedWhereUniqueInput>;
};

export type CarouselParentUpsertWithNestedWhereUniqueInput = {
  Page?: InputMaybe<PageUpsertWithNestedWhereUniqueInput>;
};

export type CarouselParentWhereInput = {
  Page?: InputMaybe<PageWhereInput>;
};

export type CarouselParentWhereUniqueInput = {
  Page?: InputMaybe<PageWhereUniqueInput>;
};

export type CarouselSlide = {
  __typename?: 'CarouselSlide';
  ctas?: Maybe<CarouselSlidectasUnion>;
  description?: Maybe<Scalars['String']>;
  /** The unique identifier */
  id: Scalars['ID'];
  image: Asset;
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<CarouselSlide>;
  /** System stage field */
  stage: Stage;
  title: Scalars['String'];
};


export type CarouselSlideCtasArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type CarouselSlideImageArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type CarouselSlideLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};

export type CarouselSlideConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: CarouselSlideWhereUniqueInput;
};

/** A connection to a list of items. */
export type CarouselSlideConnection = {
  __typename?: 'CarouselSlideConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<CarouselSlideEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type CarouselSlideCreateInput = {
  ctas?: InputMaybe<CarouselSlidectasUnionCreateOneInlineInput>;
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  image: AssetCreateOneInlineInput;
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<CarouselSlideCreateLocalizationsInput>;
  /** title input for default locale (en) */
  title: Scalars['String'];
};

export type CarouselSlideCreateLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
  title: Scalars['String'];
};

export type CarouselSlideCreateLocalizationInput = {
  /** Localization input */
  data: CarouselSlideCreateLocalizationDataInput;
  locale: Locale;
};

export type CarouselSlideCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<CarouselSlideCreateLocalizationInput>>;
};

export type CarouselSlideCreateManyInlineInput = {
  /** Create and connect multiple existing CarouselSlide documents */
  create?: InputMaybe<Array<CarouselSlideCreateInput>>;
};

export type CarouselSlideCreateOneInlineInput = {
  /** Create and connect one CarouselSlide document */
  create?: InputMaybe<CarouselSlideCreateInput>;
};

export type CarouselSlideCreateWithPositionInput = {
  /** Document to create */
  data: CarouselSlideCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type CarouselSlideEdge = {
  __typename?: 'CarouselSlideEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: CarouselSlide;
};

/** Identifies documents */
export type CarouselSlideManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<CarouselSlideWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<CarouselSlideWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<CarouselSlideWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  image?: InputMaybe<AssetWhereInput>;
};

export enum CarouselSlideOrderByInput {
  DescriptionAsc = 'description_ASC',
  DescriptionDesc = 'description_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  TitleAsc = 'title_ASC',
  TitleDesc = 'title_DESC'
}

export type CarouselSlideParent = Carousel;

export type CarouselSlideParentConnectInput = {
  Carousel?: InputMaybe<CarouselConnectInput>;
};

export type CarouselSlideParentCreateInput = {
  Carousel?: InputMaybe<CarouselCreateInput>;
};

export type CarouselSlideParentCreateManyInlineInput = {
  /** Create and connect multiple existing CarouselSlideParent documents */
  create?: InputMaybe<Array<CarouselSlideParentCreateInput>>;
};

export type CarouselSlideParentCreateOneInlineInput = {
  /** Create and connect one CarouselSlideParent document */
  create?: InputMaybe<CarouselSlideParentCreateInput>;
};

export type CarouselSlideParentCreateWithPositionInput = {
  Carousel?: InputMaybe<CarouselCreateWithPositionInput>;
};

export type CarouselSlideParentUpdateInput = {
  Carousel?: InputMaybe<CarouselUpdateInput>;
};

export type CarouselSlideParentUpdateManyInlineInput = {
  /** Create and connect multiple CarouselSlideParent component instances */
  create?: InputMaybe<Array<CarouselSlideParentCreateWithPositionInput>>;
  /** Delete multiple CarouselSlideParent documents */
  delete?: InputMaybe<Array<CarouselSlideParentWhereUniqueInput>>;
  /** Update multiple CarouselSlideParent component instances */
  update?: InputMaybe<Array<CarouselSlideParentUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple CarouselSlideParent component instances */
  upsert?: InputMaybe<Array<CarouselSlideParentUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type CarouselSlideParentUpdateManyWithNestedWhereInput = {
  Carousel?: InputMaybe<CarouselUpdateManyWithNestedWhereInput>;
};

export type CarouselSlideParentUpdateOneInlineInput = {
  /** Create and connect one CarouselSlideParent document */
  create?: InputMaybe<CarouselSlideParentCreateInput>;
  /** Delete currently connected CarouselSlideParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single CarouselSlideParent document */
  update?: InputMaybe<CarouselSlideParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single CarouselSlideParent document */
  upsert?: InputMaybe<CarouselSlideParentUpsertWithNestedWhereUniqueInput>;
};

export type CarouselSlideParentUpdateWithNestedWhereUniqueAndPositionInput = {
  Carousel?: InputMaybe<CarouselUpdateWithNestedWhereUniqueAndPositionInput>;
};

export type CarouselSlideParentUpdateWithNestedWhereUniqueInput = {
  Carousel?: InputMaybe<CarouselUpdateWithNestedWhereUniqueInput>;
};

export type CarouselSlideParentUpsertWithNestedWhereUniqueAndPositionInput = {
  Carousel?: InputMaybe<CarouselUpsertWithNestedWhereUniqueAndPositionInput>;
};

export type CarouselSlideParentUpsertWithNestedWhereUniqueInput = {
  Carousel?: InputMaybe<CarouselUpsertWithNestedWhereUniqueInput>;
};

export type CarouselSlideParentWhereInput = {
  Carousel?: InputMaybe<CarouselWhereInput>;
};

export type CarouselSlideParentWhereUniqueInput = {
  Carousel?: InputMaybe<CarouselWhereUniqueInput>;
};

export type CarouselSlideUpdateInput = {
  ctas?: InputMaybe<CarouselSlidectasUnionUpdateOneInlineInput>;
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<AssetUpdateOneInlineInput>;
  /** Manage document localizations */
  localizations?: InputMaybe<CarouselSlideUpdateLocalizationsInput>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
};

export type CarouselSlideUpdateLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export type CarouselSlideUpdateLocalizationInput = {
  data: CarouselSlideUpdateLocalizationDataInput;
  locale: Locale;
};

export type CarouselSlideUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<CarouselSlideCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<CarouselSlideUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<CarouselSlideUpsertLocalizationInput>>;
};

export type CarouselSlideUpdateManyInlineInput = {
  /** Create and connect multiple CarouselSlide component instances */
  create?: InputMaybe<Array<CarouselSlideCreateWithPositionInput>>;
  /** Delete multiple CarouselSlide documents */
  delete?: InputMaybe<Array<CarouselSlideWhereUniqueInput>>;
  /** Update multiple CarouselSlide component instances */
  update?: InputMaybe<Array<CarouselSlideUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple CarouselSlide component instances */
  upsert?: InputMaybe<Array<CarouselSlideUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type CarouselSlideUpdateManyInput = {
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  /** Optional updates to localizations */
  localizations?: InputMaybe<CarouselSlideUpdateManyLocalizationsInput>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
};

export type CarouselSlideUpdateManyLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export type CarouselSlideUpdateManyLocalizationInput = {
  data: CarouselSlideUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type CarouselSlideUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<CarouselSlideUpdateManyLocalizationInput>>;
};

export type CarouselSlideUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: CarouselSlideUpdateManyInput;
  /** Document search */
  where: CarouselSlideWhereInput;
};

export type CarouselSlideUpdateOneInlineInput = {
  /** Create and connect one CarouselSlide document */
  create?: InputMaybe<CarouselSlideCreateInput>;
  /** Delete currently connected CarouselSlide document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single CarouselSlide document */
  update?: InputMaybe<CarouselSlideUpdateWithNestedWhereUniqueInput>;
  /** Upsert single CarouselSlide document */
  upsert?: InputMaybe<CarouselSlideUpsertWithNestedWhereUniqueInput>;
};

export type CarouselSlideUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<CarouselSlideUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: CarouselSlideWhereUniqueInput;
};

export type CarouselSlideUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: CarouselSlideUpdateInput;
  /** Unique document search */
  where: CarouselSlideWhereUniqueInput;
};

export type CarouselSlideUpsertInput = {
  /** Create document if it didn't exist */
  create: CarouselSlideCreateInput;
  /** Update document if it exists */
  update: CarouselSlideUpdateInput;
};

export type CarouselSlideUpsertLocalizationInput = {
  create: CarouselSlideCreateLocalizationDataInput;
  locale: Locale;
  update: CarouselSlideUpdateLocalizationDataInput;
};

export type CarouselSlideUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<CarouselSlideUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: CarouselSlideWhereUniqueInput;
};

export type CarouselSlideUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: CarouselSlideUpsertInput;
  /** Unique document search */
  where: CarouselSlideWhereUniqueInput;
};

/** Identifies documents */
export type CarouselSlideWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<CarouselSlideWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<CarouselSlideWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<CarouselSlideWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  description_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  description_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  description_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  description_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  description_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  description_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  description_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  description_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  description_starts_with?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  image?: InputMaybe<AssetWhereInput>;
  title?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  title_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  title_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  title_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  title_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  title_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  title_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  title_starts_with?: InputMaybe<Scalars['String']>;
};

/** References CarouselSlide record uniquely */
export type CarouselSlideWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export type CarouselSlidectasUnion = Link | OldButton;

export type CarouselSlidectasUnionConnectInput = {
  Link?: InputMaybe<LinkConnectInput>;
  OldButton?: InputMaybe<OldButtonConnectInput>;
};

export type CarouselSlidectasUnionCreateInput = {
  Link?: InputMaybe<LinkCreateInput>;
  OldButton?: InputMaybe<OldButtonCreateInput>;
};

export type CarouselSlidectasUnionCreateManyInlineInput = {
  /** Create and connect multiple existing CarouselSlidectasUnion documents */
  create?: InputMaybe<Array<CarouselSlidectasUnionCreateInput>>;
};

export type CarouselSlidectasUnionCreateOneInlineInput = {
  /** Create and connect one CarouselSlidectasUnion document */
  create?: InputMaybe<CarouselSlidectasUnionCreateInput>;
};

export type CarouselSlidectasUnionCreateWithPositionInput = {
  Link?: InputMaybe<LinkCreateWithPositionInput>;
  OldButton?: InputMaybe<OldButtonCreateWithPositionInput>;
};

export type CarouselSlidectasUnionUpdateInput = {
  Link?: InputMaybe<LinkUpdateInput>;
  OldButton?: InputMaybe<OldButtonUpdateInput>;
};

export type CarouselSlidectasUnionUpdateManyInlineInput = {
  /** Create and connect multiple CarouselSlidectasUnion component instances */
  create?: InputMaybe<Array<CarouselSlidectasUnionCreateWithPositionInput>>;
  /** Delete multiple CarouselSlidectasUnion documents */
  delete?: InputMaybe<Array<CarouselSlidectasUnionWhereUniqueInput>>;
  /** Update multiple CarouselSlidectasUnion component instances */
  update?: InputMaybe<Array<CarouselSlidectasUnionUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple CarouselSlidectasUnion component instances */
  upsert?: InputMaybe<Array<CarouselSlidectasUnionUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type CarouselSlidectasUnionUpdateManyWithNestedWhereInput = {
  Link?: InputMaybe<LinkUpdateManyWithNestedWhereInput>;
  OldButton?: InputMaybe<OldButtonUpdateManyWithNestedWhereInput>;
};

export type CarouselSlidectasUnionUpdateOneInlineInput = {
  /** Create and connect one CarouselSlidectasUnion document */
  create?: InputMaybe<CarouselSlidectasUnionCreateInput>;
  /** Delete currently connected CarouselSlidectasUnion document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single CarouselSlidectasUnion document */
  update?: InputMaybe<CarouselSlidectasUnionUpdateWithNestedWhereUniqueInput>;
  /** Upsert single CarouselSlidectasUnion document */
  upsert?: InputMaybe<CarouselSlidectasUnionUpsertWithNestedWhereUniqueInput>;
};

export type CarouselSlidectasUnionUpdateWithNestedWhereUniqueAndPositionInput = {
  Link?: InputMaybe<LinkUpdateWithNestedWhereUniqueAndPositionInput>;
  OldButton?: InputMaybe<OldButtonUpdateWithNestedWhereUniqueAndPositionInput>;
};

export type CarouselSlidectasUnionUpdateWithNestedWhereUniqueInput = {
  Link?: InputMaybe<LinkUpdateWithNestedWhereUniqueInput>;
  OldButton?: InputMaybe<OldButtonUpdateWithNestedWhereUniqueInput>;
};

export type CarouselSlidectasUnionUpsertWithNestedWhereUniqueAndPositionInput = {
  Link?: InputMaybe<LinkUpsertWithNestedWhereUniqueAndPositionInput>;
  OldButton?: InputMaybe<OldButtonUpsertWithNestedWhereUniqueAndPositionInput>;
};

export type CarouselSlidectasUnionUpsertWithNestedWhereUniqueInput = {
  Link?: InputMaybe<LinkUpsertWithNestedWhereUniqueInput>;
  OldButton?: InputMaybe<OldButtonUpsertWithNestedWhereUniqueInput>;
};

export type CarouselSlidectasUnionWhereInput = {
  Link?: InputMaybe<LinkWhereInput>;
  OldButton?: InputMaybe<OldButtonWhereInput>;
};

export type CarouselSlidectasUnionWhereUniqueInput = {
  Link?: InputMaybe<LinkWhereUniqueInput>;
  OldButton?: InputMaybe<OldButtonWhereUniqueInput>;
};

export type CarouselUpdateInput = {
  slides?: InputMaybe<CarouselSlideUpdateManyInlineInput>;
};

export type CarouselUpdateManyInlineInput = {
  /** Create and connect multiple Carousel component instances */
  create?: InputMaybe<Array<CarouselCreateWithPositionInput>>;
  /** Delete multiple Carousel documents */
  delete?: InputMaybe<Array<CarouselWhereUniqueInput>>;
  /** Update multiple Carousel component instances */
  update?: InputMaybe<Array<CarouselUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple Carousel component instances */
  upsert?: InputMaybe<Array<CarouselUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type CarouselUpdateManyInput = {
  /** No fields in updateMany data input */
  _?: InputMaybe<Scalars['String']>;
};

export type CarouselUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: CarouselUpdateManyInput;
  /** Document search */
  where: CarouselWhereInput;
};

export type CarouselUpdateOneInlineInput = {
  /** Create and connect one Carousel document */
  create?: InputMaybe<CarouselCreateInput>;
  /** Delete currently connected Carousel document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single Carousel document */
  update?: InputMaybe<CarouselUpdateWithNestedWhereUniqueInput>;
  /** Upsert single Carousel document */
  upsert?: InputMaybe<CarouselUpsertWithNestedWhereUniqueInput>;
};

export type CarouselUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<CarouselUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: CarouselWhereUniqueInput;
};

export type CarouselUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: CarouselUpdateInput;
  /** Unique document search */
  where: CarouselWhereUniqueInput;
};

export type CarouselUpsertInput = {
  /** Create document if it didn't exist */
  create: CarouselCreateInput;
  /** Update document if it exists */
  update: CarouselUpdateInput;
};

export type CarouselUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<CarouselUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: CarouselWhereUniqueInput;
};

export type CarouselUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: CarouselUpsertInput;
  /** Unique document search */
  where: CarouselWhereUniqueInput;
};

/** Identifies documents */
export type CarouselWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<CarouselWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<CarouselWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<CarouselWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  slides_every?: InputMaybe<CarouselSlideWhereInput>;
  slides_none?: InputMaybe<CarouselSlideWhereInput>;
  slides_some?: InputMaybe<CarouselSlideWhereInput>;
};

/** References Carousel record uniquely */
export type CarouselWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

/** Representing a color value comprising of HEX, RGBA and css color values */
export type Color = {
  __typename?: 'Color';
  css: Scalars['String'];
  hex: Scalars['Hex'];
  rgba: Rgba;
};

/** Accepts either HEX or RGBA color value. At least one of hex or rgba value should be passed. If both are passed RGBA is used. */
export type ColorInput = {
  hex?: InputMaybe<Scalars['Hex']>;
  rgba?: InputMaybe<RgbaInput>;
};

export type ConnectPositionInput = {
  /** Connect document after specified document */
  after?: InputMaybe<Scalars['ID']>;
  /** Connect document before specified document */
  before?: InputMaybe<Scalars['ID']>;
  /** Connect document at last position */
  end?: InputMaybe<Scalars['Boolean']>;
  /** Connect document at first position */
  start?: InputMaybe<Scalars['Boolean']>;
};

/** add all contact details of the association here, email, phone number, etc. */
export type ContactCard = Node & {
  __typename?: 'ContactCard';
  address: Array<Scalars['String']>;
  /** The time the document was created */
  createdAt: Scalars['DateTime'];
  /** User that created this document */
  createdBy?: Maybe<User>;
  /** Get the document in other stages */
  documentInStages: Array<ContactCard>;
  email: Scalars['String'];
  /** List of ContactCard versions */
  history: Array<Version>;
  /** The unique identifier */
  id: Scalars['ID'];
  phoneNumber: Scalars['String'];
  /** The time the document was published. Null on documents in draft stage. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** User that last published this document */
  publishedBy?: Maybe<User>;
  scheduledIn: Array<ScheduledOperation>;
  socials: Array<SocialLink>;
  /** System stage field */
  stage: Stage;
  /** The time the document was updated */
  updatedAt: Scalars['DateTime'];
  /** User that last updated this document */
  updatedBy?: Maybe<User>;
};


/** add all contact details of the association here, email, phone number, etc. */
export type ContactCardCreatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


/** add all contact details of the association here, email, phone number, etc. */
export type ContactCardDocumentInStagesArgs = {
  includeCurrent?: Scalars['Boolean'];
  inheritLocale?: Scalars['Boolean'];
  stages?: Array<Stage>;
};


/** add all contact details of the association here, email, phone number, etc. */
export type ContactCardHistoryArgs = {
  limit?: Scalars['Int'];
  skip?: Scalars['Int'];
  stageOverride?: InputMaybe<Stage>;
};


/** add all contact details of the association here, email, phone number, etc. */
export type ContactCardPublishedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


/** add all contact details of the association here, email, phone number, etc. */
export type ContactCardScheduledInArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ScheduledOperationWhereInput>;
};


/** add all contact details of the association here, email, phone number, etc. */
export type ContactCardSocialsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  orderBy?: InputMaybe<SocialLinkOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<SocialLinkWhereInput>;
};


/** add all contact details of the association here, email, phone number, etc. */
export type ContactCardUpdatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};

export type ContactCardConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: ContactCardWhereUniqueInput;
};

/** A connection to a list of items. */
export type ContactCardConnection = {
  __typename?: 'ContactCardConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<ContactCardEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type ContactCardCreateInput = {
  address?: InputMaybe<Array<Scalars['String']>>;
  cl6cinup616wu01uh3l76e0c0?: InputMaybe<OldColumnCreateManyInlineInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  email: Scalars['String'];
  phoneNumber: Scalars['String'];
  socials?: InputMaybe<SocialLinkCreateManyInlineInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type ContactCardCreateManyInlineInput = {
  /** Connect multiple existing ContactCard documents */
  connect?: InputMaybe<Array<ContactCardWhereUniqueInput>>;
  /** Create and connect multiple existing ContactCard documents */
  create?: InputMaybe<Array<ContactCardCreateInput>>;
};

export type ContactCardCreateOneInlineInput = {
  /** Connect one existing ContactCard document */
  connect?: InputMaybe<ContactCardWhereUniqueInput>;
  /** Create and connect one ContactCard document */
  create?: InputMaybe<ContactCardCreateInput>;
};

/** An edge in a connection. */
export type ContactCardEdge = {
  __typename?: 'ContactCardEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: ContactCard;
};

/** Identifies documents */
export type ContactCardManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<ContactCardWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<ContactCardWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<ContactCardWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  /** Matches if the field array contains *all* items provided to the filter and order does match */
  address?: InputMaybe<Array<Scalars['String']>>;
  /** Matches if the field array contains *all* items provided to the filter */
  address_contains_all?: InputMaybe<Array<Scalars['String']>>;
  /** Matches if the field array does not contain any of the items provided to the filter */
  address_contains_none?: InputMaybe<Array<Scalars['String']>>;
  /** Matches if the field array contains at least one item provided to the filter */
  address_contains_some?: InputMaybe<Array<Scalars['String']>>;
  /** Matches if the field array does not contains *all* items provided to the filter or order does not match */
  address_not?: InputMaybe<Array<Scalars['String']>>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  email?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  email_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  email_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  email_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  email_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  email_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  email_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  email_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  email_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  email_starts_with?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  phoneNumber_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  phoneNumber_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  phoneNumber_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  phoneNumber_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  phoneNumber_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  phoneNumber_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  phoneNumber_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  phoneNumber_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  phoneNumber_starts_with?: InputMaybe<Scalars['String']>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  socials_every?: InputMaybe<SocialLinkWhereInput>;
  socials_none?: InputMaybe<SocialLinkWhereInput>;
  socials_some?: InputMaybe<SocialLinkWhereInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

export enum ContactCardOrderByInput {
  AddressAsc = 'address_ASC',
  AddressDesc = 'address_DESC',
  CreatedAtAsc = 'createdAt_ASC',
  CreatedAtDesc = 'createdAt_DESC',
  EmailAsc = 'email_ASC',
  EmailDesc = 'email_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  PhoneNumberAsc = 'phoneNumber_ASC',
  PhoneNumberDesc = 'phoneNumber_DESC',
  PublishedAtAsc = 'publishedAt_ASC',
  PublishedAtDesc = 'publishedAt_DESC',
  UpdatedAtAsc = 'updatedAt_ASC',
  UpdatedAtDesc = 'updatedAt_DESC'
}

export type ContactCardUpdateInput = {
  address?: InputMaybe<Array<Scalars['String']>>;
  cl6cinup616wu01uh3l76e0c0?: InputMaybe<OldColumnUpdateManyInlineInput>;
  email?: InputMaybe<Scalars['String']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  socials?: InputMaybe<SocialLinkUpdateManyInlineInput>;
};

export type ContactCardUpdateManyInlineInput = {
  /** Connect multiple existing ContactCard documents */
  connect?: InputMaybe<Array<ContactCardConnectInput>>;
  /** Create and connect multiple ContactCard documents */
  create?: InputMaybe<Array<ContactCardCreateInput>>;
  /** Delete multiple ContactCard documents */
  delete?: InputMaybe<Array<ContactCardWhereUniqueInput>>;
  /** Disconnect multiple ContactCard documents */
  disconnect?: InputMaybe<Array<ContactCardWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing ContactCard documents */
  set?: InputMaybe<Array<ContactCardWhereUniqueInput>>;
  /** Update multiple ContactCard documents */
  update?: InputMaybe<Array<ContactCardUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple ContactCard documents */
  upsert?: InputMaybe<Array<ContactCardUpsertWithNestedWhereUniqueInput>>;
};

export type ContactCardUpdateManyInput = {
  address?: InputMaybe<Array<Scalars['String']>>;
};

export type ContactCardUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: ContactCardUpdateManyInput;
  /** Document search */
  where: ContactCardWhereInput;
};

export type ContactCardUpdateOneInlineInput = {
  /** Connect existing ContactCard document */
  connect?: InputMaybe<ContactCardWhereUniqueInput>;
  /** Create and connect one ContactCard document */
  create?: InputMaybe<ContactCardCreateInput>;
  /** Delete currently connected ContactCard document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected ContactCard document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single ContactCard document */
  update?: InputMaybe<ContactCardUpdateWithNestedWhereUniqueInput>;
  /** Upsert single ContactCard document */
  upsert?: InputMaybe<ContactCardUpsertWithNestedWhereUniqueInput>;
};

export type ContactCardUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: ContactCardUpdateInput;
  /** Unique document search */
  where: ContactCardWhereUniqueInput;
};

export type ContactCardUpsertInput = {
  /** Create document if it didn't exist */
  create: ContactCardCreateInput;
  /** Update document if it exists */
  update: ContactCardUpdateInput;
};

export type ContactCardUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: ContactCardUpsertInput;
  /** Unique document search */
  where: ContactCardWhereUniqueInput;
};

/** Identifies documents */
export type ContactCardWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<ContactCardWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<ContactCardWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<ContactCardWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  /** Matches if the field array contains *all* items provided to the filter and order does match */
  address?: InputMaybe<Array<Scalars['String']>>;
  /** Matches if the field array contains *all* items provided to the filter */
  address_contains_all?: InputMaybe<Array<Scalars['String']>>;
  /** Matches if the field array does not contain any of the items provided to the filter */
  address_contains_none?: InputMaybe<Array<Scalars['String']>>;
  /** Matches if the field array contains at least one item provided to the filter */
  address_contains_some?: InputMaybe<Array<Scalars['String']>>;
  /** Matches if the field array does not contains *all* items provided to the filter or order does not match */
  address_not?: InputMaybe<Array<Scalars['String']>>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  email?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  email_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  email_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  email_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  email_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  email_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  email_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  email_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  email_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  email_starts_with?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  phoneNumber_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  phoneNumber_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  phoneNumber_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  phoneNumber_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  phoneNumber_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  phoneNumber_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  phoneNumber_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  phoneNumber_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  phoneNumber_starts_with?: InputMaybe<Scalars['String']>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  socials_every?: InputMaybe<SocialLinkWhereInput>;
  socials_none?: InputMaybe<SocialLinkWhereInput>;
  socials_some?: InputMaybe<SocialLinkWhereInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

/** References ContactCard record uniquely */
export type ContactCardWhereUniqueInput = {
  email?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
};

export type Container = Node & {
  __typename?: 'Container';
  components: Array<ContainercomponentsUnion>;
  container?: Maybe<Container>;
  /** The time the document was created */
  createdAt: Scalars['DateTime'];
  /** User that created this document */
  createdBy?: Maybe<User>;
  /** Get the document in other stages */
  documentInStages: Array<Container>;
  /** List of Container versions */
  history: Array<Version>;
  /** The unique identifier */
  id: Scalars['ID'];
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<Container>;
  models: Array<ContainerModels>;
  /** The time the document was published. Null on documents in draft stage. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** User that last published this document */
  publishedBy?: Maybe<User>;
  scheduledIn: Array<ScheduledOperation>;
  /** System stage field */
  stage: Stage;
  style?: Maybe<Style>;
  type: ContainerType;
  /** The time the document was updated */
  updatedAt: Scalars['DateTime'];
  /** User that last updated this document */
  updatedBy?: Maybe<User>;
};


export type ContainerComponentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
};


export type ContainerContainerArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type ContainerCreatedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type ContainerCreatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type ContainerDocumentInStagesArgs = {
  includeCurrent?: Scalars['Boolean'];
  inheritLocale?: Scalars['Boolean'];
  stages?: Array<Stage>;
};


export type ContainerHistoryArgs = {
  limit?: Scalars['Int'];
  skip?: Scalars['Int'];
  stageOverride?: InputMaybe<Stage>;
};


export type ContainerLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};


export type ContainerModelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
};


export type ContainerPublishedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type ContainerPublishedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type ContainerScheduledInArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ScheduledOperationWhereInput>;
};


export type ContainerStyleArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type ContainerUpdatedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type ContainerUpdatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};

export type ContainerConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: ContainerWhereUniqueInput;
};

/** A connection to a list of items. */
export type ContainerConnection = {
  __typename?: 'ContainerConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<ContainerEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type ContainerCreateInput = {
  components?: InputMaybe<ContainercomponentsUnionCreateManyInlineInput>;
  container?: InputMaybe<ContainerCreateOneInlineInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<ContainerCreateLocalizationsInput>;
  models?: InputMaybe<ContainerModelsCreateManyInlineInput>;
  style?: InputMaybe<StyleCreateOneInlineInput>;
  type: ContainerType;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type ContainerCreateLocalizationDataInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type ContainerCreateLocalizationInput = {
  /** Localization input */
  data: ContainerCreateLocalizationDataInput;
  locale: Locale;
};

export type ContainerCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<ContainerCreateLocalizationInput>>;
};

export type ContainerCreateManyInlineInput = {
  /** Connect multiple existing Container documents */
  connect?: InputMaybe<Array<ContainerWhereUniqueInput>>;
  /** Create and connect multiple existing Container documents */
  create?: InputMaybe<Array<ContainerCreateInput>>;
};

export type ContainerCreateOneInlineInput = {
  /** Connect one existing Container document */
  connect?: InputMaybe<ContainerWhereUniqueInput>;
  /** Create and connect one Container document */
  create?: InputMaybe<ContainerCreateInput>;
};

/** An edge in a connection. */
export type ContainerEdge = {
  __typename?: 'ContainerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Container;
};

/** Identifies documents */
export type ContainerManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<ContainerWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<ContainerWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<ContainerWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  container?: InputMaybe<ContainerWhereInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  style?: InputMaybe<StyleWhereInput>;
  type?: InputMaybe<ContainerType>;
  /** All values that are contained in given list. */
  type_in?: InputMaybe<Array<InputMaybe<ContainerType>>>;
  /** All values that are not equal to given value. */
  type_not?: InputMaybe<ContainerType>;
  /** All values that are not contained in given list. */
  type_not_in?: InputMaybe<Array<InputMaybe<ContainerType>>>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

export type ContainerModels = Button | Card | Container | Form | RichTextWrapper;

export type ContainerModelsConnectInput = {
  Button?: InputMaybe<ButtonConnectInput>;
  Card?: InputMaybe<CardConnectInput>;
  Container?: InputMaybe<ContainerConnectInput>;
  Form?: InputMaybe<FormConnectInput>;
  RichTextWrapper?: InputMaybe<RichTextWrapperConnectInput>;
};

export type ContainerModelsCreateInput = {
  Button?: InputMaybe<ButtonCreateInput>;
  Card?: InputMaybe<CardCreateInput>;
  Container?: InputMaybe<ContainerCreateInput>;
  Form?: InputMaybe<FormCreateInput>;
  RichTextWrapper?: InputMaybe<RichTextWrapperCreateInput>;
};

export type ContainerModelsCreateManyInlineInput = {
  /** Connect multiple existing ContainerModels documents */
  connect?: InputMaybe<Array<ContainerModelsWhereUniqueInput>>;
  /** Create and connect multiple existing ContainerModels documents */
  create?: InputMaybe<Array<ContainerModelsCreateInput>>;
};

export type ContainerModelsCreateOneInlineInput = {
  /** Connect one existing ContainerModels document */
  connect?: InputMaybe<ContainerModelsWhereUniqueInput>;
  /** Create and connect one ContainerModels document */
  create?: InputMaybe<ContainerModelsCreateInput>;
};

export type ContainerModelsUpdateInput = {
  Button?: InputMaybe<ButtonUpdateInput>;
  Card?: InputMaybe<CardUpdateInput>;
  Container?: InputMaybe<ContainerUpdateInput>;
  Form?: InputMaybe<FormUpdateInput>;
  RichTextWrapper?: InputMaybe<RichTextWrapperUpdateInput>;
};

export type ContainerModelsUpdateManyInlineInput = {
  /** Connect multiple existing ContainerModels documents */
  connect?: InputMaybe<Array<ContainerModelsConnectInput>>;
  /** Create and connect multiple ContainerModels documents */
  create?: InputMaybe<Array<ContainerModelsCreateInput>>;
  /** Delete multiple ContainerModels documents */
  delete?: InputMaybe<Array<ContainerModelsWhereUniqueInput>>;
  /** Disconnect multiple ContainerModels documents */
  disconnect?: InputMaybe<Array<ContainerModelsWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing ContainerModels documents */
  set?: InputMaybe<Array<ContainerModelsWhereUniqueInput>>;
  /** Update multiple ContainerModels documents */
  update?: InputMaybe<Array<ContainerModelsUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple ContainerModels documents */
  upsert?: InputMaybe<Array<ContainerModelsUpsertWithNestedWhereUniqueInput>>;
};

export type ContainerModelsUpdateManyWithNestedWhereInput = {
  Button?: InputMaybe<ButtonUpdateManyWithNestedWhereInput>;
  Card?: InputMaybe<CardUpdateManyWithNestedWhereInput>;
  Container?: InputMaybe<ContainerUpdateManyWithNestedWhereInput>;
  Form?: InputMaybe<FormUpdateManyWithNestedWhereInput>;
  RichTextWrapper?: InputMaybe<RichTextWrapperUpdateManyWithNestedWhereInput>;
};

export type ContainerModelsUpdateOneInlineInput = {
  /** Connect existing ContainerModels document */
  connect?: InputMaybe<ContainerModelsWhereUniqueInput>;
  /** Create and connect one ContainerModels document */
  create?: InputMaybe<ContainerModelsCreateInput>;
  /** Delete currently connected ContainerModels document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected ContainerModels document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single ContainerModels document */
  update?: InputMaybe<ContainerModelsUpdateWithNestedWhereUniqueInput>;
  /** Upsert single ContainerModels document */
  upsert?: InputMaybe<ContainerModelsUpsertWithNestedWhereUniqueInput>;
};

export type ContainerModelsUpdateWithNestedWhereUniqueInput = {
  Button?: InputMaybe<ButtonUpdateWithNestedWhereUniqueInput>;
  Card?: InputMaybe<CardUpdateWithNestedWhereUniqueInput>;
  Container?: InputMaybe<ContainerUpdateWithNestedWhereUniqueInput>;
  Form?: InputMaybe<FormUpdateWithNestedWhereUniqueInput>;
  RichTextWrapper?: InputMaybe<RichTextWrapperUpdateWithNestedWhereUniqueInput>;
};

export type ContainerModelsUpsertWithNestedWhereUniqueInput = {
  Button?: InputMaybe<ButtonUpsertWithNestedWhereUniqueInput>;
  Card?: InputMaybe<CardUpsertWithNestedWhereUniqueInput>;
  Container?: InputMaybe<ContainerUpsertWithNestedWhereUniqueInput>;
  Form?: InputMaybe<FormUpsertWithNestedWhereUniqueInput>;
  RichTextWrapper?: InputMaybe<RichTextWrapperUpsertWithNestedWhereUniqueInput>;
};

export type ContainerModelsWhereInput = {
  Button?: InputMaybe<ButtonWhereInput>;
  Card?: InputMaybe<CardWhereInput>;
  Container?: InputMaybe<ContainerWhereInput>;
  Form?: InputMaybe<FormWhereInput>;
  RichTextWrapper?: InputMaybe<RichTextWrapperWhereInput>;
};

export type ContainerModelsWhereUniqueInput = {
  Button?: InputMaybe<ButtonWhereUniqueInput>;
  Card?: InputMaybe<CardWhereUniqueInput>;
  Container?: InputMaybe<ContainerWhereUniqueInput>;
  Form?: InputMaybe<FormWhereUniqueInput>;
  RichTextWrapper?: InputMaybe<RichTextWrapperWhereUniqueInput>;
};

export enum ContainerOrderByInput {
  CreatedAtAsc = 'createdAt_ASC',
  CreatedAtDesc = 'createdAt_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  PublishedAtAsc = 'publishedAt_ASC',
  PublishedAtDesc = 'publishedAt_DESC',
  TypeAsc = 'type_ASC',
  TypeDesc = 'type_DESC',
  UpdatedAtAsc = 'updatedAt_ASC',
  UpdatedAtDesc = 'updatedAt_DESC'
}

export enum ContainerType {
  Column = 'COLUMN',
  Row = 'ROW'
}

export type ContainerUpdateInput = {
  components?: InputMaybe<ContainercomponentsUnionUpdateManyInlineInput>;
  container?: InputMaybe<ContainerUpdateOneInlineInput>;
  /** Manage document localizations */
  localizations?: InputMaybe<ContainerUpdateLocalizationsInput>;
  models?: InputMaybe<ContainerModelsUpdateManyInlineInput>;
  style?: InputMaybe<StyleUpdateOneInlineInput>;
  type?: InputMaybe<ContainerType>;
};

export type ContainerUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<ContainerCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
};

export type ContainerUpdateManyInlineInput = {
  /** Connect multiple existing Container documents */
  connect?: InputMaybe<Array<ContainerConnectInput>>;
  /** Create and connect multiple Container documents */
  create?: InputMaybe<Array<ContainerCreateInput>>;
  /** Delete multiple Container documents */
  delete?: InputMaybe<Array<ContainerWhereUniqueInput>>;
  /** Disconnect multiple Container documents */
  disconnect?: InputMaybe<Array<ContainerWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing Container documents */
  set?: InputMaybe<Array<ContainerWhereUniqueInput>>;
  /** Update multiple Container documents */
  update?: InputMaybe<Array<ContainerUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple Container documents */
  upsert?: InputMaybe<Array<ContainerUpsertWithNestedWhereUniqueInput>>;
};

export type ContainerUpdateManyInput = {
  type?: InputMaybe<ContainerType>;
};

export type ContainerUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: ContainerUpdateManyInput;
  /** Document search */
  where: ContainerWhereInput;
};

export type ContainerUpdateOneInlineInput = {
  /** Connect existing Container document */
  connect?: InputMaybe<ContainerWhereUniqueInput>;
  /** Create and connect one Container document */
  create?: InputMaybe<ContainerCreateInput>;
  /** Delete currently connected Container document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected Container document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single Container document */
  update?: InputMaybe<ContainerUpdateWithNestedWhereUniqueInput>;
  /** Upsert single Container document */
  upsert?: InputMaybe<ContainerUpsertWithNestedWhereUniqueInput>;
};

export type ContainerUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: ContainerUpdateInput;
  /** Unique document search */
  where: ContainerWhereUniqueInput;
};

export type ContainerUpsertInput = {
  /** Create document if it didn't exist */
  create: ContainerCreateInput;
  /** Update document if it exists */
  update: ContainerUpdateInput;
};

export type ContainerUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: ContainerUpsertInput;
  /** Unique document search */
  where: ContainerWhereUniqueInput;
};

/** Identifies documents */
export type ContainerWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<ContainerWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<ContainerWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<ContainerWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  container?: InputMaybe<ContainerWhereInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  style?: InputMaybe<StyleWhereInput>;
  type?: InputMaybe<ContainerType>;
  /** All values that are contained in given list. */
  type_in?: InputMaybe<Array<InputMaybe<ContainerType>>>;
  /** All values that are not equal to given value. */
  type_not?: InputMaybe<ContainerType>;
  /** All values that are not contained in given list. */
  type_not_in?: InputMaybe<Array<InputMaybe<ContainerType>>>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

/** References Container record uniquely */
export type ContainerWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export type ContainercomponentsUnion = FormCheckbox | FormInput | FormRadio | FormTextarea | FromSelect | MdText | Text | Title;

export type ContainercomponentsUnionConnectInput = {
  FormCheckbox?: InputMaybe<FormCheckboxConnectInput>;
  FormInput?: InputMaybe<FormInputConnectInput>;
  FormRadio?: InputMaybe<FormRadioConnectInput>;
  FormTextarea?: InputMaybe<FormTextareaConnectInput>;
  FromSelect?: InputMaybe<FromSelectConnectInput>;
  MdText?: InputMaybe<MdTextConnectInput>;
  Text?: InputMaybe<TextConnectInput>;
  Title?: InputMaybe<TitleConnectInput>;
};

export type ContainercomponentsUnionCreateInput = {
  FormCheckbox?: InputMaybe<FormCheckboxCreateInput>;
  FormInput?: InputMaybe<FormInputCreateInput>;
  FormRadio?: InputMaybe<FormRadioCreateInput>;
  FormTextarea?: InputMaybe<FormTextareaCreateInput>;
  FromSelect?: InputMaybe<FromSelectCreateInput>;
  MdText?: InputMaybe<MdTextCreateInput>;
  Text?: InputMaybe<TextCreateInput>;
  Title?: InputMaybe<TitleCreateInput>;
};

export type ContainercomponentsUnionCreateManyInlineInput = {
  /** Create and connect multiple existing ContainercomponentsUnion documents */
  create?: InputMaybe<Array<ContainercomponentsUnionCreateInput>>;
};

export type ContainercomponentsUnionCreateOneInlineInput = {
  /** Create and connect one ContainercomponentsUnion document */
  create?: InputMaybe<ContainercomponentsUnionCreateInput>;
};

export type ContainercomponentsUnionCreateWithPositionInput = {
  FormCheckbox?: InputMaybe<FormCheckboxCreateWithPositionInput>;
  FormInput?: InputMaybe<FormInputCreateWithPositionInput>;
  FormRadio?: InputMaybe<FormRadioCreateWithPositionInput>;
  FormTextarea?: InputMaybe<FormTextareaCreateWithPositionInput>;
  FromSelect?: InputMaybe<FromSelectCreateWithPositionInput>;
  MdText?: InputMaybe<MdTextCreateWithPositionInput>;
  Text?: InputMaybe<TextCreateWithPositionInput>;
  Title?: InputMaybe<TitleCreateWithPositionInput>;
};

export type ContainercomponentsUnionUpdateInput = {
  FormCheckbox?: InputMaybe<FormCheckboxUpdateInput>;
  FormInput?: InputMaybe<FormInputUpdateInput>;
  FormRadio?: InputMaybe<FormRadioUpdateInput>;
  FormTextarea?: InputMaybe<FormTextareaUpdateInput>;
  FromSelect?: InputMaybe<FromSelectUpdateInput>;
  MdText?: InputMaybe<MdTextUpdateInput>;
  Text?: InputMaybe<TextUpdateInput>;
  Title?: InputMaybe<TitleUpdateInput>;
};

export type ContainercomponentsUnionUpdateManyInlineInput = {
  /** Create and connect multiple ContainercomponentsUnion component instances */
  create?: InputMaybe<Array<ContainercomponentsUnionCreateWithPositionInput>>;
  /** Delete multiple ContainercomponentsUnion documents */
  delete?: InputMaybe<Array<ContainercomponentsUnionWhereUniqueInput>>;
  /** Update multiple ContainercomponentsUnion component instances */
  update?: InputMaybe<Array<ContainercomponentsUnionUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple ContainercomponentsUnion component instances */
  upsert?: InputMaybe<Array<ContainercomponentsUnionUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type ContainercomponentsUnionUpdateManyWithNestedWhereInput = {
  FormCheckbox?: InputMaybe<FormCheckboxUpdateManyWithNestedWhereInput>;
  FormInput?: InputMaybe<FormInputUpdateManyWithNestedWhereInput>;
  FormRadio?: InputMaybe<FormRadioUpdateManyWithNestedWhereInput>;
  FormTextarea?: InputMaybe<FormTextareaUpdateManyWithNestedWhereInput>;
  FromSelect?: InputMaybe<FromSelectUpdateManyWithNestedWhereInput>;
  MdText?: InputMaybe<MdTextUpdateManyWithNestedWhereInput>;
  Text?: InputMaybe<TextUpdateManyWithNestedWhereInput>;
  Title?: InputMaybe<TitleUpdateManyWithNestedWhereInput>;
};

export type ContainercomponentsUnionUpdateOneInlineInput = {
  /** Create and connect one ContainercomponentsUnion document */
  create?: InputMaybe<ContainercomponentsUnionCreateInput>;
  /** Delete currently connected ContainercomponentsUnion document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single ContainercomponentsUnion document */
  update?: InputMaybe<ContainercomponentsUnionUpdateWithNestedWhereUniqueInput>;
  /** Upsert single ContainercomponentsUnion document */
  upsert?: InputMaybe<ContainercomponentsUnionUpsertWithNestedWhereUniqueInput>;
};

export type ContainercomponentsUnionUpdateWithNestedWhereUniqueAndPositionInput = {
  FormCheckbox?: InputMaybe<FormCheckboxUpdateWithNestedWhereUniqueAndPositionInput>;
  FormInput?: InputMaybe<FormInputUpdateWithNestedWhereUniqueAndPositionInput>;
  FormRadio?: InputMaybe<FormRadioUpdateWithNestedWhereUniqueAndPositionInput>;
  FormTextarea?: InputMaybe<FormTextareaUpdateWithNestedWhereUniqueAndPositionInput>;
  FromSelect?: InputMaybe<FromSelectUpdateWithNestedWhereUniqueAndPositionInput>;
  MdText?: InputMaybe<MdTextUpdateWithNestedWhereUniqueAndPositionInput>;
  Text?: InputMaybe<TextUpdateWithNestedWhereUniqueAndPositionInput>;
  Title?: InputMaybe<TitleUpdateWithNestedWhereUniqueAndPositionInput>;
};

export type ContainercomponentsUnionUpdateWithNestedWhereUniqueInput = {
  FormCheckbox?: InputMaybe<FormCheckboxUpdateWithNestedWhereUniqueInput>;
  FormInput?: InputMaybe<FormInputUpdateWithNestedWhereUniqueInput>;
  FormRadio?: InputMaybe<FormRadioUpdateWithNestedWhereUniqueInput>;
  FormTextarea?: InputMaybe<FormTextareaUpdateWithNestedWhereUniqueInput>;
  FromSelect?: InputMaybe<FromSelectUpdateWithNestedWhereUniqueInput>;
  MdText?: InputMaybe<MdTextUpdateWithNestedWhereUniqueInput>;
  Text?: InputMaybe<TextUpdateWithNestedWhereUniqueInput>;
  Title?: InputMaybe<TitleUpdateWithNestedWhereUniqueInput>;
};

export type ContainercomponentsUnionUpsertWithNestedWhereUniqueAndPositionInput = {
  FormCheckbox?: InputMaybe<FormCheckboxUpsertWithNestedWhereUniqueAndPositionInput>;
  FormInput?: InputMaybe<FormInputUpsertWithNestedWhereUniqueAndPositionInput>;
  FormRadio?: InputMaybe<FormRadioUpsertWithNestedWhereUniqueAndPositionInput>;
  FormTextarea?: InputMaybe<FormTextareaUpsertWithNestedWhereUniqueAndPositionInput>;
  FromSelect?: InputMaybe<FromSelectUpsertWithNestedWhereUniqueAndPositionInput>;
  MdText?: InputMaybe<MdTextUpsertWithNestedWhereUniqueAndPositionInput>;
  Text?: InputMaybe<TextUpsertWithNestedWhereUniqueAndPositionInput>;
  Title?: InputMaybe<TitleUpsertWithNestedWhereUniqueAndPositionInput>;
};

export type ContainercomponentsUnionUpsertWithNestedWhereUniqueInput = {
  FormCheckbox?: InputMaybe<FormCheckboxUpsertWithNestedWhereUniqueInput>;
  FormInput?: InputMaybe<FormInputUpsertWithNestedWhereUniqueInput>;
  FormRadio?: InputMaybe<FormRadioUpsertWithNestedWhereUniqueInput>;
  FormTextarea?: InputMaybe<FormTextareaUpsertWithNestedWhereUniqueInput>;
  FromSelect?: InputMaybe<FromSelectUpsertWithNestedWhereUniqueInput>;
  MdText?: InputMaybe<MdTextUpsertWithNestedWhereUniqueInput>;
  Text?: InputMaybe<TextUpsertWithNestedWhereUniqueInput>;
  Title?: InputMaybe<TitleUpsertWithNestedWhereUniqueInput>;
};

export type ContainercomponentsUnionWhereInput = {
  FormCheckbox?: InputMaybe<FormCheckboxWhereInput>;
  FormInput?: InputMaybe<FormInputWhereInput>;
  FormRadio?: InputMaybe<FormRadioWhereInput>;
  FormTextarea?: InputMaybe<FormTextareaWhereInput>;
  FromSelect?: InputMaybe<FromSelectWhereInput>;
  MdText?: InputMaybe<MdTextWhereInput>;
  Text?: InputMaybe<TextWhereInput>;
  Title?: InputMaybe<TitleWhereInput>;
};

export type ContainercomponentsUnionWhereUniqueInput = {
  FormCheckbox?: InputMaybe<FormCheckboxWhereUniqueInput>;
  FormInput?: InputMaybe<FormInputWhereUniqueInput>;
  FormRadio?: InputMaybe<FormRadioWhereUniqueInput>;
  FormTextarea?: InputMaybe<FormTextareaWhereUniqueInput>;
  FromSelect?: InputMaybe<FromSelectWhereUniqueInput>;
  MdText?: InputMaybe<MdTextWhereUniqueInput>;
  Text?: InputMaybe<TextWhereUniqueInput>;
  Title?: InputMaybe<TitleWhereUniqueInput>;
};

export enum DocumentFileTypes {
  Doc = 'doc',
  Docx = 'docx',
  Html = 'html',
  Jpg = 'jpg',
  Odp = 'odp',
  Ods = 'ods',
  Odt = 'odt',
  Pdf = 'pdf',
  Png = 'png',
  Ppt = 'ppt',
  Pptx = 'pptx',
  Svg = 'svg',
  Txt = 'txt',
  Webp = 'webp',
  Xls = 'xls',
  Xlsx = 'xlsx'
}

export type DocumentOutputInput = {
  /**
   * Transforms a document into a desired file type.
   * See this matrix for format support:
   *
   * PDF:	jpg, odp, ods, odt, png, svg, txt, and webp
   * DOC:	docx, html, jpg, odt, pdf, png, svg, txt, and webp
   * DOCX:	doc, html, jpg, odt, pdf, png, svg, txt, and webp
   * ODT:	doc, docx, html, jpg, pdf, png, svg, txt, and webp
   * XLS:	jpg, pdf, ods, png, svg, xlsx, and webp
   * XLSX:	jpg, pdf, ods, png, svg, xls, and webp
   * ODS:	jpg, pdf, png, xls, svg, xlsx, and webp
   * PPT:	jpg, odp, pdf, png, svg, pptx, and webp
   * PPTX:	jpg, odp, pdf, png, svg, ppt, and webp
   * ODP:	jpg, pdf, png, ppt, svg, pptx, and webp
   * BMP:	jpg, odp, ods, odt, pdf, png, svg, and webp
   * GIF:	jpg, odp, ods, odt, pdf, png, svg, and webp
   * JPG:	jpg, odp, ods, odt, pdf, png, svg, and webp
   * PNG:	jpg, odp, ods, odt, pdf, png, svg, and webp
   * WEBP:	jpg, odp, ods, odt, pdf, png, svg, and webp
   * TIFF:	jpg, odp, ods, odt, pdf, png, svg, and webp
   * AI:	    jpg, odp, ods, odt, pdf, png, svg, and webp
   * PSD:	jpg, odp, ods, odt, pdf, png, svg, and webp
   * SVG:	jpg, odp, ods, odt, pdf, png, and webp
   * HTML:	jpg, odt, pdf, svg, txt, and webp
   * TXT:	jpg, html, odt, pdf, svg, and webp
   */
  format?: InputMaybe<DocumentFileTypes>;
};

/** Transformations for Documents */
export type DocumentTransformationInput = {
  /** Changes the output for the file. */
  output?: InputMaybe<DocumentOutputInput>;
};

export type DocumentVersion = {
  __typename?: 'DocumentVersion';
  createdAt: Scalars['DateTime'];
  data?: Maybe<Scalars['Json']>;
  id: Scalars['ID'];
  revision: Scalars['Int'];
  stage: Stage;
};

export type Event = Node & {
  __typename?: 'Event';
  card?: Maybe<Card>;
  category?: Maybe<Scalars['String']>;
  /** The time the document was created */
  createdAt: Scalars['DateTime'];
  /** User that created this document */
  createdBy?: Maybe<User>;
  description: RichText;
  details: Scalars['String'];
  /** Get the document in other stages */
  documentInStages: Array<Event>;
  endDate: Scalars['DateTime'];
  gallery: Array<Asset>;
  /** List of Event versions */
  history: Array<Version>;
  /** The unique identifier */
  id: Scalars['ID'];
  image: Asset;
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<Event>;
  /** The time the document was published. Null on documents in draft stage. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** User that last published this document */
  publishedBy?: Maybe<User>;
  scheduledIn: Array<ScheduledOperation>;
  slug?: Maybe<Scalars['String']>;
  /** System stage field */
  stage: Stage;
  startDate: Scalars['DateTime'];
  title: Scalars['String'];
  /** The time the document was updated */
  updatedAt: Scalars['DateTime'];
  /** User that last updated this document */
  updatedBy?: Maybe<User>;
};


export type EventCardArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type EventCreatedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type EventCreatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type EventDocumentInStagesArgs = {
  includeCurrent?: Scalars['Boolean'];
  inheritLocale?: Scalars['Boolean'];
  stages?: Array<Stage>;
};


export type EventGalleryArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  orderBy?: InputMaybe<AssetOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AssetWhereInput>;
};


export type EventHistoryArgs = {
  limit?: Scalars['Int'];
  skip?: Scalars['Int'];
  stageOverride?: InputMaybe<Stage>;
};


export type EventImageArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type EventLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};


export type EventPublishedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type EventPublishedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type EventScheduledInArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ScheduledOperationWhereInput>;
};


export type EventUpdatedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type EventUpdatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};

export type EventConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: EventWhereUniqueInput;
};

/** A connection to a list of items. */
export type EventConnection = {
  __typename?: 'EventConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<EventEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type EventCreateInput = {
  card?: InputMaybe<CardCreateOneInlineInput>;
  /** category input for default locale (en) */
  category?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** description input for default locale (en) */
  description: Scalars['RichTextAST'];
  /** details input for default locale (en) */
  details: Scalars['String'];
  endDate: Scalars['DateTime'];
  gallery?: InputMaybe<AssetCreateManyInlineInput>;
  image: AssetCreateOneInlineInput;
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<EventCreateLocalizationsInput>;
  slug?: InputMaybe<Scalars['String']>;
  startDate: Scalars['DateTime'];
  /** title input for default locale (en) */
  title: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type EventCreateLocalizationDataInput = {
  category?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  description: Scalars['RichTextAST'];
  details: Scalars['String'];
  title: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type EventCreateLocalizationInput = {
  /** Localization input */
  data: EventCreateLocalizationDataInput;
  locale: Locale;
};

export type EventCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<EventCreateLocalizationInput>>;
};

export type EventCreateManyInlineInput = {
  /** Connect multiple existing Event documents */
  connect?: InputMaybe<Array<EventWhereUniqueInput>>;
  /** Create and connect multiple existing Event documents */
  create?: InputMaybe<Array<EventCreateInput>>;
};

export type EventCreateOneInlineInput = {
  /** Connect one existing Event document */
  connect?: InputMaybe<EventWhereUniqueInput>;
  /** Create and connect one Event document */
  create?: InputMaybe<EventCreateInput>;
};

/** An edge in a connection. */
export type EventEdge = {
  __typename?: 'EventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Event;
};

/** Identifies documents */
export type EventManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<EventWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<EventWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<EventWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  card?: InputMaybe<CardWhereInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  endDate_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  endDate_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  endDate_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  endDate_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  endDate_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  endDate_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  endDate_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  gallery_every?: InputMaybe<AssetWhereInput>;
  gallery_none?: InputMaybe<AssetWhereInput>;
  gallery_some?: InputMaybe<AssetWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  image?: InputMaybe<AssetWhereInput>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  slug?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  slug_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  slug_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  slug_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  slug_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  slug_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  slug_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  slug_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  slug_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  slug_starts_with?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  startDate_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  startDate_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  startDate_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  startDate_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  startDate_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  startDate_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  startDate_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

export enum EventOrderByInput {
  CategoryAsc = 'category_ASC',
  CategoryDesc = 'category_DESC',
  CreatedAtAsc = 'createdAt_ASC',
  CreatedAtDesc = 'createdAt_DESC',
  DetailsAsc = 'details_ASC',
  DetailsDesc = 'details_DESC',
  EndDateAsc = 'endDate_ASC',
  EndDateDesc = 'endDate_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  PublishedAtAsc = 'publishedAt_ASC',
  PublishedAtDesc = 'publishedAt_DESC',
  SlugAsc = 'slug_ASC',
  SlugDesc = 'slug_DESC',
  StartDateAsc = 'startDate_ASC',
  StartDateDesc = 'startDate_DESC',
  TitleAsc = 'title_ASC',
  TitleDesc = 'title_DESC',
  UpdatedAtAsc = 'updatedAt_ASC',
  UpdatedAtDesc = 'updatedAt_DESC'
}

export type EventUpdateInput = {
  card?: InputMaybe<CardUpdateOneInlineInput>;
  /** category input for default locale (en) */
  category?: InputMaybe<Scalars['String']>;
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['RichTextAST']>;
  /** details input for default locale (en) */
  details?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  gallery?: InputMaybe<AssetUpdateManyInlineInput>;
  image?: InputMaybe<AssetUpdateOneInlineInput>;
  /** Manage document localizations */
  localizations?: InputMaybe<EventUpdateLocalizationsInput>;
  slug?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
};

export type EventUpdateLocalizationDataInput = {
  category?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['RichTextAST']>;
  details?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export type EventUpdateLocalizationInput = {
  data: EventUpdateLocalizationDataInput;
  locale: Locale;
};

export type EventUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<EventCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<EventUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<EventUpsertLocalizationInput>>;
};

export type EventUpdateManyInlineInput = {
  /** Connect multiple existing Event documents */
  connect?: InputMaybe<Array<EventConnectInput>>;
  /** Create and connect multiple Event documents */
  create?: InputMaybe<Array<EventCreateInput>>;
  /** Delete multiple Event documents */
  delete?: InputMaybe<Array<EventWhereUniqueInput>>;
  /** Disconnect multiple Event documents */
  disconnect?: InputMaybe<Array<EventWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing Event documents */
  set?: InputMaybe<Array<EventWhereUniqueInput>>;
  /** Update multiple Event documents */
  update?: InputMaybe<Array<EventUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple Event documents */
  upsert?: InputMaybe<Array<EventUpsertWithNestedWhereUniqueInput>>;
};

export type EventUpdateManyInput = {
  /** category input for default locale (en) */
  category?: InputMaybe<Scalars['String']>;
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['RichTextAST']>;
  /** details input for default locale (en) */
  details?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  /** Optional updates to localizations */
  localizations?: InputMaybe<EventUpdateManyLocalizationsInput>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
};

export type EventUpdateManyLocalizationDataInput = {
  category?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['RichTextAST']>;
  details?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export type EventUpdateManyLocalizationInput = {
  data: EventUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type EventUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<EventUpdateManyLocalizationInput>>;
};

export type EventUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: EventUpdateManyInput;
  /** Document search */
  where: EventWhereInput;
};

export type EventUpdateOneInlineInput = {
  /** Connect existing Event document */
  connect?: InputMaybe<EventWhereUniqueInput>;
  /** Create and connect one Event document */
  create?: InputMaybe<EventCreateInput>;
  /** Delete currently connected Event document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected Event document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single Event document */
  update?: InputMaybe<EventUpdateWithNestedWhereUniqueInput>;
  /** Upsert single Event document */
  upsert?: InputMaybe<EventUpsertWithNestedWhereUniqueInput>;
};

export type EventUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: EventUpdateInput;
  /** Unique document search */
  where: EventWhereUniqueInput;
};

export type EventUpsertInput = {
  /** Create document if it didn't exist */
  create: EventCreateInput;
  /** Update document if it exists */
  update: EventUpdateInput;
};

export type EventUpsertLocalizationInput = {
  create: EventCreateLocalizationDataInput;
  locale: Locale;
  update: EventUpdateLocalizationDataInput;
};

export type EventUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: EventUpsertInput;
  /** Unique document search */
  where: EventWhereUniqueInput;
};

/** Identifies documents */
export type EventWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<EventWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<EventWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<EventWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  card?: InputMaybe<CardWhereInput>;
  category?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  category_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  category_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  category_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  category_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  category_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  category_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  category_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  category_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  category_starts_with?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  details?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  details_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  details_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  details_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  details_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  details_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  details_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  details_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  details_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  details_starts_with?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  endDate_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  endDate_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  endDate_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  endDate_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  endDate_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  endDate_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  endDate_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  gallery_every?: InputMaybe<AssetWhereInput>;
  gallery_none?: InputMaybe<AssetWhereInput>;
  gallery_some?: InputMaybe<AssetWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  image?: InputMaybe<AssetWhereInput>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  slug?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  slug_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  slug_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  slug_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  slug_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  slug_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  slug_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  slug_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  slug_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  slug_starts_with?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  startDate_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  startDate_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  startDate_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  startDate_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  startDate_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  startDate_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  startDate_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  title?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  title_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  title_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  title_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  title_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  title_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  title_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  title_starts_with?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

/** References Event record uniquely */
export type EventWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
  slug?: InputMaybe<Scalars['String']>;
};

export type Fact = {
  __typename?: 'Fact';
  description: Scalars['String'];
  /** The unique identifier */
  id: Scalars['ID'];
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<Fact>;
  /** System stage field */
  stage: Stage;
  title: Scalars['String'];
};


export type FactLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};

export type FactConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: FactWhereUniqueInput;
};

/** A connection to a list of items. */
export type FactConnection = {
  __typename?: 'FactConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<FactEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type FactCreateInput = {
  /** description input for default locale (en) */
  description: Scalars['String'];
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<FactCreateLocalizationsInput>;
  /** title input for default locale (en) */
  title: Scalars['String'];
};

export type FactCreateLocalizationDataInput = {
  description: Scalars['String'];
  title: Scalars['String'];
};

export type FactCreateLocalizationInput = {
  /** Localization input */
  data: FactCreateLocalizationDataInput;
  locale: Locale;
};

export type FactCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<FactCreateLocalizationInput>>;
};

export type FactCreateManyInlineInput = {
  /** Create and connect multiple existing Fact documents */
  create?: InputMaybe<Array<FactCreateInput>>;
};

export type FactCreateOneInlineInput = {
  /** Create and connect one Fact document */
  create?: InputMaybe<FactCreateInput>;
};

export type FactCreateWithPositionInput = {
  /** Document to create */
  data: FactCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type FactEdge = {
  __typename?: 'FactEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Fact;
};

/** Identifies documents */
export type FactManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<FactWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<FactWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<FactWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
};

export enum FactOrderByInput {
  DescriptionAsc = 'description_ASC',
  DescriptionDesc = 'description_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  TitleAsc = 'title_ASC',
  TitleDesc = 'title_DESC'
}

export type FactParent = AssociationProfileSection;

export type FactParentConnectInput = {
  AssociationProfileSection?: InputMaybe<AssociationProfileSectionConnectInput>;
};

export type FactParentCreateInput = {
  AssociationProfileSection?: InputMaybe<AssociationProfileSectionCreateInput>;
};

export type FactParentCreateManyInlineInput = {
  /** Create and connect multiple existing FactParent documents */
  create?: InputMaybe<Array<FactParentCreateInput>>;
};

export type FactParentCreateOneInlineInput = {
  /** Create and connect one FactParent document */
  create?: InputMaybe<FactParentCreateInput>;
};

export type FactParentCreateWithPositionInput = {
  AssociationProfileSection?: InputMaybe<AssociationProfileSectionCreateWithPositionInput>;
};

export type FactParentUpdateInput = {
  AssociationProfileSection?: InputMaybe<AssociationProfileSectionUpdateInput>;
};

export type FactParentUpdateManyInlineInput = {
  /** Create and connect multiple FactParent component instances */
  create?: InputMaybe<Array<FactParentCreateWithPositionInput>>;
  /** Delete multiple FactParent documents */
  delete?: InputMaybe<Array<FactParentWhereUniqueInput>>;
  /** Update multiple FactParent component instances */
  update?: InputMaybe<Array<FactParentUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple FactParent component instances */
  upsert?: InputMaybe<Array<FactParentUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type FactParentUpdateManyWithNestedWhereInput = {
  AssociationProfileSection?: InputMaybe<AssociationProfileSectionUpdateManyWithNestedWhereInput>;
};

export type FactParentUpdateOneInlineInput = {
  /** Create and connect one FactParent document */
  create?: InputMaybe<FactParentCreateInput>;
  /** Delete currently connected FactParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single FactParent document */
  update?: InputMaybe<FactParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single FactParent document */
  upsert?: InputMaybe<FactParentUpsertWithNestedWhereUniqueInput>;
};

export type FactParentUpdateWithNestedWhereUniqueAndPositionInput = {
  AssociationProfileSection?: InputMaybe<AssociationProfileSectionUpdateWithNestedWhereUniqueAndPositionInput>;
};

export type FactParentUpdateWithNestedWhereUniqueInput = {
  AssociationProfileSection?: InputMaybe<AssociationProfileSectionUpdateWithNestedWhereUniqueInput>;
};

export type FactParentUpsertWithNestedWhereUniqueAndPositionInput = {
  AssociationProfileSection?: InputMaybe<AssociationProfileSectionUpsertWithNestedWhereUniqueAndPositionInput>;
};

export type FactParentUpsertWithNestedWhereUniqueInput = {
  AssociationProfileSection?: InputMaybe<AssociationProfileSectionUpsertWithNestedWhereUniqueInput>;
};

export type FactParentWhereInput = {
  AssociationProfileSection?: InputMaybe<AssociationProfileSectionWhereInput>;
};

export type FactParentWhereUniqueInput = {
  AssociationProfileSection?: InputMaybe<AssociationProfileSectionWhereUniqueInput>;
};

export type FactUpdateInput = {
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  /** Manage document localizations */
  localizations?: InputMaybe<FactUpdateLocalizationsInput>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
};

export type FactUpdateLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export type FactUpdateLocalizationInput = {
  data: FactUpdateLocalizationDataInput;
  locale: Locale;
};

export type FactUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<FactCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<FactUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<FactUpsertLocalizationInput>>;
};

export type FactUpdateManyInlineInput = {
  /** Create and connect multiple Fact component instances */
  create?: InputMaybe<Array<FactCreateWithPositionInput>>;
  /** Delete multiple Fact documents */
  delete?: InputMaybe<Array<FactWhereUniqueInput>>;
  /** Update multiple Fact component instances */
  update?: InputMaybe<Array<FactUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple Fact component instances */
  upsert?: InputMaybe<Array<FactUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type FactUpdateManyInput = {
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  /** Optional updates to localizations */
  localizations?: InputMaybe<FactUpdateManyLocalizationsInput>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
};

export type FactUpdateManyLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export type FactUpdateManyLocalizationInput = {
  data: FactUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type FactUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<FactUpdateManyLocalizationInput>>;
};

export type FactUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: FactUpdateManyInput;
  /** Document search */
  where: FactWhereInput;
};

export type FactUpdateOneInlineInput = {
  /** Create and connect one Fact document */
  create?: InputMaybe<FactCreateInput>;
  /** Delete currently connected Fact document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single Fact document */
  update?: InputMaybe<FactUpdateWithNestedWhereUniqueInput>;
  /** Upsert single Fact document */
  upsert?: InputMaybe<FactUpsertWithNestedWhereUniqueInput>;
};

export type FactUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<FactUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: FactWhereUniqueInput;
};

export type FactUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: FactUpdateInput;
  /** Unique document search */
  where: FactWhereUniqueInput;
};

export type FactUpsertInput = {
  /** Create document if it didn't exist */
  create: FactCreateInput;
  /** Update document if it exists */
  update: FactUpdateInput;
};

export type FactUpsertLocalizationInput = {
  create: FactCreateLocalizationDataInput;
  locale: Locale;
  update: FactUpdateLocalizationDataInput;
};

export type FactUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<FactUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: FactWhereUniqueInput;
};

export type FactUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: FactUpsertInput;
  /** Unique document search */
  where: FactWhereUniqueInput;
};

/** Identifies documents */
export type FactWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<FactWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<FactWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<FactWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  description_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  description_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  description_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  description_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  description_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  description_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  description_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  description_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  description_starts_with?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  title?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  title_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  title_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  title_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  title_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  title_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  title_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  title_starts_with?: InputMaybe<Scalars['String']>;
};

/** References Fact record uniquely */
export type FactWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export type Footer = {
  __typename?: 'Footer';
  columns: Array<OldColumn>;
  description?: Maybe<Scalars['String']>;
  /** The unique identifier */
  id: Scalars['ID'];
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<Footer>;
  secondaryLinks: Array<Link>;
  /** System stage field */
  stage: Stage;
  title?: Maybe<Scalars['String']>;
};


export type FooterColumnsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  orderBy?: InputMaybe<OldColumnOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<OldColumnWhereInput>;
};


export type FooterLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};


export type FooterSecondaryLinksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  orderBy?: InputMaybe<LinkOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<LinkWhereInput>;
};

export type FooterConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: FooterWhereUniqueInput;
};

/** A connection to a list of items. */
export type FooterConnection = {
  __typename?: 'FooterConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<FooterEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type FooterCreateInput = {
  columns?: InputMaybe<OldColumnCreateManyInlineInput>;
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<FooterCreateLocalizationsInput>;
  secondaryLinks?: InputMaybe<LinkCreateManyInlineInput>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
};

export type FooterCreateLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export type FooterCreateLocalizationInput = {
  /** Localization input */
  data: FooterCreateLocalizationDataInput;
  locale: Locale;
};

export type FooterCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<FooterCreateLocalizationInput>>;
};

export type FooterCreateManyInlineInput = {
  /** Create and connect multiple existing Footer documents */
  create?: InputMaybe<Array<FooterCreateInput>>;
};

export type FooterCreateOneInlineInput = {
  /** Create and connect one Footer document */
  create?: InputMaybe<FooterCreateInput>;
};

export type FooterCreateWithPositionInput = {
  /** Document to create */
  data: FooterCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type FooterEdge = {
  __typename?: 'FooterEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Footer;
};

/** Identifies documents */
export type FooterManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<FooterWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<FooterWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<FooterWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  columns_every?: InputMaybe<OldColumnWhereInput>;
  columns_none?: InputMaybe<OldColumnWhereInput>;
  columns_some?: InputMaybe<OldColumnWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  secondaryLinks_every?: InputMaybe<LinkWhereInput>;
  secondaryLinks_none?: InputMaybe<LinkWhereInput>;
  secondaryLinks_some?: InputMaybe<LinkWhereInput>;
};

export enum FooterOrderByInput {
  DescriptionAsc = 'description_ASC',
  DescriptionDesc = 'description_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  TitleAsc = 'title_ASC',
  TitleDesc = 'title_DESC'
}

export type FooterParent = Layout;

export type FooterParentConnectInput = {
  Layout?: InputMaybe<LayoutConnectInput>;
};

export type FooterParentCreateInput = {
  Layout?: InputMaybe<LayoutCreateInput>;
};

export type FooterParentCreateManyInlineInput = {
  /** Connect multiple existing FooterParent documents */
  connect?: InputMaybe<Array<FooterParentWhereUniqueInput>>;
  /** Create and connect multiple existing FooterParent documents */
  create?: InputMaybe<Array<FooterParentCreateInput>>;
};

export type FooterParentCreateOneInlineInput = {
  /** Connect one existing FooterParent document */
  connect?: InputMaybe<FooterParentWhereUniqueInput>;
  /** Create and connect one FooterParent document */
  create?: InputMaybe<FooterParentCreateInput>;
};

export type FooterParentUpdateInput = {
  Layout?: InputMaybe<LayoutUpdateInput>;
};

export type FooterParentUpdateManyInlineInput = {
  /** Connect multiple existing FooterParent documents */
  connect?: InputMaybe<Array<FooterParentConnectInput>>;
  /** Create and connect multiple FooterParent documents */
  create?: InputMaybe<Array<FooterParentCreateInput>>;
  /** Delete multiple FooterParent documents */
  delete?: InputMaybe<Array<FooterParentWhereUniqueInput>>;
  /** Disconnect multiple FooterParent documents */
  disconnect?: InputMaybe<Array<FooterParentWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing FooterParent documents */
  set?: InputMaybe<Array<FooterParentWhereUniqueInput>>;
  /** Update multiple FooterParent documents */
  update?: InputMaybe<Array<FooterParentUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple FooterParent documents */
  upsert?: InputMaybe<Array<FooterParentUpsertWithNestedWhereUniqueInput>>;
};

export type FooterParentUpdateManyWithNestedWhereInput = {
  Layout?: InputMaybe<LayoutUpdateManyWithNestedWhereInput>;
};

export type FooterParentUpdateOneInlineInput = {
  /** Connect existing FooterParent document */
  connect?: InputMaybe<FooterParentWhereUniqueInput>;
  /** Create and connect one FooterParent document */
  create?: InputMaybe<FooterParentCreateInput>;
  /** Delete currently connected FooterParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected FooterParent document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single FooterParent document */
  update?: InputMaybe<FooterParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single FooterParent document */
  upsert?: InputMaybe<FooterParentUpsertWithNestedWhereUniqueInput>;
};

export type FooterParentUpdateWithNestedWhereUniqueInput = {
  Layout?: InputMaybe<LayoutUpdateWithNestedWhereUniqueInput>;
};

export type FooterParentUpsertWithNestedWhereUniqueInput = {
  Layout?: InputMaybe<LayoutUpsertWithNestedWhereUniqueInput>;
};

export type FooterParentWhereInput = {
  Layout?: InputMaybe<LayoutWhereInput>;
};

export type FooterParentWhereUniqueInput = {
  Layout?: InputMaybe<LayoutWhereUniqueInput>;
};

export type FooterUpdateInput = {
  columns?: InputMaybe<OldColumnUpdateManyInlineInput>;
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  /** Manage document localizations */
  localizations?: InputMaybe<FooterUpdateLocalizationsInput>;
  secondaryLinks?: InputMaybe<LinkUpdateManyInlineInput>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
};

export type FooterUpdateLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export type FooterUpdateLocalizationInput = {
  data: FooterUpdateLocalizationDataInput;
  locale: Locale;
};

export type FooterUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<FooterCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<FooterUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<FooterUpsertLocalizationInput>>;
};

export type FooterUpdateManyInlineInput = {
  /** Create and connect multiple Footer component instances */
  create?: InputMaybe<Array<FooterCreateWithPositionInput>>;
  /** Delete multiple Footer documents */
  delete?: InputMaybe<Array<FooterWhereUniqueInput>>;
  /** Update multiple Footer component instances */
  update?: InputMaybe<Array<FooterUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple Footer component instances */
  upsert?: InputMaybe<Array<FooterUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type FooterUpdateManyInput = {
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  /** Optional updates to localizations */
  localizations?: InputMaybe<FooterUpdateManyLocalizationsInput>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
};

export type FooterUpdateManyLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export type FooterUpdateManyLocalizationInput = {
  data: FooterUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type FooterUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<FooterUpdateManyLocalizationInput>>;
};

export type FooterUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: FooterUpdateManyInput;
  /** Document search */
  where: FooterWhereInput;
};

export type FooterUpdateOneInlineInput = {
  /** Create and connect one Footer document */
  create?: InputMaybe<FooterCreateInput>;
  /** Delete currently connected Footer document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single Footer document */
  update?: InputMaybe<FooterUpdateWithNestedWhereUniqueInput>;
  /** Upsert single Footer document */
  upsert?: InputMaybe<FooterUpsertWithNestedWhereUniqueInput>;
};

export type FooterUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<FooterUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: FooterWhereUniqueInput;
};

export type FooterUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: FooterUpdateInput;
  /** Unique document search */
  where: FooterWhereUniqueInput;
};

export type FooterUpsertInput = {
  /** Create document if it didn't exist */
  create: FooterCreateInput;
  /** Update document if it exists */
  update: FooterUpdateInput;
};

export type FooterUpsertLocalizationInput = {
  create: FooterCreateLocalizationDataInput;
  locale: Locale;
  update: FooterUpdateLocalizationDataInput;
};

export type FooterUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<FooterUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: FooterWhereUniqueInput;
};

export type FooterUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: FooterUpsertInput;
  /** Unique document search */
  where: FooterWhereUniqueInput;
};

/** Identifies documents */
export type FooterWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<FooterWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<FooterWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<FooterWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  columns_every?: InputMaybe<OldColumnWhereInput>;
  columns_none?: InputMaybe<OldColumnWhereInput>;
  columns_some?: InputMaybe<OldColumnWhereInput>;
  description?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  description_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  description_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  description_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  description_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  description_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  description_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  description_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  description_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  description_starts_with?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  secondaryLinks_every?: InputMaybe<LinkWhereInput>;
  secondaryLinks_none?: InputMaybe<LinkWhereInput>;
  secondaryLinks_some?: InputMaybe<LinkWhereInput>;
  title?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  title_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  title_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  title_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  title_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  title_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  title_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  title_starts_with?: InputMaybe<Scalars['String']>;
};

/** References Footer record uniquely */
export type FooterWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export type Form = Node & {
  __typename?: 'Form';
  container?: Maybe<Container>;
  /** The time the document was created */
  createdAt: Scalars['DateTime'];
  /** User that created this document */
  createdBy?: Maybe<User>;
  /** Get the document in other stages */
  documentInStages: Array<Form>;
  fields?: Maybe<FormfieldsUnion>;
  /** List of Form versions */
  history: Array<Version>;
  /** The unique identifier */
  id: Scalars['ID'];
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<Form>;
  pages: Array<Page>;
  /** The time the document was published. Null on documents in draft stage. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** User that last published this document */
  publishedBy?: Maybe<User>;
  scheduledIn: Array<ScheduledOperation>;
  /** System stage field */
  stage: Stage;
  /** The time the document was updated */
  updatedAt: Scalars['DateTime'];
  /** User that last updated this document */
  updatedBy?: Maybe<User>;
};


export type FormContainerArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type FormCreatedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type FormCreatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type FormDocumentInStagesArgs = {
  includeCurrent?: Scalars['Boolean'];
  inheritLocale?: Scalars['Boolean'];
  stages?: Array<Stage>;
};


export type FormFieldsArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type FormHistoryArgs = {
  limit?: Scalars['Int'];
  skip?: Scalars['Int'];
  stageOverride?: InputMaybe<Stage>;
};


export type FormLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};


export type FormPagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  orderBy?: InputMaybe<PageOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PageWhereInput>;
};


export type FormPublishedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type FormPublishedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type FormScheduledInArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ScheduledOperationWhereInput>;
};


export type FormUpdatedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type FormUpdatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};

export type FormCheckbox = {
  __typename?: 'FormCheckbox';
  /** The unique identifier */
  id: Scalars['ID'];
  label: Scalars['String'];
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<FormCheckbox>;
  name: Scalars['String'];
  required: Scalars['Boolean'];
  /** System stage field */
  stage: Stage;
};


export type FormCheckboxLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};

export type FormCheckboxConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: FormCheckboxWhereUniqueInput;
};

/** A connection to a list of items. */
export type FormCheckboxConnection = {
  __typename?: 'FormCheckboxConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<FormCheckboxEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type FormCheckboxCreateInput = {
  /** label input for default locale (en) */
  label: Scalars['String'];
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<FormCheckboxCreateLocalizationsInput>;
  name: Scalars['String'];
  required: Scalars['Boolean'];
};

export type FormCheckboxCreateLocalizationDataInput = {
  label: Scalars['String'];
};

export type FormCheckboxCreateLocalizationInput = {
  /** Localization input */
  data: FormCheckboxCreateLocalizationDataInput;
  locale: Locale;
};

export type FormCheckboxCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<FormCheckboxCreateLocalizationInput>>;
};

export type FormCheckboxCreateManyInlineInput = {
  /** Create and connect multiple existing FormCheckbox documents */
  create?: InputMaybe<Array<FormCheckboxCreateInput>>;
};

export type FormCheckboxCreateOneInlineInput = {
  /** Create and connect one FormCheckbox document */
  create?: InputMaybe<FormCheckboxCreateInput>;
};

export type FormCheckboxCreateWithPositionInput = {
  /** Document to create */
  data: FormCheckboxCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type FormCheckboxEdge = {
  __typename?: 'FormCheckboxEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: FormCheckbox;
};

/** Identifies documents */
export type FormCheckboxManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<FormCheckboxWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<FormCheckboxWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<FormCheckboxWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  name?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  name_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  name_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  name_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  name_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  name_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  name_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  name_starts_with?: InputMaybe<Scalars['String']>;
  required?: InputMaybe<Scalars['Boolean']>;
  /** All values that are not equal to given value. */
  required_not?: InputMaybe<Scalars['Boolean']>;
};

export enum FormCheckboxOrderByInput {
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  LabelAsc = 'label_ASC',
  LabelDesc = 'label_DESC',
  NameAsc = 'name_ASC',
  NameDesc = 'name_DESC',
  RequiredAsc = 'required_ASC',
  RequiredDesc = 'required_DESC'
}

export type FormCheckboxParent = Container | Form;

export type FormCheckboxParentConnectInput = {
  Container?: InputMaybe<ContainerConnectInput>;
  Form?: InputMaybe<FormConnectInput>;
};

export type FormCheckboxParentCreateInput = {
  Container?: InputMaybe<ContainerCreateInput>;
  Form?: InputMaybe<FormCreateInput>;
};

export type FormCheckboxParentCreateManyInlineInput = {
  /** Connect multiple existing FormCheckboxParent documents */
  connect?: InputMaybe<Array<FormCheckboxParentWhereUniqueInput>>;
  /** Create and connect multiple existing FormCheckboxParent documents */
  create?: InputMaybe<Array<FormCheckboxParentCreateInput>>;
};

export type FormCheckboxParentCreateOneInlineInput = {
  /** Connect one existing FormCheckboxParent document */
  connect?: InputMaybe<FormCheckboxParentWhereUniqueInput>;
  /** Create and connect one FormCheckboxParent document */
  create?: InputMaybe<FormCheckboxParentCreateInput>;
};

export type FormCheckboxParentUpdateInput = {
  Container?: InputMaybe<ContainerUpdateInput>;
  Form?: InputMaybe<FormUpdateInput>;
};

export type FormCheckboxParentUpdateManyInlineInput = {
  /** Connect multiple existing FormCheckboxParent documents */
  connect?: InputMaybe<Array<FormCheckboxParentConnectInput>>;
  /** Create and connect multiple FormCheckboxParent documents */
  create?: InputMaybe<Array<FormCheckboxParentCreateInput>>;
  /** Delete multiple FormCheckboxParent documents */
  delete?: InputMaybe<Array<FormCheckboxParentWhereUniqueInput>>;
  /** Disconnect multiple FormCheckboxParent documents */
  disconnect?: InputMaybe<Array<FormCheckboxParentWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing FormCheckboxParent documents */
  set?: InputMaybe<Array<FormCheckboxParentWhereUniqueInput>>;
  /** Update multiple FormCheckboxParent documents */
  update?: InputMaybe<Array<FormCheckboxParentUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple FormCheckboxParent documents */
  upsert?: InputMaybe<Array<FormCheckboxParentUpsertWithNestedWhereUniqueInput>>;
};

export type FormCheckboxParentUpdateManyWithNestedWhereInput = {
  Container?: InputMaybe<ContainerUpdateManyWithNestedWhereInput>;
  Form?: InputMaybe<FormUpdateManyWithNestedWhereInput>;
};

export type FormCheckboxParentUpdateOneInlineInput = {
  /** Connect existing FormCheckboxParent document */
  connect?: InputMaybe<FormCheckboxParentWhereUniqueInput>;
  /** Create and connect one FormCheckboxParent document */
  create?: InputMaybe<FormCheckboxParentCreateInput>;
  /** Delete currently connected FormCheckboxParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected FormCheckboxParent document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single FormCheckboxParent document */
  update?: InputMaybe<FormCheckboxParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single FormCheckboxParent document */
  upsert?: InputMaybe<FormCheckboxParentUpsertWithNestedWhereUniqueInput>;
};

export type FormCheckboxParentUpdateWithNestedWhereUniqueInput = {
  Container?: InputMaybe<ContainerUpdateWithNestedWhereUniqueInput>;
  Form?: InputMaybe<FormUpdateWithNestedWhereUniqueInput>;
};

export type FormCheckboxParentUpsertWithNestedWhereUniqueInput = {
  Container?: InputMaybe<ContainerUpsertWithNestedWhereUniqueInput>;
  Form?: InputMaybe<FormUpsertWithNestedWhereUniqueInput>;
};

export type FormCheckboxParentWhereInput = {
  Container?: InputMaybe<ContainerWhereInput>;
  Form?: InputMaybe<FormWhereInput>;
};

export type FormCheckboxParentWhereUniqueInput = {
  Container?: InputMaybe<ContainerWhereUniqueInput>;
  Form?: InputMaybe<FormWhereUniqueInput>;
};

export type FormCheckboxUpdateInput = {
  /** label input for default locale (en) */
  label?: InputMaybe<Scalars['String']>;
  /** Manage document localizations */
  localizations?: InputMaybe<FormCheckboxUpdateLocalizationsInput>;
  name?: InputMaybe<Scalars['String']>;
  required?: InputMaybe<Scalars['Boolean']>;
};

export type FormCheckboxUpdateLocalizationDataInput = {
  label?: InputMaybe<Scalars['String']>;
};

export type FormCheckboxUpdateLocalizationInput = {
  data: FormCheckboxUpdateLocalizationDataInput;
  locale: Locale;
};

export type FormCheckboxUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<FormCheckboxCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<FormCheckboxUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<FormCheckboxUpsertLocalizationInput>>;
};

export type FormCheckboxUpdateManyInlineInput = {
  /** Create and connect multiple FormCheckbox component instances */
  create?: InputMaybe<Array<FormCheckboxCreateWithPositionInput>>;
  /** Delete multiple FormCheckbox documents */
  delete?: InputMaybe<Array<FormCheckboxWhereUniqueInput>>;
  /** Update multiple FormCheckbox component instances */
  update?: InputMaybe<Array<FormCheckboxUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple FormCheckbox component instances */
  upsert?: InputMaybe<Array<FormCheckboxUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type FormCheckboxUpdateManyInput = {
  /** label input for default locale (en) */
  label?: InputMaybe<Scalars['String']>;
  /** Optional updates to localizations */
  localizations?: InputMaybe<FormCheckboxUpdateManyLocalizationsInput>;
  name?: InputMaybe<Scalars['String']>;
  required?: InputMaybe<Scalars['Boolean']>;
};

export type FormCheckboxUpdateManyLocalizationDataInput = {
  label?: InputMaybe<Scalars['String']>;
};

export type FormCheckboxUpdateManyLocalizationInput = {
  data: FormCheckboxUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type FormCheckboxUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<FormCheckboxUpdateManyLocalizationInput>>;
};

export type FormCheckboxUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: FormCheckboxUpdateManyInput;
  /** Document search */
  where: FormCheckboxWhereInput;
};

export type FormCheckboxUpdateOneInlineInput = {
  /** Create and connect one FormCheckbox document */
  create?: InputMaybe<FormCheckboxCreateInput>;
  /** Delete currently connected FormCheckbox document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single FormCheckbox document */
  update?: InputMaybe<FormCheckboxUpdateWithNestedWhereUniqueInput>;
  /** Upsert single FormCheckbox document */
  upsert?: InputMaybe<FormCheckboxUpsertWithNestedWhereUniqueInput>;
};

export type FormCheckboxUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<FormCheckboxUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: FormCheckboxWhereUniqueInput;
};

export type FormCheckboxUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: FormCheckboxUpdateInput;
  /** Unique document search */
  where: FormCheckboxWhereUniqueInput;
};

export type FormCheckboxUpsertInput = {
  /** Create document if it didn't exist */
  create: FormCheckboxCreateInput;
  /** Update document if it exists */
  update: FormCheckboxUpdateInput;
};

export type FormCheckboxUpsertLocalizationInput = {
  create: FormCheckboxCreateLocalizationDataInput;
  locale: Locale;
  update: FormCheckboxUpdateLocalizationDataInput;
};

export type FormCheckboxUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<FormCheckboxUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: FormCheckboxWhereUniqueInput;
};

export type FormCheckboxUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: FormCheckboxUpsertInput;
  /** Unique document search */
  where: FormCheckboxWhereUniqueInput;
};

/** Identifies documents */
export type FormCheckboxWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<FormCheckboxWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<FormCheckboxWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<FormCheckboxWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  label?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  label_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  label_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  label_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  label_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  label_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  label_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  label_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  label_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  label_starts_with?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  name_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  name_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  name_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  name_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  name_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  name_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  name_starts_with?: InputMaybe<Scalars['String']>;
  required?: InputMaybe<Scalars['Boolean']>;
  /** All values that are not equal to given value. */
  required_not?: InputMaybe<Scalars['Boolean']>;
};

/** References FormCheckbox record uniquely */
export type FormCheckboxWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export type FormConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: FormWhereUniqueInput;
};

/** A connection to a list of items. */
export type FormConnection = {
  __typename?: 'FormConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<FormEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type FormCreateInput = {
  container?: InputMaybe<ContainerCreateOneInlineInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  fields?: InputMaybe<FormfieldsUnionCreateOneInlineInput>;
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<FormCreateLocalizationsInput>;
  pages?: InputMaybe<PageCreateManyInlineInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type FormCreateLocalizationDataInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type FormCreateLocalizationInput = {
  /** Localization input */
  data: FormCreateLocalizationDataInput;
  locale: Locale;
};

export type FormCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<FormCreateLocalizationInput>>;
};

export type FormCreateManyInlineInput = {
  /** Connect multiple existing Form documents */
  connect?: InputMaybe<Array<FormWhereUniqueInput>>;
  /** Create and connect multiple existing Form documents */
  create?: InputMaybe<Array<FormCreateInput>>;
};

export type FormCreateOneInlineInput = {
  /** Connect one existing Form document */
  connect?: InputMaybe<FormWhereUniqueInput>;
  /** Create and connect one Form document */
  create?: InputMaybe<FormCreateInput>;
};

/** An edge in a connection. */
export type FormEdge = {
  __typename?: 'FormEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Form;
};

export type FormInput = {
  __typename?: 'FormInput';
  /** The unique identifier */
  id: Scalars['ID'];
  label: Scalars['String'];
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<FormInput>;
  name: Scalars['String'];
  placeholder?: Maybe<Scalars['String']>;
  required: Scalars['Boolean'];
  /** System stage field */
  stage: Stage;
  type?: Maybe<InputType>;
};


export type FormInputLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};

export type FormInputConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: FormInputWhereUniqueInput;
};

/** A connection to a list of items. */
export type FormInputConnection = {
  __typename?: 'FormInputConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<FormInputEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type FormInputCreateInput = {
  /** label input for default locale (en) */
  label: Scalars['String'];
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<FormInputCreateLocalizationsInput>;
  /** name input for default locale (en) */
  name: Scalars['String'];
  /** placeholder input for default locale (en) */
  placeholder?: InputMaybe<Scalars['String']>;
  required: Scalars['Boolean'];
  type?: InputMaybe<InputType>;
};

export type FormInputCreateLocalizationDataInput = {
  label: Scalars['String'];
  name: Scalars['String'];
  placeholder?: InputMaybe<Scalars['String']>;
};

export type FormInputCreateLocalizationInput = {
  /** Localization input */
  data: FormInputCreateLocalizationDataInput;
  locale: Locale;
};

export type FormInputCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<FormInputCreateLocalizationInput>>;
};

export type FormInputCreateManyInlineInput = {
  /** Create and connect multiple existing FormInput documents */
  create?: InputMaybe<Array<FormInputCreateInput>>;
};

export type FormInputCreateOneInlineInput = {
  /** Create and connect one FormInput document */
  create?: InputMaybe<FormInputCreateInput>;
};

export type FormInputCreateWithPositionInput = {
  /** Document to create */
  data: FormInputCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type FormInputEdge = {
  __typename?: 'FormInputEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: FormInput;
};

/** Identifies documents */
export type FormInputManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<FormInputWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<FormInputWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<FormInputWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  required?: InputMaybe<Scalars['Boolean']>;
  /** All values that are not equal to given value. */
  required_not?: InputMaybe<Scalars['Boolean']>;
  type?: InputMaybe<InputType>;
  /** All values that are contained in given list. */
  type_in?: InputMaybe<Array<InputMaybe<InputType>>>;
  /** All values that are not equal to given value. */
  type_not?: InputMaybe<InputType>;
  /** All values that are not contained in given list. */
  type_not_in?: InputMaybe<Array<InputMaybe<InputType>>>;
};

export enum FormInputOrderByInput {
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  LabelAsc = 'label_ASC',
  LabelDesc = 'label_DESC',
  NameAsc = 'name_ASC',
  NameDesc = 'name_DESC',
  PlaceholderAsc = 'placeholder_ASC',
  PlaceholderDesc = 'placeholder_DESC',
  RequiredAsc = 'required_ASC',
  RequiredDesc = 'required_DESC',
  TypeAsc = 'type_ASC',
  TypeDesc = 'type_DESC'
}

export type FormInputParent = Container | Form;

export type FormInputParentConnectInput = {
  Container?: InputMaybe<ContainerConnectInput>;
  Form?: InputMaybe<FormConnectInput>;
};

export type FormInputParentCreateInput = {
  Container?: InputMaybe<ContainerCreateInput>;
  Form?: InputMaybe<FormCreateInput>;
};

export type FormInputParentCreateManyInlineInput = {
  /** Connect multiple existing FormInputParent documents */
  connect?: InputMaybe<Array<FormInputParentWhereUniqueInput>>;
  /** Create and connect multiple existing FormInputParent documents */
  create?: InputMaybe<Array<FormInputParentCreateInput>>;
};

export type FormInputParentCreateOneInlineInput = {
  /** Connect one existing FormInputParent document */
  connect?: InputMaybe<FormInputParentWhereUniqueInput>;
  /** Create and connect one FormInputParent document */
  create?: InputMaybe<FormInputParentCreateInput>;
};

export type FormInputParentUpdateInput = {
  Container?: InputMaybe<ContainerUpdateInput>;
  Form?: InputMaybe<FormUpdateInput>;
};

export type FormInputParentUpdateManyInlineInput = {
  /** Connect multiple existing FormInputParent documents */
  connect?: InputMaybe<Array<FormInputParentConnectInput>>;
  /** Create and connect multiple FormInputParent documents */
  create?: InputMaybe<Array<FormInputParentCreateInput>>;
  /** Delete multiple FormInputParent documents */
  delete?: InputMaybe<Array<FormInputParentWhereUniqueInput>>;
  /** Disconnect multiple FormInputParent documents */
  disconnect?: InputMaybe<Array<FormInputParentWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing FormInputParent documents */
  set?: InputMaybe<Array<FormInputParentWhereUniqueInput>>;
  /** Update multiple FormInputParent documents */
  update?: InputMaybe<Array<FormInputParentUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple FormInputParent documents */
  upsert?: InputMaybe<Array<FormInputParentUpsertWithNestedWhereUniqueInput>>;
};

export type FormInputParentUpdateManyWithNestedWhereInput = {
  Container?: InputMaybe<ContainerUpdateManyWithNestedWhereInput>;
  Form?: InputMaybe<FormUpdateManyWithNestedWhereInput>;
};

export type FormInputParentUpdateOneInlineInput = {
  /** Connect existing FormInputParent document */
  connect?: InputMaybe<FormInputParentWhereUniqueInput>;
  /** Create and connect one FormInputParent document */
  create?: InputMaybe<FormInputParentCreateInput>;
  /** Delete currently connected FormInputParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected FormInputParent document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single FormInputParent document */
  update?: InputMaybe<FormInputParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single FormInputParent document */
  upsert?: InputMaybe<FormInputParentUpsertWithNestedWhereUniqueInput>;
};

export type FormInputParentUpdateWithNestedWhereUniqueInput = {
  Container?: InputMaybe<ContainerUpdateWithNestedWhereUniqueInput>;
  Form?: InputMaybe<FormUpdateWithNestedWhereUniqueInput>;
};

export type FormInputParentUpsertWithNestedWhereUniqueInput = {
  Container?: InputMaybe<ContainerUpsertWithNestedWhereUniqueInput>;
  Form?: InputMaybe<FormUpsertWithNestedWhereUniqueInput>;
};

export type FormInputParentWhereInput = {
  Container?: InputMaybe<ContainerWhereInput>;
  Form?: InputMaybe<FormWhereInput>;
};

export type FormInputParentWhereUniqueInput = {
  Container?: InputMaybe<ContainerWhereUniqueInput>;
  Form?: InputMaybe<FormWhereUniqueInput>;
};

export type FormInputUpdateInput = {
  /** label input for default locale (en) */
  label?: InputMaybe<Scalars['String']>;
  /** Manage document localizations */
  localizations?: InputMaybe<FormInputUpdateLocalizationsInput>;
  /** name input for default locale (en) */
  name?: InputMaybe<Scalars['String']>;
  /** placeholder input for default locale (en) */
  placeholder?: InputMaybe<Scalars['String']>;
  required?: InputMaybe<Scalars['Boolean']>;
  type?: InputMaybe<InputType>;
};

export type FormInputUpdateLocalizationDataInput = {
  label?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  placeholder?: InputMaybe<Scalars['String']>;
};

export type FormInputUpdateLocalizationInput = {
  data: FormInputUpdateLocalizationDataInput;
  locale: Locale;
};

export type FormInputUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<FormInputCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<FormInputUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<FormInputUpsertLocalizationInput>>;
};

export type FormInputUpdateManyInlineInput = {
  /** Create and connect multiple FormInput component instances */
  create?: InputMaybe<Array<FormInputCreateWithPositionInput>>;
  /** Delete multiple FormInput documents */
  delete?: InputMaybe<Array<FormInputWhereUniqueInput>>;
  /** Update multiple FormInput component instances */
  update?: InputMaybe<Array<FormInputUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple FormInput component instances */
  upsert?: InputMaybe<Array<FormInputUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type FormInputUpdateManyInput = {
  /** label input for default locale (en) */
  label?: InputMaybe<Scalars['String']>;
  /** Optional updates to localizations */
  localizations?: InputMaybe<FormInputUpdateManyLocalizationsInput>;
  /** name input for default locale (en) */
  name?: InputMaybe<Scalars['String']>;
  /** placeholder input for default locale (en) */
  placeholder?: InputMaybe<Scalars['String']>;
  required?: InputMaybe<Scalars['Boolean']>;
  type?: InputMaybe<InputType>;
};

export type FormInputUpdateManyLocalizationDataInput = {
  label?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  placeholder?: InputMaybe<Scalars['String']>;
};

export type FormInputUpdateManyLocalizationInput = {
  data: FormInputUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type FormInputUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<FormInputUpdateManyLocalizationInput>>;
};

export type FormInputUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: FormInputUpdateManyInput;
  /** Document search */
  where: FormInputWhereInput;
};

export type FormInputUpdateOneInlineInput = {
  /** Create and connect one FormInput document */
  create?: InputMaybe<FormInputCreateInput>;
  /** Delete currently connected FormInput document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single FormInput document */
  update?: InputMaybe<FormInputUpdateWithNestedWhereUniqueInput>;
  /** Upsert single FormInput document */
  upsert?: InputMaybe<FormInputUpsertWithNestedWhereUniqueInput>;
};

export type FormInputUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<FormInputUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: FormInputWhereUniqueInput;
};

export type FormInputUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: FormInputUpdateInput;
  /** Unique document search */
  where: FormInputWhereUniqueInput;
};

export type FormInputUpsertInput = {
  /** Create document if it didn't exist */
  create: FormInputCreateInput;
  /** Update document if it exists */
  update: FormInputUpdateInput;
};

export type FormInputUpsertLocalizationInput = {
  create: FormInputCreateLocalizationDataInput;
  locale: Locale;
  update: FormInputUpdateLocalizationDataInput;
};

export type FormInputUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<FormInputUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: FormInputWhereUniqueInput;
};

export type FormInputUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: FormInputUpsertInput;
  /** Unique document search */
  where: FormInputWhereUniqueInput;
};

/** Identifies documents */
export type FormInputWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<FormInputWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<FormInputWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<FormInputWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  label?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  label_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  label_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  label_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  label_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  label_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  label_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  label_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  label_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  label_starts_with?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  name_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  name_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  name_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  name_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  name_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  name_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  name_starts_with?: InputMaybe<Scalars['String']>;
  placeholder?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  placeholder_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  placeholder_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  placeholder_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  placeholder_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  placeholder_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  placeholder_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  placeholder_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  placeholder_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  placeholder_starts_with?: InputMaybe<Scalars['String']>;
  required?: InputMaybe<Scalars['Boolean']>;
  /** All values that are not equal to given value. */
  required_not?: InputMaybe<Scalars['Boolean']>;
  type?: InputMaybe<InputType>;
  /** All values that are contained in given list. */
  type_in?: InputMaybe<Array<InputMaybe<InputType>>>;
  /** All values that are not equal to given value. */
  type_not?: InputMaybe<InputType>;
  /** All values that are not contained in given list. */
  type_not_in?: InputMaybe<Array<InputMaybe<InputType>>>;
};

/** References FormInput record uniquely */
export type FormInputWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

/** Identifies documents */
export type FormManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<FormWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<FormWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<FormWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  container?: InputMaybe<ContainerWhereInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  pages_every?: InputMaybe<PageWhereInput>;
  pages_none?: InputMaybe<PageWhereInput>;
  pages_some?: InputMaybe<PageWhereInput>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

export enum FormOrderByInput {
  CreatedAtAsc = 'createdAt_ASC',
  CreatedAtDesc = 'createdAt_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  PublishedAtAsc = 'publishedAt_ASC',
  PublishedAtDesc = 'publishedAt_DESC',
  UpdatedAtAsc = 'updatedAt_ASC',
  UpdatedAtDesc = 'updatedAt_DESC'
}

export type FormRadio = {
  __typename?: 'FormRadio';
  /** The unique identifier */
  id: Scalars['ID'];
  label: Scalars['String'];
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<FormRadio>;
  name: Scalars['String'];
  placeholder?: Maybe<Scalars['String']>;
  required: Scalars['Boolean'];
  /** System stage field */
  stage: Stage;
  values?: Maybe<Scalars['String']>;
};


export type FormRadioLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};

export type FormRadioConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: FormRadioWhereUniqueInput;
};

/** A connection to a list of items. */
export type FormRadioConnection = {
  __typename?: 'FormRadioConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<FormRadioEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type FormRadioCreateInput = {
  /** label input for default locale (en) */
  label: Scalars['String'];
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<FormRadioCreateLocalizationsInput>;
  /** name input for default locale (en) */
  name: Scalars['String'];
  /** placeholder input for default locale (en) */
  placeholder?: InputMaybe<Scalars['String']>;
  required: Scalars['Boolean'];
  /** values input for default locale (en) */
  values?: InputMaybe<Scalars['String']>;
};

export type FormRadioCreateLocalizationDataInput = {
  label: Scalars['String'];
  name: Scalars['String'];
  placeholder?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Scalars['String']>;
};

export type FormRadioCreateLocalizationInput = {
  /** Localization input */
  data: FormRadioCreateLocalizationDataInput;
  locale: Locale;
};

export type FormRadioCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<FormRadioCreateLocalizationInput>>;
};

export type FormRadioCreateManyInlineInput = {
  /** Create and connect multiple existing FormRadio documents */
  create?: InputMaybe<Array<FormRadioCreateInput>>;
};

export type FormRadioCreateOneInlineInput = {
  /** Create and connect one FormRadio document */
  create?: InputMaybe<FormRadioCreateInput>;
};

export type FormRadioCreateWithPositionInput = {
  /** Document to create */
  data: FormRadioCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type FormRadioEdge = {
  __typename?: 'FormRadioEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: FormRadio;
};

/** Identifies documents */
export type FormRadioManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<FormRadioWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<FormRadioWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<FormRadioWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  required?: InputMaybe<Scalars['Boolean']>;
  /** All values that are not equal to given value. */
  required_not?: InputMaybe<Scalars['Boolean']>;
};

export enum FormRadioOrderByInput {
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  LabelAsc = 'label_ASC',
  LabelDesc = 'label_DESC',
  NameAsc = 'name_ASC',
  NameDesc = 'name_DESC',
  PlaceholderAsc = 'placeholder_ASC',
  PlaceholderDesc = 'placeholder_DESC',
  RequiredAsc = 'required_ASC',
  RequiredDesc = 'required_DESC',
  ValuesAsc = 'values_ASC',
  ValuesDesc = 'values_DESC'
}

export type FormRadioParent = Container | Form;

export type FormRadioParentConnectInput = {
  Container?: InputMaybe<ContainerConnectInput>;
  Form?: InputMaybe<FormConnectInput>;
};

export type FormRadioParentCreateInput = {
  Container?: InputMaybe<ContainerCreateInput>;
  Form?: InputMaybe<FormCreateInput>;
};

export type FormRadioParentCreateManyInlineInput = {
  /** Connect multiple existing FormRadioParent documents */
  connect?: InputMaybe<Array<FormRadioParentWhereUniqueInput>>;
  /** Create and connect multiple existing FormRadioParent documents */
  create?: InputMaybe<Array<FormRadioParentCreateInput>>;
};

export type FormRadioParentCreateOneInlineInput = {
  /** Connect one existing FormRadioParent document */
  connect?: InputMaybe<FormRadioParentWhereUniqueInput>;
  /** Create and connect one FormRadioParent document */
  create?: InputMaybe<FormRadioParentCreateInput>;
};

export type FormRadioParentUpdateInput = {
  Container?: InputMaybe<ContainerUpdateInput>;
  Form?: InputMaybe<FormUpdateInput>;
};

export type FormRadioParentUpdateManyInlineInput = {
  /** Connect multiple existing FormRadioParent documents */
  connect?: InputMaybe<Array<FormRadioParentConnectInput>>;
  /** Create and connect multiple FormRadioParent documents */
  create?: InputMaybe<Array<FormRadioParentCreateInput>>;
  /** Delete multiple FormRadioParent documents */
  delete?: InputMaybe<Array<FormRadioParentWhereUniqueInput>>;
  /** Disconnect multiple FormRadioParent documents */
  disconnect?: InputMaybe<Array<FormRadioParentWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing FormRadioParent documents */
  set?: InputMaybe<Array<FormRadioParentWhereUniqueInput>>;
  /** Update multiple FormRadioParent documents */
  update?: InputMaybe<Array<FormRadioParentUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple FormRadioParent documents */
  upsert?: InputMaybe<Array<FormRadioParentUpsertWithNestedWhereUniqueInput>>;
};

export type FormRadioParentUpdateManyWithNestedWhereInput = {
  Container?: InputMaybe<ContainerUpdateManyWithNestedWhereInput>;
  Form?: InputMaybe<FormUpdateManyWithNestedWhereInput>;
};

export type FormRadioParentUpdateOneInlineInput = {
  /** Connect existing FormRadioParent document */
  connect?: InputMaybe<FormRadioParentWhereUniqueInput>;
  /** Create and connect one FormRadioParent document */
  create?: InputMaybe<FormRadioParentCreateInput>;
  /** Delete currently connected FormRadioParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected FormRadioParent document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single FormRadioParent document */
  update?: InputMaybe<FormRadioParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single FormRadioParent document */
  upsert?: InputMaybe<FormRadioParentUpsertWithNestedWhereUniqueInput>;
};

export type FormRadioParentUpdateWithNestedWhereUniqueInput = {
  Container?: InputMaybe<ContainerUpdateWithNestedWhereUniqueInput>;
  Form?: InputMaybe<FormUpdateWithNestedWhereUniqueInput>;
};

export type FormRadioParentUpsertWithNestedWhereUniqueInput = {
  Container?: InputMaybe<ContainerUpsertWithNestedWhereUniqueInput>;
  Form?: InputMaybe<FormUpsertWithNestedWhereUniqueInput>;
};

export type FormRadioParentWhereInput = {
  Container?: InputMaybe<ContainerWhereInput>;
  Form?: InputMaybe<FormWhereInput>;
};

export type FormRadioParentWhereUniqueInput = {
  Container?: InputMaybe<ContainerWhereUniqueInput>;
  Form?: InputMaybe<FormWhereUniqueInput>;
};

export type FormRadioUpdateInput = {
  /** label input for default locale (en) */
  label?: InputMaybe<Scalars['String']>;
  /** Manage document localizations */
  localizations?: InputMaybe<FormRadioUpdateLocalizationsInput>;
  /** name input for default locale (en) */
  name?: InputMaybe<Scalars['String']>;
  /** placeholder input for default locale (en) */
  placeholder?: InputMaybe<Scalars['String']>;
  required?: InputMaybe<Scalars['Boolean']>;
  /** values input for default locale (en) */
  values?: InputMaybe<Scalars['String']>;
};

export type FormRadioUpdateLocalizationDataInput = {
  label?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  placeholder?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Scalars['String']>;
};

export type FormRadioUpdateLocalizationInput = {
  data: FormRadioUpdateLocalizationDataInput;
  locale: Locale;
};

export type FormRadioUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<FormRadioCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<FormRadioUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<FormRadioUpsertLocalizationInput>>;
};

export type FormRadioUpdateManyInlineInput = {
  /** Create and connect multiple FormRadio component instances */
  create?: InputMaybe<Array<FormRadioCreateWithPositionInput>>;
  /** Delete multiple FormRadio documents */
  delete?: InputMaybe<Array<FormRadioWhereUniqueInput>>;
  /** Update multiple FormRadio component instances */
  update?: InputMaybe<Array<FormRadioUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple FormRadio component instances */
  upsert?: InputMaybe<Array<FormRadioUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type FormRadioUpdateManyInput = {
  /** label input for default locale (en) */
  label?: InputMaybe<Scalars['String']>;
  /** Optional updates to localizations */
  localizations?: InputMaybe<FormRadioUpdateManyLocalizationsInput>;
  /** name input for default locale (en) */
  name?: InputMaybe<Scalars['String']>;
  /** placeholder input for default locale (en) */
  placeholder?: InputMaybe<Scalars['String']>;
  required?: InputMaybe<Scalars['Boolean']>;
  /** values input for default locale (en) */
  values?: InputMaybe<Scalars['String']>;
};

export type FormRadioUpdateManyLocalizationDataInput = {
  label?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  placeholder?: InputMaybe<Scalars['String']>;
  values?: InputMaybe<Scalars['String']>;
};

export type FormRadioUpdateManyLocalizationInput = {
  data: FormRadioUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type FormRadioUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<FormRadioUpdateManyLocalizationInput>>;
};

export type FormRadioUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: FormRadioUpdateManyInput;
  /** Document search */
  where: FormRadioWhereInput;
};

export type FormRadioUpdateOneInlineInput = {
  /** Create and connect one FormRadio document */
  create?: InputMaybe<FormRadioCreateInput>;
  /** Delete currently connected FormRadio document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single FormRadio document */
  update?: InputMaybe<FormRadioUpdateWithNestedWhereUniqueInput>;
  /** Upsert single FormRadio document */
  upsert?: InputMaybe<FormRadioUpsertWithNestedWhereUniqueInput>;
};

export type FormRadioUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<FormRadioUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: FormRadioWhereUniqueInput;
};

export type FormRadioUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: FormRadioUpdateInput;
  /** Unique document search */
  where: FormRadioWhereUniqueInput;
};

export type FormRadioUpsertInput = {
  /** Create document if it didn't exist */
  create: FormRadioCreateInput;
  /** Update document if it exists */
  update: FormRadioUpdateInput;
};

export type FormRadioUpsertLocalizationInput = {
  create: FormRadioCreateLocalizationDataInput;
  locale: Locale;
  update: FormRadioUpdateLocalizationDataInput;
};

export type FormRadioUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<FormRadioUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: FormRadioWhereUniqueInput;
};

export type FormRadioUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: FormRadioUpsertInput;
  /** Unique document search */
  where: FormRadioWhereUniqueInput;
};

/** Identifies documents */
export type FormRadioWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<FormRadioWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<FormRadioWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<FormRadioWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  label?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  label_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  label_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  label_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  label_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  label_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  label_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  label_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  label_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  label_starts_with?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  name_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  name_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  name_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  name_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  name_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  name_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  name_starts_with?: InputMaybe<Scalars['String']>;
  placeholder?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  placeholder_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  placeholder_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  placeholder_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  placeholder_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  placeholder_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  placeholder_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  placeholder_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  placeholder_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  placeholder_starts_with?: InputMaybe<Scalars['String']>;
  required?: InputMaybe<Scalars['Boolean']>;
  /** All values that are not equal to given value. */
  required_not?: InputMaybe<Scalars['Boolean']>;
  values?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  values_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  values_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  values_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  values_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  values_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  values_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  values_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  values_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  values_starts_with?: InputMaybe<Scalars['String']>;
};

/** References FormRadio record uniquely */
export type FormRadioWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export type FormTextarea = {
  __typename?: 'FormTextarea';
  /** The unique identifier */
  id: Scalars['ID'];
  label: Scalars['String'];
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<FormTextarea>;
  name: Scalars['String'];
  placeholder?: Maybe<Scalars['String']>;
  required: Scalars['Boolean'];
  /** System stage field */
  stage: Stage;
};


export type FormTextareaLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};

export type FormTextareaConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: FormTextareaWhereUniqueInput;
};

/** A connection to a list of items. */
export type FormTextareaConnection = {
  __typename?: 'FormTextareaConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<FormTextareaEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type FormTextareaCreateInput = {
  /** label input for default locale (en) */
  label: Scalars['String'];
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<FormTextareaCreateLocalizationsInput>;
  name: Scalars['String'];
  /** placeholder input for default locale (en) */
  placeholder?: InputMaybe<Scalars['String']>;
  required: Scalars['Boolean'];
};

export type FormTextareaCreateLocalizationDataInput = {
  label: Scalars['String'];
  placeholder?: InputMaybe<Scalars['String']>;
};

export type FormTextareaCreateLocalizationInput = {
  /** Localization input */
  data: FormTextareaCreateLocalizationDataInput;
  locale: Locale;
};

export type FormTextareaCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<FormTextareaCreateLocalizationInput>>;
};

export type FormTextareaCreateManyInlineInput = {
  /** Create and connect multiple existing FormTextarea documents */
  create?: InputMaybe<Array<FormTextareaCreateInput>>;
};

export type FormTextareaCreateOneInlineInput = {
  /** Create and connect one FormTextarea document */
  create?: InputMaybe<FormTextareaCreateInput>;
};

export type FormTextareaCreateWithPositionInput = {
  /** Document to create */
  data: FormTextareaCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type FormTextareaEdge = {
  __typename?: 'FormTextareaEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: FormTextarea;
};

/** Identifies documents */
export type FormTextareaManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<FormTextareaWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<FormTextareaWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<FormTextareaWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  name?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  name_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  name_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  name_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  name_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  name_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  name_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  name_starts_with?: InputMaybe<Scalars['String']>;
  required?: InputMaybe<Scalars['Boolean']>;
  /** All values that are not equal to given value. */
  required_not?: InputMaybe<Scalars['Boolean']>;
};

export enum FormTextareaOrderByInput {
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  LabelAsc = 'label_ASC',
  LabelDesc = 'label_DESC',
  NameAsc = 'name_ASC',
  NameDesc = 'name_DESC',
  PlaceholderAsc = 'placeholder_ASC',
  PlaceholderDesc = 'placeholder_DESC',
  RequiredAsc = 'required_ASC',
  RequiredDesc = 'required_DESC'
}

export type FormTextareaParent = Container | Form;

export type FormTextareaParentConnectInput = {
  Container?: InputMaybe<ContainerConnectInput>;
  Form?: InputMaybe<FormConnectInput>;
};

export type FormTextareaParentCreateInput = {
  Container?: InputMaybe<ContainerCreateInput>;
  Form?: InputMaybe<FormCreateInput>;
};

export type FormTextareaParentCreateManyInlineInput = {
  /** Connect multiple existing FormTextareaParent documents */
  connect?: InputMaybe<Array<FormTextareaParentWhereUniqueInput>>;
  /** Create and connect multiple existing FormTextareaParent documents */
  create?: InputMaybe<Array<FormTextareaParentCreateInput>>;
};

export type FormTextareaParentCreateOneInlineInput = {
  /** Connect one existing FormTextareaParent document */
  connect?: InputMaybe<FormTextareaParentWhereUniqueInput>;
  /** Create and connect one FormTextareaParent document */
  create?: InputMaybe<FormTextareaParentCreateInput>;
};

export type FormTextareaParentUpdateInput = {
  Container?: InputMaybe<ContainerUpdateInput>;
  Form?: InputMaybe<FormUpdateInput>;
};

export type FormTextareaParentUpdateManyInlineInput = {
  /** Connect multiple existing FormTextareaParent documents */
  connect?: InputMaybe<Array<FormTextareaParentConnectInput>>;
  /** Create and connect multiple FormTextareaParent documents */
  create?: InputMaybe<Array<FormTextareaParentCreateInput>>;
  /** Delete multiple FormTextareaParent documents */
  delete?: InputMaybe<Array<FormTextareaParentWhereUniqueInput>>;
  /** Disconnect multiple FormTextareaParent documents */
  disconnect?: InputMaybe<Array<FormTextareaParentWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing FormTextareaParent documents */
  set?: InputMaybe<Array<FormTextareaParentWhereUniqueInput>>;
  /** Update multiple FormTextareaParent documents */
  update?: InputMaybe<Array<FormTextareaParentUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple FormTextareaParent documents */
  upsert?: InputMaybe<Array<FormTextareaParentUpsertWithNestedWhereUniqueInput>>;
};

export type FormTextareaParentUpdateManyWithNestedWhereInput = {
  Container?: InputMaybe<ContainerUpdateManyWithNestedWhereInput>;
  Form?: InputMaybe<FormUpdateManyWithNestedWhereInput>;
};

export type FormTextareaParentUpdateOneInlineInput = {
  /** Connect existing FormTextareaParent document */
  connect?: InputMaybe<FormTextareaParentWhereUniqueInput>;
  /** Create and connect one FormTextareaParent document */
  create?: InputMaybe<FormTextareaParentCreateInput>;
  /** Delete currently connected FormTextareaParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected FormTextareaParent document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single FormTextareaParent document */
  update?: InputMaybe<FormTextareaParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single FormTextareaParent document */
  upsert?: InputMaybe<FormTextareaParentUpsertWithNestedWhereUniqueInput>;
};

export type FormTextareaParentUpdateWithNestedWhereUniqueInput = {
  Container?: InputMaybe<ContainerUpdateWithNestedWhereUniqueInput>;
  Form?: InputMaybe<FormUpdateWithNestedWhereUniqueInput>;
};

export type FormTextareaParentUpsertWithNestedWhereUniqueInput = {
  Container?: InputMaybe<ContainerUpsertWithNestedWhereUniqueInput>;
  Form?: InputMaybe<FormUpsertWithNestedWhereUniqueInput>;
};

export type FormTextareaParentWhereInput = {
  Container?: InputMaybe<ContainerWhereInput>;
  Form?: InputMaybe<FormWhereInput>;
};

export type FormTextareaParentWhereUniqueInput = {
  Container?: InputMaybe<ContainerWhereUniqueInput>;
  Form?: InputMaybe<FormWhereUniqueInput>;
};

export type FormTextareaUpdateInput = {
  /** label input for default locale (en) */
  label?: InputMaybe<Scalars['String']>;
  /** Manage document localizations */
  localizations?: InputMaybe<FormTextareaUpdateLocalizationsInput>;
  name?: InputMaybe<Scalars['String']>;
  /** placeholder input for default locale (en) */
  placeholder?: InputMaybe<Scalars['String']>;
  required?: InputMaybe<Scalars['Boolean']>;
};

export type FormTextareaUpdateLocalizationDataInput = {
  label?: InputMaybe<Scalars['String']>;
  placeholder?: InputMaybe<Scalars['String']>;
};

export type FormTextareaUpdateLocalizationInput = {
  data: FormTextareaUpdateLocalizationDataInput;
  locale: Locale;
};

export type FormTextareaUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<FormTextareaCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<FormTextareaUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<FormTextareaUpsertLocalizationInput>>;
};

export type FormTextareaUpdateManyInlineInput = {
  /** Create and connect multiple FormTextarea component instances */
  create?: InputMaybe<Array<FormTextareaCreateWithPositionInput>>;
  /** Delete multiple FormTextarea documents */
  delete?: InputMaybe<Array<FormTextareaWhereUniqueInput>>;
  /** Update multiple FormTextarea component instances */
  update?: InputMaybe<Array<FormTextareaUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple FormTextarea component instances */
  upsert?: InputMaybe<Array<FormTextareaUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type FormTextareaUpdateManyInput = {
  /** label input for default locale (en) */
  label?: InputMaybe<Scalars['String']>;
  /** Optional updates to localizations */
  localizations?: InputMaybe<FormTextareaUpdateManyLocalizationsInput>;
  name?: InputMaybe<Scalars['String']>;
  /** placeholder input for default locale (en) */
  placeholder?: InputMaybe<Scalars['String']>;
  required?: InputMaybe<Scalars['Boolean']>;
};

export type FormTextareaUpdateManyLocalizationDataInput = {
  label?: InputMaybe<Scalars['String']>;
  placeholder?: InputMaybe<Scalars['String']>;
};

export type FormTextareaUpdateManyLocalizationInput = {
  data: FormTextareaUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type FormTextareaUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<FormTextareaUpdateManyLocalizationInput>>;
};

export type FormTextareaUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: FormTextareaUpdateManyInput;
  /** Document search */
  where: FormTextareaWhereInput;
};

export type FormTextareaUpdateOneInlineInput = {
  /** Create and connect one FormTextarea document */
  create?: InputMaybe<FormTextareaCreateInput>;
  /** Delete currently connected FormTextarea document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single FormTextarea document */
  update?: InputMaybe<FormTextareaUpdateWithNestedWhereUniqueInput>;
  /** Upsert single FormTextarea document */
  upsert?: InputMaybe<FormTextareaUpsertWithNestedWhereUniqueInput>;
};

export type FormTextareaUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<FormTextareaUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: FormTextareaWhereUniqueInput;
};

export type FormTextareaUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: FormTextareaUpdateInput;
  /** Unique document search */
  where: FormTextareaWhereUniqueInput;
};

export type FormTextareaUpsertInput = {
  /** Create document if it didn't exist */
  create: FormTextareaCreateInput;
  /** Update document if it exists */
  update: FormTextareaUpdateInput;
};

export type FormTextareaUpsertLocalizationInput = {
  create: FormTextareaCreateLocalizationDataInput;
  locale: Locale;
  update: FormTextareaUpdateLocalizationDataInput;
};

export type FormTextareaUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<FormTextareaUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: FormTextareaWhereUniqueInput;
};

export type FormTextareaUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: FormTextareaUpsertInput;
  /** Unique document search */
  where: FormTextareaWhereUniqueInput;
};

/** Identifies documents */
export type FormTextareaWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<FormTextareaWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<FormTextareaWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<FormTextareaWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  label?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  label_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  label_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  label_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  label_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  label_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  label_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  label_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  label_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  label_starts_with?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  name_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  name_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  name_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  name_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  name_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  name_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  name_starts_with?: InputMaybe<Scalars['String']>;
  placeholder?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  placeholder_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  placeholder_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  placeholder_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  placeholder_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  placeholder_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  placeholder_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  placeholder_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  placeholder_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  placeholder_starts_with?: InputMaybe<Scalars['String']>;
  required?: InputMaybe<Scalars['Boolean']>;
  /** All values that are not equal to given value. */
  required_not?: InputMaybe<Scalars['Boolean']>;
};

/** References FormTextarea record uniquely */
export type FormTextareaWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export type FormUpdateInput = {
  container?: InputMaybe<ContainerUpdateOneInlineInput>;
  fields?: InputMaybe<FormfieldsUnionUpdateOneInlineInput>;
  /** Manage document localizations */
  localizations?: InputMaybe<FormUpdateLocalizationsInput>;
  pages?: InputMaybe<PageUpdateManyInlineInput>;
};

export type FormUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<FormCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
};

export type FormUpdateManyInlineInput = {
  /** Connect multiple existing Form documents */
  connect?: InputMaybe<Array<FormConnectInput>>;
  /** Create and connect multiple Form documents */
  create?: InputMaybe<Array<FormCreateInput>>;
  /** Delete multiple Form documents */
  delete?: InputMaybe<Array<FormWhereUniqueInput>>;
  /** Disconnect multiple Form documents */
  disconnect?: InputMaybe<Array<FormWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing Form documents */
  set?: InputMaybe<Array<FormWhereUniqueInput>>;
  /** Update multiple Form documents */
  update?: InputMaybe<Array<FormUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple Form documents */
  upsert?: InputMaybe<Array<FormUpsertWithNestedWhereUniqueInput>>;
};

export type FormUpdateManyInput = {
  /** No fields in updateMany data input */
  _?: InputMaybe<Scalars['String']>;
};

export type FormUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: FormUpdateManyInput;
  /** Document search */
  where: FormWhereInput;
};

export type FormUpdateOneInlineInput = {
  /** Connect existing Form document */
  connect?: InputMaybe<FormWhereUniqueInput>;
  /** Create and connect one Form document */
  create?: InputMaybe<FormCreateInput>;
  /** Delete currently connected Form document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected Form document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single Form document */
  update?: InputMaybe<FormUpdateWithNestedWhereUniqueInput>;
  /** Upsert single Form document */
  upsert?: InputMaybe<FormUpsertWithNestedWhereUniqueInput>;
};

export type FormUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: FormUpdateInput;
  /** Unique document search */
  where: FormWhereUniqueInput;
};

export type FormUpsertInput = {
  /** Create document if it didn't exist */
  create: FormCreateInput;
  /** Update document if it exists */
  update: FormUpdateInput;
};

export type FormUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: FormUpsertInput;
  /** Unique document search */
  where: FormWhereUniqueInput;
};

/** Identifies documents */
export type FormWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<FormWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<FormWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<FormWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  container?: InputMaybe<ContainerWhereInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  pages_every?: InputMaybe<PageWhereInput>;
  pages_none?: InputMaybe<PageWhereInput>;
  pages_some?: InputMaybe<PageWhereInput>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

/** References Form record uniquely */
export type FormWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export type FormfieldsUnion = FormCheckbox | FormInput | FormRadio | FormTextarea | FromSelect;

export type FormfieldsUnionConnectInput = {
  FormCheckbox?: InputMaybe<FormCheckboxConnectInput>;
  FormInput?: InputMaybe<FormInputConnectInput>;
  FormRadio?: InputMaybe<FormRadioConnectInput>;
  FormTextarea?: InputMaybe<FormTextareaConnectInput>;
  FromSelect?: InputMaybe<FromSelectConnectInput>;
};

export type FormfieldsUnionCreateInput = {
  FormCheckbox?: InputMaybe<FormCheckboxCreateInput>;
  FormInput?: InputMaybe<FormInputCreateInput>;
  FormRadio?: InputMaybe<FormRadioCreateInput>;
  FormTextarea?: InputMaybe<FormTextareaCreateInput>;
  FromSelect?: InputMaybe<FromSelectCreateInput>;
};

export type FormfieldsUnionCreateManyInlineInput = {
  /** Create and connect multiple existing FormfieldsUnion documents */
  create?: InputMaybe<Array<FormfieldsUnionCreateInput>>;
};

export type FormfieldsUnionCreateOneInlineInput = {
  /** Create and connect one FormfieldsUnion document */
  create?: InputMaybe<FormfieldsUnionCreateInput>;
};

export type FormfieldsUnionCreateWithPositionInput = {
  FormCheckbox?: InputMaybe<FormCheckboxCreateWithPositionInput>;
  FormInput?: InputMaybe<FormInputCreateWithPositionInput>;
  FormRadio?: InputMaybe<FormRadioCreateWithPositionInput>;
  FormTextarea?: InputMaybe<FormTextareaCreateWithPositionInput>;
  FromSelect?: InputMaybe<FromSelectCreateWithPositionInput>;
};

export type FormfieldsUnionUpdateInput = {
  FormCheckbox?: InputMaybe<FormCheckboxUpdateInput>;
  FormInput?: InputMaybe<FormInputUpdateInput>;
  FormRadio?: InputMaybe<FormRadioUpdateInput>;
  FormTextarea?: InputMaybe<FormTextareaUpdateInput>;
  FromSelect?: InputMaybe<FromSelectUpdateInput>;
};

export type FormfieldsUnionUpdateManyInlineInput = {
  /** Create and connect multiple FormfieldsUnion component instances */
  create?: InputMaybe<Array<FormfieldsUnionCreateWithPositionInput>>;
  /** Delete multiple FormfieldsUnion documents */
  delete?: InputMaybe<Array<FormfieldsUnionWhereUniqueInput>>;
  /** Update multiple FormfieldsUnion component instances */
  update?: InputMaybe<Array<FormfieldsUnionUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple FormfieldsUnion component instances */
  upsert?: InputMaybe<Array<FormfieldsUnionUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type FormfieldsUnionUpdateManyWithNestedWhereInput = {
  FormCheckbox?: InputMaybe<FormCheckboxUpdateManyWithNestedWhereInput>;
  FormInput?: InputMaybe<FormInputUpdateManyWithNestedWhereInput>;
  FormRadio?: InputMaybe<FormRadioUpdateManyWithNestedWhereInput>;
  FormTextarea?: InputMaybe<FormTextareaUpdateManyWithNestedWhereInput>;
  FromSelect?: InputMaybe<FromSelectUpdateManyWithNestedWhereInput>;
};

export type FormfieldsUnionUpdateOneInlineInput = {
  /** Create and connect one FormfieldsUnion document */
  create?: InputMaybe<FormfieldsUnionCreateInput>;
  /** Delete currently connected FormfieldsUnion document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single FormfieldsUnion document */
  update?: InputMaybe<FormfieldsUnionUpdateWithNestedWhereUniqueInput>;
  /** Upsert single FormfieldsUnion document */
  upsert?: InputMaybe<FormfieldsUnionUpsertWithNestedWhereUniqueInput>;
};

export type FormfieldsUnionUpdateWithNestedWhereUniqueAndPositionInput = {
  FormCheckbox?: InputMaybe<FormCheckboxUpdateWithNestedWhereUniqueAndPositionInput>;
  FormInput?: InputMaybe<FormInputUpdateWithNestedWhereUniqueAndPositionInput>;
  FormRadio?: InputMaybe<FormRadioUpdateWithNestedWhereUniqueAndPositionInput>;
  FormTextarea?: InputMaybe<FormTextareaUpdateWithNestedWhereUniqueAndPositionInput>;
  FromSelect?: InputMaybe<FromSelectUpdateWithNestedWhereUniqueAndPositionInput>;
};

export type FormfieldsUnionUpdateWithNestedWhereUniqueInput = {
  FormCheckbox?: InputMaybe<FormCheckboxUpdateWithNestedWhereUniqueInput>;
  FormInput?: InputMaybe<FormInputUpdateWithNestedWhereUniqueInput>;
  FormRadio?: InputMaybe<FormRadioUpdateWithNestedWhereUniqueInput>;
  FormTextarea?: InputMaybe<FormTextareaUpdateWithNestedWhereUniqueInput>;
  FromSelect?: InputMaybe<FromSelectUpdateWithNestedWhereUniqueInput>;
};

export type FormfieldsUnionUpsertWithNestedWhereUniqueAndPositionInput = {
  FormCheckbox?: InputMaybe<FormCheckboxUpsertWithNestedWhereUniqueAndPositionInput>;
  FormInput?: InputMaybe<FormInputUpsertWithNestedWhereUniqueAndPositionInput>;
  FormRadio?: InputMaybe<FormRadioUpsertWithNestedWhereUniqueAndPositionInput>;
  FormTextarea?: InputMaybe<FormTextareaUpsertWithNestedWhereUniqueAndPositionInput>;
  FromSelect?: InputMaybe<FromSelectUpsertWithNestedWhereUniqueAndPositionInput>;
};

export type FormfieldsUnionUpsertWithNestedWhereUniqueInput = {
  FormCheckbox?: InputMaybe<FormCheckboxUpsertWithNestedWhereUniqueInput>;
  FormInput?: InputMaybe<FormInputUpsertWithNestedWhereUniqueInput>;
  FormRadio?: InputMaybe<FormRadioUpsertWithNestedWhereUniqueInput>;
  FormTextarea?: InputMaybe<FormTextareaUpsertWithNestedWhereUniqueInput>;
  FromSelect?: InputMaybe<FromSelectUpsertWithNestedWhereUniqueInput>;
};

export type FormfieldsUnionWhereInput = {
  FormCheckbox?: InputMaybe<FormCheckboxWhereInput>;
  FormInput?: InputMaybe<FormInputWhereInput>;
  FormRadio?: InputMaybe<FormRadioWhereInput>;
  FormTextarea?: InputMaybe<FormTextareaWhereInput>;
  FromSelect?: InputMaybe<FromSelectWhereInput>;
};

export type FormfieldsUnionWhereUniqueInput = {
  FormCheckbox?: InputMaybe<FormCheckboxWhereUniqueInput>;
  FormInput?: InputMaybe<FormInputWhereUniqueInput>;
  FormRadio?: InputMaybe<FormRadioWhereUniqueInput>;
  FormTextarea?: InputMaybe<FormTextareaWhereUniqueInput>;
  FromSelect?: InputMaybe<FromSelectWhereUniqueInput>;
};

export type FromSelect = {
  __typename?: 'FromSelect';
  /** The unique identifier */
  id: Scalars['ID'];
  label: Scalars['String'];
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<FromSelect>;
  name: Scalars['String'];
  required: Scalars['Boolean'];
  /** System stage field */
  stage: Stage;
};


export type FromSelectLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};

export type FromSelectConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: FromSelectWhereUniqueInput;
};

/** A connection to a list of items. */
export type FromSelectConnection = {
  __typename?: 'FromSelectConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<FromSelectEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type FromSelectCreateInput = {
  /** label input for default locale (en) */
  label: Scalars['String'];
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<FromSelectCreateLocalizationsInput>;
  name: Scalars['String'];
  required: Scalars['Boolean'];
};

export type FromSelectCreateLocalizationDataInput = {
  label: Scalars['String'];
};

export type FromSelectCreateLocalizationInput = {
  /** Localization input */
  data: FromSelectCreateLocalizationDataInput;
  locale: Locale;
};

export type FromSelectCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<FromSelectCreateLocalizationInput>>;
};

export type FromSelectCreateManyInlineInput = {
  /** Create and connect multiple existing FromSelect documents */
  create?: InputMaybe<Array<FromSelectCreateInput>>;
};

export type FromSelectCreateOneInlineInput = {
  /** Create and connect one FromSelect document */
  create?: InputMaybe<FromSelectCreateInput>;
};

export type FromSelectCreateWithPositionInput = {
  /** Document to create */
  data: FromSelectCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type FromSelectEdge = {
  __typename?: 'FromSelectEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: FromSelect;
};

/** Identifies documents */
export type FromSelectManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<FromSelectWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<FromSelectWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<FromSelectWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  name?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  name_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  name_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  name_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  name_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  name_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  name_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  name_starts_with?: InputMaybe<Scalars['String']>;
  required?: InputMaybe<Scalars['Boolean']>;
  /** All values that are not equal to given value. */
  required_not?: InputMaybe<Scalars['Boolean']>;
};

export enum FromSelectOrderByInput {
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  LabelAsc = 'label_ASC',
  LabelDesc = 'label_DESC',
  NameAsc = 'name_ASC',
  NameDesc = 'name_DESC',
  RequiredAsc = 'required_ASC',
  RequiredDesc = 'required_DESC'
}

export type FromSelectParent = Container | Form;

export type FromSelectParentConnectInput = {
  Container?: InputMaybe<ContainerConnectInput>;
  Form?: InputMaybe<FormConnectInput>;
};

export type FromSelectParentCreateInput = {
  Container?: InputMaybe<ContainerCreateInput>;
  Form?: InputMaybe<FormCreateInput>;
};

export type FromSelectParentCreateManyInlineInput = {
  /** Connect multiple existing FromSelectParent documents */
  connect?: InputMaybe<Array<FromSelectParentWhereUniqueInput>>;
  /** Create and connect multiple existing FromSelectParent documents */
  create?: InputMaybe<Array<FromSelectParentCreateInput>>;
};

export type FromSelectParentCreateOneInlineInput = {
  /** Connect one existing FromSelectParent document */
  connect?: InputMaybe<FromSelectParentWhereUniqueInput>;
  /** Create and connect one FromSelectParent document */
  create?: InputMaybe<FromSelectParentCreateInput>;
};

export type FromSelectParentUpdateInput = {
  Container?: InputMaybe<ContainerUpdateInput>;
  Form?: InputMaybe<FormUpdateInput>;
};

export type FromSelectParentUpdateManyInlineInput = {
  /** Connect multiple existing FromSelectParent documents */
  connect?: InputMaybe<Array<FromSelectParentConnectInput>>;
  /** Create and connect multiple FromSelectParent documents */
  create?: InputMaybe<Array<FromSelectParentCreateInput>>;
  /** Delete multiple FromSelectParent documents */
  delete?: InputMaybe<Array<FromSelectParentWhereUniqueInput>>;
  /** Disconnect multiple FromSelectParent documents */
  disconnect?: InputMaybe<Array<FromSelectParentWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing FromSelectParent documents */
  set?: InputMaybe<Array<FromSelectParentWhereUniqueInput>>;
  /** Update multiple FromSelectParent documents */
  update?: InputMaybe<Array<FromSelectParentUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple FromSelectParent documents */
  upsert?: InputMaybe<Array<FromSelectParentUpsertWithNestedWhereUniqueInput>>;
};

export type FromSelectParentUpdateManyWithNestedWhereInput = {
  Container?: InputMaybe<ContainerUpdateManyWithNestedWhereInput>;
  Form?: InputMaybe<FormUpdateManyWithNestedWhereInput>;
};

export type FromSelectParentUpdateOneInlineInput = {
  /** Connect existing FromSelectParent document */
  connect?: InputMaybe<FromSelectParentWhereUniqueInput>;
  /** Create and connect one FromSelectParent document */
  create?: InputMaybe<FromSelectParentCreateInput>;
  /** Delete currently connected FromSelectParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected FromSelectParent document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single FromSelectParent document */
  update?: InputMaybe<FromSelectParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single FromSelectParent document */
  upsert?: InputMaybe<FromSelectParentUpsertWithNestedWhereUniqueInput>;
};

export type FromSelectParentUpdateWithNestedWhereUniqueInput = {
  Container?: InputMaybe<ContainerUpdateWithNestedWhereUniqueInput>;
  Form?: InputMaybe<FormUpdateWithNestedWhereUniqueInput>;
};

export type FromSelectParentUpsertWithNestedWhereUniqueInput = {
  Container?: InputMaybe<ContainerUpsertWithNestedWhereUniqueInput>;
  Form?: InputMaybe<FormUpsertWithNestedWhereUniqueInput>;
};

export type FromSelectParentWhereInput = {
  Container?: InputMaybe<ContainerWhereInput>;
  Form?: InputMaybe<FormWhereInput>;
};

export type FromSelectParentWhereUniqueInput = {
  Container?: InputMaybe<ContainerWhereUniqueInput>;
  Form?: InputMaybe<FormWhereUniqueInput>;
};

export type FromSelectUpdateInput = {
  /** label input for default locale (en) */
  label?: InputMaybe<Scalars['String']>;
  /** Manage document localizations */
  localizations?: InputMaybe<FromSelectUpdateLocalizationsInput>;
  name?: InputMaybe<Scalars['String']>;
  required?: InputMaybe<Scalars['Boolean']>;
};

export type FromSelectUpdateLocalizationDataInput = {
  label?: InputMaybe<Scalars['String']>;
};

export type FromSelectUpdateLocalizationInput = {
  data: FromSelectUpdateLocalizationDataInput;
  locale: Locale;
};

export type FromSelectUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<FromSelectCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<FromSelectUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<FromSelectUpsertLocalizationInput>>;
};

export type FromSelectUpdateManyInlineInput = {
  /** Create and connect multiple FromSelect component instances */
  create?: InputMaybe<Array<FromSelectCreateWithPositionInput>>;
  /** Delete multiple FromSelect documents */
  delete?: InputMaybe<Array<FromSelectWhereUniqueInput>>;
  /** Update multiple FromSelect component instances */
  update?: InputMaybe<Array<FromSelectUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple FromSelect component instances */
  upsert?: InputMaybe<Array<FromSelectUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type FromSelectUpdateManyInput = {
  /** label input for default locale (en) */
  label?: InputMaybe<Scalars['String']>;
  /** Optional updates to localizations */
  localizations?: InputMaybe<FromSelectUpdateManyLocalizationsInput>;
  name?: InputMaybe<Scalars['String']>;
  required?: InputMaybe<Scalars['Boolean']>;
};

export type FromSelectUpdateManyLocalizationDataInput = {
  label?: InputMaybe<Scalars['String']>;
};

export type FromSelectUpdateManyLocalizationInput = {
  data: FromSelectUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type FromSelectUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<FromSelectUpdateManyLocalizationInput>>;
};

export type FromSelectUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: FromSelectUpdateManyInput;
  /** Document search */
  where: FromSelectWhereInput;
};

export type FromSelectUpdateOneInlineInput = {
  /** Create and connect one FromSelect document */
  create?: InputMaybe<FromSelectCreateInput>;
  /** Delete currently connected FromSelect document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single FromSelect document */
  update?: InputMaybe<FromSelectUpdateWithNestedWhereUniqueInput>;
  /** Upsert single FromSelect document */
  upsert?: InputMaybe<FromSelectUpsertWithNestedWhereUniqueInput>;
};

export type FromSelectUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<FromSelectUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: FromSelectWhereUniqueInput;
};

export type FromSelectUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: FromSelectUpdateInput;
  /** Unique document search */
  where: FromSelectWhereUniqueInput;
};

export type FromSelectUpsertInput = {
  /** Create document if it didn't exist */
  create: FromSelectCreateInput;
  /** Update document if it exists */
  update: FromSelectUpdateInput;
};

export type FromSelectUpsertLocalizationInput = {
  create: FromSelectCreateLocalizationDataInput;
  locale: Locale;
  update: FromSelectUpdateLocalizationDataInput;
};

export type FromSelectUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<FromSelectUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: FromSelectWhereUniqueInput;
};

export type FromSelectUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: FromSelectUpsertInput;
  /** Unique document search */
  where: FromSelectWhereUniqueInput;
};

/** Identifies documents */
export type FromSelectWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<FromSelectWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<FromSelectWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<FromSelectWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  label?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  label_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  label_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  label_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  label_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  label_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  label_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  label_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  label_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  label_starts_with?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  name_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  name_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  name_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  name_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  name_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  name_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  name_starts_with?: InputMaybe<Scalars['String']>;
  required?: InputMaybe<Scalars['Boolean']>;
  /** All values that are not equal to given value. */
  required_not?: InputMaybe<Scalars['Boolean']>;
};

/** References FromSelect record uniquely */
export type FromSelectWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export type Grid = {
  __typename?: 'Grid';
  bgColor?: Maybe<Color>;
  children: Array<GridEvent>;
  description?: Maybe<Scalars['String']>;
  /** The unique identifier */
  id: Scalars['ID'];
  layout?: Maybe<GridLayout>;
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<Grid>;
  /** System stage field */
  stage: Stage;
  title: Scalars['String'];
  type: GridType;
};


export type GridChildrenArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
};


export type GridLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};

export type GridConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: GridWhereUniqueInput;
};

/** A connection to a list of items. */
export type GridConnection = {
  __typename?: 'GridConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<GridEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type GridCreateInput = {
  bgColor?: InputMaybe<ColorInput>;
  children?: InputMaybe<GridEventCreateManyInlineInput>;
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  layout?: InputMaybe<GridLayout>;
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<GridCreateLocalizationsInput>;
  /** title input for default locale (en) */
  title: Scalars['String'];
  type: GridType;
};

export type GridCreateLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
  title: Scalars['String'];
};

export type GridCreateLocalizationInput = {
  /** Localization input */
  data: GridCreateLocalizationDataInput;
  locale: Locale;
};

export type GridCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<GridCreateLocalizationInput>>;
};

export type GridCreateManyInlineInput = {
  /** Create and connect multiple existing Grid documents */
  create?: InputMaybe<Array<GridCreateInput>>;
};

export type GridCreateOneInlineInput = {
  /** Create and connect one Grid document */
  create?: InputMaybe<GridCreateInput>;
};

export type GridCreateWithPositionInput = {
  /** Document to create */
  data: GridCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type GridEdge = {
  __typename?: 'GridEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Grid;
};

export type GridEvent = Event | Person | Service | Sponsor;

export type GridEventConnectInput = {
  Event?: InputMaybe<EventConnectInput>;
  Person?: InputMaybe<PersonConnectInput>;
  Service?: InputMaybe<ServiceConnectInput>;
  Sponsor?: InputMaybe<SponsorConnectInput>;
};

export type GridEventCreateInput = {
  Event?: InputMaybe<EventCreateInput>;
  Person?: InputMaybe<PersonCreateInput>;
  Service?: InputMaybe<ServiceCreateInput>;
  Sponsor?: InputMaybe<SponsorCreateInput>;
};

export type GridEventCreateManyInlineInput = {
  /** Connect multiple existing GridEvent documents */
  connect?: InputMaybe<Array<GridEventWhereUniqueInput>>;
  /** Create and connect multiple existing GridEvent documents */
  create?: InputMaybe<Array<GridEventCreateInput>>;
};

export type GridEventCreateOneInlineInput = {
  /** Connect one existing GridEvent document */
  connect?: InputMaybe<GridEventWhereUniqueInput>;
  /** Create and connect one GridEvent document */
  create?: InputMaybe<GridEventCreateInput>;
};

export type GridEventUpdateInput = {
  Event?: InputMaybe<EventUpdateInput>;
  Person?: InputMaybe<PersonUpdateInput>;
  Service?: InputMaybe<ServiceUpdateInput>;
  Sponsor?: InputMaybe<SponsorUpdateInput>;
};

export type GridEventUpdateManyInlineInput = {
  /** Connect multiple existing GridEvent documents */
  connect?: InputMaybe<Array<GridEventConnectInput>>;
  /** Create and connect multiple GridEvent documents */
  create?: InputMaybe<Array<GridEventCreateInput>>;
  /** Delete multiple GridEvent documents */
  delete?: InputMaybe<Array<GridEventWhereUniqueInput>>;
  /** Disconnect multiple GridEvent documents */
  disconnect?: InputMaybe<Array<GridEventWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing GridEvent documents */
  set?: InputMaybe<Array<GridEventWhereUniqueInput>>;
  /** Update multiple GridEvent documents */
  update?: InputMaybe<Array<GridEventUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple GridEvent documents */
  upsert?: InputMaybe<Array<GridEventUpsertWithNestedWhereUniqueInput>>;
};

export type GridEventUpdateManyWithNestedWhereInput = {
  Event?: InputMaybe<EventUpdateManyWithNestedWhereInput>;
  Person?: InputMaybe<PersonUpdateManyWithNestedWhereInput>;
  Service?: InputMaybe<ServiceUpdateManyWithNestedWhereInput>;
  Sponsor?: InputMaybe<SponsorUpdateManyWithNestedWhereInput>;
};

export type GridEventUpdateOneInlineInput = {
  /** Connect existing GridEvent document */
  connect?: InputMaybe<GridEventWhereUniqueInput>;
  /** Create and connect one GridEvent document */
  create?: InputMaybe<GridEventCreateInput>;
  /** Delete currently connected GridEvent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected GridEvent document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single GridEvent document */
  update?: InputMaybe<GridEventUpdateWithNestedWhereUniqueInput>;
  /** Upsert single GridEvent document */
  upsert?: InputMaybe<GridEventUpsertWithNestedWhereUniqueInput>;
};

export type GridEventUpdateWithNestedWhereUniqueInput = {
  Event?: InputMaybe<EventUpdateWithNestedWhereUniqueInput>;
  Person?: InputMaybe<PersonUpdateWithNestedWhereUniqueInput>;
  Service?: InputMaybe<ServiceUpdateWithNestedWhereUniqueInput>;
  Sponsor?: InputMaybe<SponsorUpdateWithNestedWhereUniqueInput>;
};

export type GridEventUpsertWithNestedWhereUniqueInput = {
  Event?: InputMaybe<EventUpsertWithNestedWhereUniqueInput>;
  Person?: InputMaybe<PersonUpsertWithNestedWhereUniqueInput>;
  Service?: InputMaybe<ServiceUpsertWithNestedWhereUniqueInput>;
  Sponsor?: InputMaybe<SponsorUpsertWithNestedWhereUniqueInput>;
};

export type GridEventWhereInput = {
  Event?: InputMaybe<EventWhereInput>;
  Person?: InputMaybe<PersonWhereInput>;
  Service?: InputMaybe<ServiceWhereInput>;
  Sponsor?: InputMaybe<SponsorWhereInput>;
};

export type GridEventWhereUniqueInput = {
  Event?: InputMaybe<EventWhereUniqueInput>;
  Person?: InputMaybe<PersonWhereUniqueInput>;
  Service?: InputMaybe<ServiceWhereUniqueInput>;
  Sponsor?: InputMaybe<SponsorWhereUniqueInput>;
};

export enum GridLayout {
  Split = 'SPLIT',
  Stack = 'STACK'
}

/** Identifies documents */
export type GridManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<GridWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<GridWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<GridWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  layout?: InputMaybe<GridLayout>;
  /** All values that are contained in given list. */
  layout_in?: InputMaybe<Array<InputMaybe<GridLayout>>>;
  /** All values that are not equal to given value. */
  layout_not?: InputMaybe<GridLayout>;
  /** All values that are not contained in given list. */
  layout_not_in?: InputMaybe<Array<InputMaybe<GridLayout>>>;
  type?: InputMaybe<GridType>;
  /** All values that are contained in given list. */
  type_in?: InputMaybe<Array<InputMaybe<GridType>>>;
  /** All values that are not equal to given value. */
  type_not?: InputMaybe<GridType>;
  /** All values that are not contained in given list. */
  type_not_in?: InputMaybe<Array<InputMaybe<GridType>>>;
};

export enum GridOrderByInput {
  DescriptionAsc = 'description_ASC',
  DescriptionDesc = 'description_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  LayoutAsc = 'layout_ASC',
  LayoutDesc = 'layout_DESC',
  TitleAsc = 'title_ASC',
  TitleDesc = 'title_DESC',
  TypeAsc = 'type_ASC',
  TypeDesc = 'type_DESC'
}

export type GridParent = Page;

export type GridParentConnectInput = {
  Page?: InputMaybe<PageConnectInput>;
};

export type GridParentCreateInput = {
  Page?: InputMaybe<PageCreateInput>;
};

export type GridParentCreateManyInlineInput = {
  /** Connect multiple existing GridParent documents */
  connect?: InputMaybe<Array<GridParentWhereUniqueInput>>;
  /** Create and connect multiple existing GridParent documents */
  create?: InputMaybe<Array<GridParentCreateInput>>;
};

export type GridParentCreateOneInlineInput = {
  /** Connect one existing GridParent document */
  connect?: InputMaybe<GridParentWhereUniqueInput>;
  /** Create and connect one GridParent document */
  create?: InputMaybe<GridParentCreateInput>;
};

export type GridParentUpdateInput = {
  Page?: InputMaybe<PageUpdateInput>;
};

export type GridParentUpdateManyInlineInput = {
  /** Connect multiple existing GridParent documents */
  connect?: InputMaybe<Array<GridParentConnectInput>>;
  /** Create and connect multiple GridParent documents */
  create?: InputMaybe<Array<GridParentCreateInput>>;
  /** Delete multiple GridParent documents */
  delete?: InputMaybe<Array<GridParentWhereUniqueInput>>;
  /** Disconnect multiple GridParent documents */
  disconnect?: InputMaybe<Array<GridParentWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing GridParent documents */
  set?: InputMaybe<Array<GridParentWhereUniqueInput>>;
  /** Update multiple GridParent documents */
  update?: InputMaybe<Array<GridParentUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple GridParent documents */
  upsert?: InputMaybe<Array<GridParentUpsertWithNestedWhereUniqueInput>>;
};

export type GridParentUpdateManyWithNestedWhereInput = {
  Page?: InputMaybe<PageUpdateManyWithNestedWhereInput>;
};

export type GridParentUpdateOneInlineInput = {
  /** Connect existing GridParent document */
  connect?: InputMaybe<GridParentWhereUniqueInput>;
  /** Create and connect one GridParent document */
  create?: InputMaybe<GridParentCreateInput>;
  /** Delete currently connected GridParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected GridParent document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single GridParent document */
  update?: InputMaybe<GridParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single GridParent document */
  upsert?: InputMaybe<GridParentUpsertWithNestedWhereUniqueInput>;
};

export type GridParentUpdateWithNestedWhereUniqueInput = {
  Page?: InputMaybe<PageUpdateWithNestedWhereUniqueInput>;
};

export type GridParentUpsertWithNestedWhereUniqueInput = {
  Page?: InputMaybe<PageUpsertWithNestedWhereUniqueInput>;
};

export type GridParentWhereInput = {
  Page?: InputMaybe<PageWhereInput>;
};

export type GridParentWhereUniqueInput = {
  Page?: InputMaybe<PageWhereUniqueInput>;
};

export enum GridType {
  Events = 'EVENTS',
  Services = 'SERVICES',
  Sponsors = 'SPONSORS',
  TeamMembers = 'TEAM_MEMBERS'
}

export type GridUpdateInput = {
  bgColor?: InputMaybe<ColorInput>;
  children?: InputMaybe<GridEventUpdateManyInlineInput>;
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  layout?: InputMaybe<GridLayout>;
  /** Manage document localizations */
  localizations?: InputMaybe<GridUpdateLocalizationsInput>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<GridType>;
};

export type GridUpdateLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export type GridUpdateLocalizationInput = {
  data: GridUpdateLocalizationDataInput;
  locale: Locale;
};

export type GridUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<GridCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<GridUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<GridUpsertLocalizationInput>>;
};

export type GridUpdateManyInlineInput = {
  /** Create and connect multiple Grid component instances */
  create?: InputMaybe<Array<GridCreateWithPositionInput>>;
  /** Delete multiple Grid documents */
  delete?: InputMaybe<Array<GridWhereUniqueInput>>;
  /** Update multiple Grid component instances */
  update?: InputMaybe<Array<GridUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple Grid component instances */
  upsert?: InputMaybe<Array<GridUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type GridUpdateManyInput = {
  bgColor?: InputMaybe<ColorInput>;
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  layout?: InputMaybe<GridLayout>;
  /** Optional updates to localizations */
  localizations?: InputMaybe<GridUpdateManyLocalizationsInput>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<GridType>;
};

export type GridUpdateManyLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export type GridUpdateManyLocalizationInput = {
  data: GridUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type GridUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<GridUpdateManyLocalizationInput>>;
};

export type GridUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: GridUpdateManyInput;
  /** Document search */
  where: GridWhereInput;
};

export type GridUpdateOneInlineInput = {
  /** Create and connect one Grid document */
  create?: InputMaybe<GridCreateInput>;
  /** Delete currently connected Grid document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single Grid document */
  update?: InputMaybe<GridUpdateWithNestedWhereUniqueInput>;
  /** Upsert single Grid document */
  upsert?: InputMaybe<GridUpsertWithNestedWhereUniqueInput>;
};

export type GridUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<GridUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: GridWhereUniqueInput;
};

export type GridUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: GridUpdateInput;
  /** Unique document search */
  where: GridWhereUniqueInput;
};

export type GridUpsertInput = {
  /** Create document if it didn't exist */
  create: GridCreateInput;
  /** Update document if it exists */
  update: GridUpdateInput;
};

export type GridUpsertLocalizationInput = {
  create: GridCreateLocalizationDataInput;
  locale: Locale;
  update: GridUpdateLocalizationDataInput;
};

export type GridUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<GridUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: GridWhereUniqueInput;
};

export type GridUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: GridUpsertInput;
  /** Unique document search */
  where: GridWhereUniqueInput;
};

/** Identifies documents */
export type GridWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<GridWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<GridWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<GridWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  description_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  description_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  description_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  description_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  description_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  description_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  description_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  description_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  description_starts_with?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  layout?: InputMaybe<GridLayout>;
  /** All values that are contained in given list. */
  layout_in?: InputMaybe<Array<InputMaybe<GridLayout>>>;
  /** All values that are not equal to given value. */
  layout_not?: InputMaybe<GridLayout>;
  /** All values that are not contained in given list. */
  layout_not_in?: InputMaybe<Array<InputMaybe<GridLayout>>>;
  title?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  title_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  title_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  title_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  title_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  title_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  title_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  title_starts_with?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<GridType>;
  /** All values that are contained in given list. */
  type_in?: InputMaybe<Array<InputMaybe<GridType>>>;
  /** All values that are not equal to given value. */
  type_not?: InputMaybe<GridType>;
  /** All values that are not contained in given list. */
  type_not_in?: InputMaybe<Array<InputMaybe<GridType>>>;
};

/** References Grid record uniquely */
export type GridWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export type Hero = {
  __typename?: 'Hero';
  description?: Maybe<Scalars['String']>;
  /** The unique identifier */
  id: Scalars['ID'];
  /** Image of the hero */
  image: Asset;
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<Hero>;
  /** System stage field */
  stage: Stage;
  title: Scalars['String'];
};


export type HeroImageArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type HeroLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};

export type HeroConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: HeroWhereUniqueInput;
};

/** A connection to a list of items. */
export type HeroConnection = {
  __typename?: 'HeroConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<HeroEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type HeroCreateInput = {
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  image: AssetCreateOneInlineInput;
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<HeroCreateLocalizationsInput>;
  /** title input for default locale (en) */
  title: Scalars['String'];
};

export type HeroCreateLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
  title: Scalars['String'];
};

export type HeroCreateLocalizationInput = {
  /** Localization input */
  data: HeroCreateLocalizationDataInput;
  locale: Locale;
};

export type HeroCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<HeroCreateLocalizationInput>>;
};

export type HeroCreateManyInlineInput = {
  /** Create and connect multiple existing Hero documents */
  create?: InputMaybe<Array<HeroCreateInput>>;
};

export type HeroCreateOneInlineInput = {
  /** Create and connect one Hero document */
  create?: InputMaybe<HeroCreateInput>;
};

export type HeroCreateWithPositionInput = {
  /** Document to create */
  data: HeroCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type HeroEdge = {
  __typename?: 'HeroEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Hero;
};

/** Identifies documents */
export type HeroManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<HeroWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<HeroWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<HeroWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  image?: InputMaybe<AssetWhereInput>;
};

export enum HeroOrderByInput {
  DescriptionAsc = 'description_ASC',
  DescriptionDesc = 'description_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  TitleAsc = 'title_ASC',
  TitleDesc = 'title_DESC'
}

export type HeroParent = Page;

export type HeroParentConnectInput = {
  Page?: InputMaybe<PageConnectInput>;
};

export type HeroParentCreateInput = {
  Page?: InputMaybe<PageCreateInput>;
};

export type HeroParentCreateManyInlineInput = {
  /** Connect multiple existing HeroParent documents */
  connect?: InputMaybe<Array<HeroParentWhereUniqueInput>>;
  /** Create and connect multiple existing HeroParent documents */
  create?: InputMaybe<Array<HeroParentCreateInput>>;
};

export type HeroParentCreateOneInlineInput = {
  /** Connect one existing HeroParent document */
  connect?: InputMaybe<HeroParentWhereUniqueInput>;
  /** Create and connect one HeroParent document */
  create?: InputMaybe<HeroParentCreateInput>;
};

export type HeroParentUpdateInput = {
  Page?: InputMaybe<PageUpdateInput>;
};

export type HeroParentUpdateManyInlineInput = {
  /** Connect multiple existing HeroParent documents */
  connect?: InputMaybe<Array<HeroParentConnectInput>>;
  /** Create and connect multiple HeroParent documents */
  create?: InputMaybe<Array<HeroParentCreateInput>>;
  /** Delete multiple HeroParent documents */
  delete?: InputMaybe<Array<HeroParentWhereUniqueInput>>;
  /** Disconnect multiple HeroParent documents */
  disconnect?: InputMaybe<Array<HeroParentWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing HeroParent documents */
  set?: InputMaybe<Array<HeroParentWhereUniqueInput>>;
  /** Update multiple HeroParent documents */
  update?: InputMaybe<Array<HeroParentUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple HeroParent documents */
  upsert?: InputMaybe<Array<HeroParentUpsertWithNestedWhereUniqueInput>>;
};

export type HeroParentUpdateManyWithNestedWhereInput = {
  Page?: InputMaybe<PageUpdateManyWithNestedWhereInput>;
};

export type HeroParentUpdateOneInlineInput = {
  /** Connect existing HeroParent document */
  connect?: InputMaybe<HeroParentWhereUniqueInput>;
  /** Create and connect one HeroParent document */
  create?: InputMaybe<HeroParentCreateInput>;
  /** Delete currently connected HeroParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected HeroParent document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single HeroParent document */
  update?: InputMaybe<HeroParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single HeroParent document */
  upsert?: InputMaybe<HeroParentUpsertWithNestedWhereUniqueInput>;
};

export type HeroParentUpdateWithNestedWhereUniqueInput = {
  Page?: InputMaybe<PageUpdateWithNestedWhereUniqueInput>;
};

export type HeroParentUpsertWithNestedWhereUniqueInput = {
  Page?: InputMaybe<PageUpsertWithNestedWhereUniqueInput>;
};

export type HeroParentWhereInput = {
  Page?: InputMaybe<PageWhereInput>;
};

export type HeroParentWhereUniqueInput = {
  Page?: InputMaybe<PageWhereUniqueInput>;
};

export type HeroUpdateInput = {
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<AssetUpdateOneInlineInput>;
  /** Manage document localizations */
  localizations?: InputMaybe<HeroUpdateLocalizationsInput>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
};

export type HeroUpdateLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export type HeroUpdateLocalizationInput = {
  data: HeroUpdateLocalizationDataInput;
  locale: Locale;
};

export type HeroUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<HeroCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<HeroUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<HeroUpsertLocalizationInput>>;
};

export type HeroUpdateManyInlineInput = {
  /** Create and connect multiple Hero component instances */
  create?: InputMaybe<Array<HeroCreateWithPositionInput>>;
  /** Delete multiple Hero documents */
  delete?: InputMaybe<Array<HeroWhereUniqueInput>>;
  /** Update multiple Hero component instances */
  update?: InputMaybe<Array<HeroUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple Hero component instances */
  upsert?: InputMaybe<Array<HeroUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type HeroUpdateManyInput = {
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  /** Optional updates to localizations */
  localizations?: InputMaybe<HeroUpdateManyLocalizationsInput>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
};

export type HeroUpdateManyLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export type HeroUpdateManyLocalizationInput = {
  data: HeroUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type HeroUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<HeroUpdateManyLocalizationInput>>;
};

export type HeroUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: HeroUpdateManyInput;
  /** Document search */
  where: HeroWhereInput;
};

export type HeroUpdateOneInlineInput = {
  /** Create and connect one Hero document */
  create?: InputMaybe<HeroCreateInput>;
  /** Delete currently connected Hero document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single Hero document */
  update?: InputMaybe<HeroUpdateWithNestedWhereUniqueInput>;
  /** Upsert single Hero document */
  upsert?: InputMaybe<HeroUpsertWithNestedWhereUniqueInput>;
};

export type HeroUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<HeroUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: HeroWhereUniqueInput;
};

export type HeroUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: HeroUpdateInput;
  /** Unique document search */
  where: HeroWhereUniqueInput;
};

export type HeroUpsertInput = {
  /** Create document if it didn't exist */
  create: HeroCreateInput;
  /** Update document if it exists */
  update: HeroUpdateInput;
};

export type HeroUpsertLocalizationInput = {
  create: HeroCreateLocalizationDataInput;
  locale: Locale;
  update: HeroUpdateLocalizationDataInput;
};

export type HeroUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<HeroUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: HeroWhereUniqueInput;
};

export type HeroUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: HeroUpsertInput;
  /** Unique document search */
  where: HeroWhereUniqueInput;
};

/** Identifies documents */
export type HeroWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<HeroWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<HeroWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<HeroWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  description_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  description_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  description_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  description_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  description_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  description_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  description_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  description_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  description_starts_with?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  image?: InputMaybe<AssetWhereInput>;
  title?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  title_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  title_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  title_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  title_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  title_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  title_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  title_starts_with?: InputMaybe<Scalars['String']>;
};

/** References Hero record uniquely */
export type HeroWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export type Highlight = {
  __typename?: 'Highlight';
  color: Color;
  /** The unique identifier */
  id: Scalars['ID'];
  /** System stage field */
  stage: Stage;
  text: Scalars['String'];
};

/** A connection to a list of items. */
export type HighlightConnection = {
  __typename?: 'HighlightConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<HighlightEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type HighlightCreateInput = {
  color: ColorInput;
  text: Scalars['String'];
};

export type HighlightCreateWithPositionInput = {
  /** Document to create */
  data: HighlightCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type HighlightEdge = {
  __typename?: 'HighlightEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Highlight;
};

/** Identifies documents */
export type HighlightManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<HighlightWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<HighlightWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<HighlightWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  text?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  text_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  text_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  text_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  text_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  text_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  text_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  text_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  text_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  text_starts_with?: InputMaybe<Scalars['String']>;
};

export enum HighlightOrderByInput {
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  TextAsc = 'text_ASC',
  TextDesc = 'text_DESC'
}

export type HighlightUpdateInput = {
  color?: InputMaybe<ColorInput>;
  text?: InputMaybe<Scalars['String']>;
};

export type HighlightUpdateManyInput = {
  color?: InputMaybe<ColorInput>;
  text?: InputMaybe<Scalars['String']>;
};

export type HighlightUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: HighlightUpdateManyInput;
  /** Document search */
  where: HighlightWhereInput;
};

export type HighlightUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<HighlightUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: HighlightWhereUniqueInput;
};

export type HighlightUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: HighlightUpdateInput;
  /** Unique document search */
  where: HighlightWhereUniqueInput;
};

export type HighlightUpsertInput = {
  /** Create document if it didn't exist */
  create: HighlightCreateInput;
  /** Update document if it exists */
  update: HighlightUpdateInput;
};

export type HighlightUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<HighlightUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: HighlightWhereUniqueInput;
};

export type HighlightUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: HighlightUpsertInput;
  /** Unique document search */
  where: HighlightWhereUniqueInput;
};

/** Identifies documents */
export type HighlightWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<HighlightWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<HighlightWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<HighlightWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  text?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  text_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  text_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  text_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  text_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  text_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  text_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  text_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  text_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  text_starts_with?: InputMaybe<Scalars['String']>;
};

/** References Highlight record uniquely */
export type HighlightWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export enum Icons {
  FaHome = 'FaHome',
  FaUsers = 'FaUsers',
  GiTeacher = 'GiTeacher',
  MdSchool = 'MdSchool',
  MdWork = 'MdWork',
  RiParentFill = 'RiParentFill'
}

export type ImageContainer = {
  __typename?: 'ImageContainer';
  height?: Maybe<Scalars['Int']>;
  /** The unique identifier */
  id: Scalars['ID'];
  image?: Maybe<Asset>;
  /** System stage field */
  stage: Stage;
  width?: Maybe<Scalars['Int']>;
  withBackground?: Maybe<Scalars['Boolean']>;
};


export type ImageContainerImageArgs = {
  locales?: InputMaybe<Array<Locale>>;
};

export type ImageContainerConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: ImageContainerWhereUniqueInput;
};

/** A connection to a list of items. */
export type ImageContainerConnection = {
  __typename?: 'ImageContainerConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<ImageContainerEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type ImageContainerCreateInput = {
  height?: InputMaybe<Scalars['Int']>;
  image?: InputMaybe<AssetCreateOneInlineInput>;
  width?: InputMaybe<Scalars['Int']>;
  withBackground?: InputMaybe<Scalars['Boolean']>;
};

export type ImageContainerCreateManyInlineInput = {
  /** Create and connect multiple existing ImageContainer documents */
  create?: InputMaybe<Array<ImageContainerCreateInput>>;
};

export type ImageContainerCreateOneInlineInput = {
  /** Create and connect one ImageContainer document */
  create?: InputMaybe<ImageContainerCreateInput>;
};

export type ImageContainerCreateWithPositionInput = {
  /** Document to create */
  data: ImageContainerCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type ImageContainerEdge = {
  __typename?: 'ImageContainerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: ImageContainer;
};

/** Identifies documents */
export type ImageContainerManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<ImageContainerWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<ImageContainerWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<ImageContainerWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  height?: InputMaybe<Scalars['Int']>;
  /** All values greater than the given value. */
  height_gt?: InputMaybe<Scalars['Int']>;
  /** All values greater than or equal the given value. */
  height_gte?: InputMaybe<Scalars['Int']>;
  /** All values that are contained in given list. */
  height_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  /** All values less than the given value. */
  height_lt?: InputMaybe<Scalars['Int']>;
  /** All values less than or equal the given value. */
  height_lte?: InputMaybe<Scalars['Int']>;
  /** All values that are not equal to given value. */
  height_not?: InputMaybe<Scalars['Int']>;
  /** All values that are not contained in given list. */
  height_not_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  image?: InputMaybe<AssetWhereInput>;
  width?: InputMaybe<Scalars['Int']>;
  /** All values greater than the given value. */
  width_gt?: InputMaybe<Scalars['Int']>;
  /** All values greater than or equal the given value. */
  width_gte?: InputMaybe<Scalars['Int']>;
  /** All values that are contained in given list. */
  width_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  /** All values less than the given value. */
  width_lt?: InputMaybe<Scalars['Int']>;
  /** All values less than or equal the given value. */
  width_lte?: InputMaybe<Scalars['Int']>;
  /** All values that are not equal to given value. */
  width_not?: InputMaybe<Scalars['Int']>;
  /** All values that are not contained in given list. */
  width_not_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  withBackground?: InputMaybe<Scalars['Boolean']>;
  /** All values that are not equal to given value. */
  withBackground_not?: InputMaybe<Scalars['Boolean']>;
};

export enum ImageContainerOrderByInput {
  HeightAsc = 'height_ASC',
  HeightDesc = 'height_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  WidthAsc = 'width_ASC',
  WidthDesc = 'width_DESC',
  WithBackgroundAsc = 'withBackground_ASC',
  WithBackgroundDesc = 'withBackground_DESC'
}

export type ImageContainerUpdateInput = {
  height?: InputMaybe<Scalars['Int']>;
  image?: InputMaybe<AssetUpdateOneInlineInput>;
  width?: InputMaybe<Scalars['Int']>;
  withBackground?: InputMaybe<Scalars['Boolean']>;
};

export type ImageContainerUpdateManyInlineInput = {
  /** Create and connect multiple ImageContainer component instances */
  create?: InputMaybe<Array<ImageContainerCreateWithPositionInput>>;
  /** Delete multiple ImageContainer documents */
  delete?: InputMaybe<Array<ImageContainerWhereUniqueInput>>;
  /** Update multiple ImageContainer component instances */
  update?: InputMaybe<Array<ImageContainerUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple ImageContainer component instances */
  upsert?: InputMaybe<Array<ImageContainerUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type ImageContainerUpdateManyInput = {
  height?: InputMaybe<Scalars['Int']>;
  width?: InputMaybe<Scalars['Int']>;
  withBackground?: InputMaybe<Scalars['Boolean']>;
};

export type ImageContainerUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: ImageContainerUpdateManyInput;
  /** Document search */
  where: ImageContainerWhereInput;
};

export type ImageContainerUpdateOneInlineInput = {
  /** Create and connect one ImageContainer document */
  create?: InputMaybe<ImageContainerCreateInput>;
  /** Delete currently connected ImageContainer document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single ImageContainer document */
  update?: InputMaybe<ImageContainerUpdateWithNestedWhereUniqueInput>;
  /** Upsert single ImageContainer document */
  upsert?: InputMaybe<ImageContainerUpsertWithNestedWhereUniqueInput>;
};

export type ImageContainerUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<ImageContainerUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: ImageContainerWhereUniqueInput;
};

export type ImageContainerUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: ImageContainerUpdateInput;
  /** Unique document search */
  where: ImageContainerWhereUniqueInput;
};

export type ImageContainerUpsertInput = {
  /** Create document if it didn't exist */
  create: ImageContainerCreateInput;
  /** Update document if it exists */
  update: ImageContainerUpdateInput;
};

export type ImageContainerUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<ImageContainerUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: ImageContainerWhereUniqueInput;
};

export type ImageContainerUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: ImageContainerUpsertInput;
  /** Unique document search */
  where: ImageContainerWhereUniqueInput;
};

/** Identifies documents */
export type ImageContainerWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<ImageContainerWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<ImageContainerWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<ImageContainerWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  height?: InputMaybe<Scalars['Int']>;
  /** All values greater than the given value. */
  height_gt?: InputMaybe<Scalars['Int']>;
  /** All values greater than or equal the given value. */
  height_gte?: InputMaybe<Scalars['Int']>;
  /** All values that are contained in given list. */
  height_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  /** All values less than the given value. */
  height_lt?: InputMaybe<Scalars['Int']>;
  /** All values less than or equal the given value. */
  height_lte?: InputMaybe<Scalars['Int']>;
  /** All values that are not equal to given value. */
  height_not?: InputMaybe<Scalars['Int']>;
  /** All values that are not contained in given list. */
  height_not_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  image?: InputMaybe<AssetWhereInput>;
  width?: InputMaybe<Scalars['Int']>;
  /** All values greater than the given value. */
  width_gt?: InputMaybe<Scalars['Int']>;
  /** All values greater than or equal the given value. */
  width_gte?: InputMaybe<Scalars['Int']>;
  /** All values that are contained in given list. */
  width_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  /** All values less than the given value. */
  width_lt?: InputMaybe<Scalars['Int']>;
  /** All values less than or equal the given value. */
  width_lte?: InputMaybe<Scalars['Int']>;
  /** All values that are not equal to given value. */
  width_not?: InputMaybe<Scalars['Int']>;
  /** All values that are not contained in given list. */
  width_not_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  withBackground?: InputMaybe<Scalars['Boolean']>;
  /** All values that are not equal to given value. */
  withBackground_not?: InputMaybe<Scalars['Boolean']>;
};

/** References ImageContainer record uniquely */
export type ImageContainerWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export enum ImageFit {
  /** Resizes the image to fit within the specified parameters without distorting, cropping, or changing the aspect ratio. */
  Clip = 'clip',
  /** Resizes the image to fit the specified parameters exactly by removing any parts of the image that don't fit within the boundaries. */
  Crop = 'crop',
  /** Resizes the image to fit within the parameters, but as opposed to 'fit:clip' will not scale the image if the image is smaller than the output size. */
  Max = 'max',
  /** Resizes the image to fit the specified parameters exactly by scaling the image to the desired size. The aspect ratio of the image is not respected and the image can be distorted using this method. */
  Scale = 'scale'
}

export type ImageResizeInput = {
  /** The default value for the fit parameter is fit:clip. */
  fit?: InputMaybe<ImageFit>;
  /** The height in pixels to resize the image to. The value must be an integer from 1 to 10000. */
  height?: InputMaybe<Scalars['Int']>;
  /** The width in pixels to resize the image to. The value must be an integer from 1 to 10000. */
  width?: InputMaybe<Scalars['Int']>;
};

/** Transformations for Images */
export type ImageTransformationInput = {
  /** Resizes the image */
  resize?: InputMaybe<ImageResizeInput>;
};

export enum InputType {
  Email = 'EMAIL',
  Tel = 'TEL',
  Text = 'TEXT'
}

export type JoinUsSection = {
  __typename?: 'JoinUsSection';
  bgColor?: Maybe<Color>;
  ctas: Array<OldButton>;
  description?: Maybe<Scalars['String']>;
  /** The unique identifier */
  id: Scalars['ID'];
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<JoinUsSection>;
  /** System stage field */
  stage: Stage;
  title: Scalars['String'];
};


export type JoinUsSectionCtasArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  orderBy?: InputMaybe<OldButtonOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<OldButtonWhereInput>;
};


export type JoinUsSectionLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};

export type JoinUsSectionConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: JoinUsSectionWhereUniqueInput;
};

/** A connection to a list of items. */
export type JoinUsSectionConnection = {
  __typename?: 'JoinUsSectionConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<JoinUsSectionEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type JoinUsSectionCreateInput = {
  bgColor?: InputMaybe<ColorInput>;
  ctas?: InputMaybe<OldButtonCreateManyInlineInput>;
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<JoinUsSectionCreateLocalizationsInput>;
  /** title input for default locale (en) */
  title: Scalars['String'];
};

export type JoinUsSectionCreateLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
  title: Scalars['String'];
};

export type JoinUsSectionCreateLocalizationInput = {
  /** Localization input */
  data: JoinUsSectionCreateLocalizationDataInput;
  locale: Locale;
};

export type JoinUsSectionCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<JoinUsSectionCreateLocalizationInput>>;
};

export type JoinUsSectionCreateManyInlineInput = {
  /** Create and connect multiple existing JoinUsSection documents */
  create?: InputMaybe<Array<JoinUsSectionCreateInput>>;
};

export type JoinUsSectionCreateOneInlineInput = {
  /** Create and connect one JoinUsSection document */
  create?: InputMaybe<JoinUsSectionCreateInput>;
};

export type JoinUsSectionCreateWithPositionInput = {
  /** Document to create */
  data: JoinUsSectionCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type JoinUsSectionEdge = {
  __typename?: 'JoinUsSectionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: JoinUsSection;
};

/** Identifies documents */
export type JoinUsSectionManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<JoinUsSectionWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<JoinUsSectionWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<JoinUsSectionWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  ctas_every?: InputMaybe<OldButtonWhereInput>;
  ctas_none?: InputMaybe<OldButtonWhereInput>;
  ctas_some?: InputMaybe<OldButtonWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
};

export enum JoinUsSectionOrderByInput {
  DescriptionAsc = 'description_ASC',
  DescriptionDesc = 'description_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  TitleAsc = 'title_ASC',
  TitleDesc = 'title_DESC'
}

export type JoinUsSectionParent = Page;

export type JoinUsSectionParentConnectInput = {
  Page?: InputMaybe<PageConnectInput>;
};

export type JoinUsSectionParentCreateInput = {
  Page?: InputMaybe<PageCreateInput>;
};

export type JoinUsSectionParentCreateManyInlineInput = {
  /** Connect multiple existing JoinUsSectionParent documents */
  connect?: InputMaybe<Array<JoinUsSectionParentWhereUniqueInput>>;
  /** Create and connect multiple existing JoinUsSectionParent documents */
  create?: InputMaybe<Array<JoinUsSectionParentCreateInput>>;
};

export type JoinUsSectionParentCreateOneInlineInput = {
  /** Connect one existing JoinUsSectionParent document */
  connect?: InputMaybe<JoinUsSectionParentWhereUniqueInput>;
  /** Create and connect one JoinUsSectionParent document */
  create?: InputMaybe<JoinUsSectionParentCreateInput>;
};

export type JoinUsSectionParentUpdateInput = {
  Page?: InputMaybe<PageUpdateInput>;
};

export type JoinUsSectionParentUpdateManyInlineInput = {
  /** Connect multiple existing JoinUsSectionParent documents */
  connect?: InputMaybe<Array<JoinUsSectionParentConnectInput>>;
  /** Create and connect multiple JoinUsSectionParent documents */
  create?: InputMaybe<Array<JoinUsSectionParentCreateInput>>;
  /** Delete multiple JoinUsSectionParent documents */
  delete?: InputMaybe<Array<JoinUsSectionParentWhereUniqueInput>>;
  /** Disconnect multiple JoinUsSectionParent documents */
  disconnect?: InputMaybe<Array<JoinUsSectionParentWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing JoinUsSectionParent documents */
  set?: InputMaybe<Array<JoinUsSectionParentWhereUniqueInput>>;
  /** Update multiple JoinUsSectionParent documents */
  update?: InputMaybe<Array<JoinUsSectionParentUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple JoinUsSectionParent documents */
  upsert?: InputMaybe<Array<JoinUsSectionParentUpsertWithNestedWhereUniqueInput>>;
};

export type JoinUsSectionParentUpdateManyWithNestedWhereInput = {
  Page?: InputMaybe<PageUpdateManyWithNestedWhereInput>;
};

export type JoinUsSectionParentUpdateOneInlineInput = {
  /** Connect existing JoinUsSectionParent document */
  connect?: InputMaybe<JoinUsSectionParentWhereUniqueInput>;
  /** Create and connect one JoinUsSectionParent document */
  create?: InputMaybe<JoinUsSectionParentCreateInput>;
  /** Delete currently connected JoinUsSectionParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected JoinUsSectionParent document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single JoinUsSectionParent document */
  update?: InputMaybe<JoinUsSectionParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single JoinUsSectionParent document */
  upsert?: InputMaybe<JoinUsSectionParentUpsertWithNestedWhereUniqueInput>;
};

export type JoinUsSectionParentUpdateWithNestedWhereUniqueInput = {
  Page?: InputMaybe<PageUpdateWithNestedWhereUniqueInput>;
};

export type JoinUsSectionParentUpsertWithNestedWhereUniqueInput = {
  Page?: InputMaybe<PageUpsertWithNestedWhereUniqueInput>;
};

export type JoinUsSectionParentWhereInput = {
  Page?: InputMaybe<PageWhereInput>;
};

export type JoinUsSectionParentWhereUniqueInput = {
  Page?: InputMaybe<PageWhereUniqueInput>;
};

export type JoinUsSectionUpdateInput = {
  bgColor?: InputMaybe<ColorInput>;
  ctas?: InputMaybe<OldButtonUpdateManyInlineInput>;
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  /** Manage document localizations */
  localizations?: InputMaybe<JoinUsSectionUpdateLocalizationsInput>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
};

export type JoinUsSectionUpdateLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export type JoinUsSectionUpdateLocalizationInput = {
  data: JoinUsSectionUpdateLocalizationDataInput;
  locale: Locale;
};

export type JoinUsSectionUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<JoinUsSectionCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<JoinUsSectionUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<JoinUsSectionUpsertLocalizationInput>>;
};

export type JoinUsSectionUpdateManyInlineInput = {
  /** Create and connect multiple JoinUsSection component instances */
  create?: InputMaybe<Array<JoinUsSectionCreateWithPositionInput>>;
  /** Delete multiple JoinUsSection documents */
  delete?: InputMaybe<Array<JoinUsSectionWhereUniqueInput>>;
  /** Update multiple JoinUsSection component instances */
  update?: InputMaybe<Array<JoinUsSectionUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple JoinUsSection component instances */
  upsert?: InputMaybe<Array<JoinUsSectionUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type JoinUsSectionUpdateManyInput = {
  bgColor?: InputMaybe<ColorInput>;
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  /** Optional updates to localizations */
  localizations?: InputMaybe<JoinUsSectionUpdateManyLocalizationsInput>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
};

export type JoinUsSectionUpdateManyLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export type JoinUsSectionUpdateManyLocalizationInput = {
  data: JoinUsSectionUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type JoinUsSectionUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<JoinUsSectionUpdateManyLocalizationInput>>;
};

export type JoinUsSectionUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: JoinUsSectionUpdateManyInput;
  /** Document search */
  where: JoinUsSectionWhereInput;
};

export type JoinUsSectionUpdateOneInlineInput = {
  /** Create and connect one JoinUsSection document */
  create?: InputMaybe<JoinUsSectionCreateInput>;
  /** Delete currently connected JoinUsSection document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single JoinUsSection document */
  update?: InputMaybe<JoinUsSectionUpdateWithNestedWhereUniqueInput>;
  /** Upsert single JoinUsSection document */
  upsert?: InputMaybe<JoinUsSectionUpsertWithNestedWhereUniqueInput>;
};

export type JoinUsSectionUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<JoinUsSectionUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: JoinUsSectionWhereUniqueInput;
};

export type JoinUsSectionUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: JoinUsSectionUpdateInput;
  /** Unique document search */
  where: JoinUsSectionWhereUniqueInput;
};

export type JoinUsSectionUpsertInput = {
  /** Create document if it didn't exist */
  create: JoinUsSectionCreateInput;
  /** Update document if it exists */
  update: JoinUsSectionUpdateInput;
};

export type JoinUsSectionUpsertLocalizationInput = {
  create: JoinUsSectionCreateLocalizationDataInput;
  locale: Locale;
  update: JoinUsSectionUpdateLocalizationDataInput;
};

export type JoinUsSectionUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<JoinUsSectionUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: JoinUsSectionWhereUniqueInput;
};

export type JoinUsSectionUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: JoinUsSectionUpsertInput;
  /** Unique document search */
  where: JoinUsSectionWhereUniqueInput;
};

/** Identifies documents */
export type JoinUsSectionWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<JoinUsSectionWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<JoinUsSectionWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<JoinUsSectionWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  ctas_every?: InputMaybe<OldButtonWhereInput>;
  ctas_none?: InputMaybe<OldButtonWhereInput>;
  ctas_some?: InputMaybe<OldButtonWhereInput>;
  description?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  description_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  description_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  description_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  description_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  description_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  description_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  description_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  description_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  description_starts_with?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  title?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  title_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  title_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  title_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  title_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  title_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  title_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  title_starts_with?: InputMaybe<Scalars['String']>;
};

/** References JoinUsSection record uniquely */
export type JoinUsSectionWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

/** This model represents the layout of the website. It is not meant to be updated by non-developer and is composed of two main components: The Footer and the navigation */
export type Layout = Node & {
  __typename?: 'Layout';
  /** The time the document was created */
  createdAt: Scalars['DateTime'];
  /** User that created this document */
  createdBy?: Maybe<User>;
  /** Get the document in other stages */
  documentInStages: Array<Layout>;
  footer?: Maybe<Footer>;
  /** List of Layout versions */
  history: Array<Version>;
  /** The unique identifier */
  id: Scalars['ID'];
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<Layout>;
  navigation?: Maybe<Navigation>;
  /** The time the document was published. Null on documents in draft stage. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** User that last published this document */
  publishedBy?: Maybe<User>;
  scheduledIn: Array<ScheduledOperation>;
  /** System stage field */
  stage: Stage;
  /** The time the document was updated */
  updatedAt: Scalars['DateTime'];
  /** User that last updated this document */
  updatedBy?: Maybe<User>;
};


/** This model represents the layout of the website. It is not meant to be updated by non-developer and is composed of two main components: The Footer and the navigation */
export type LayoutCreatedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


/** This model represents the layout of the website. It is not meant to be updated by non-developer and is composed of two main components: The Footer and the navigation */
export type LayoutCreatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


/** This model represents the layout of the website. It is not meant to be updated by non-developer and is composed of two main components: The Footer and the navigation */
export type LayoutDocumentInStagesArgs = {
  includeCurrent?: Scalars['Boolean'];
  inheritLocale?: Scalars['Boolean'];
  stages?: Array<Stage>;
};


/** This model represents the layout of the website. It is not meant to be updated by non-developer and is composed of two main components: The Footer and the navigation */
export type LayoutFooterArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


/** This model represents the layout of the website. It is not meant to be updated by non-developer and is composed of two main components: The Footer and the navigation */
export type LayoutHistoryArgs = {
  limit?: Scalars['Int'];
  skip?: Scalars['Int'];
  stageOverride?: InputMaybe<Stage>;
};


/** This model represents the layout of the website. It is not meant to be updated by non-developer and is composed of two main components: The Footer and the navigation */
export type LayoutLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};


/** This model represents the layout of the website. It is not meant to be updated by non-developer and is composed of two main components: The Footer and the navigation */
export type LayoutNavigationArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


/** This model represents the layout of the website. It is not meant to be updated by non-developer and is composed of two main components: The Footer and the navigation */
export type LayoutPublishedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


/** This model represents the layout of the website. It is not meant to be updated by non-developer and is composed of two main components: The Footer and the navigation */
export type LayoutPublishedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


/** This model represents the layout of the website. It is not meant to be updated by non-developer and is composed of two main components: The Footer and the navigation */
export type LayoutScheduledInArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ScheduledOperationWhereInput>;
};


/** This model represents the layout of the website. It is not meant to be updated by non-developer and is composed of two main components: The Footer and the navigation */
export type LayoutUpdatedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


/** This model represents the layout of the website. It is not meant to be updated by non-developer and is composed of two main components: The Footer and the navigation */
export type LayoutUpdatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};

export type LayoutConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: LayoutWhereUniqueInput;
};

/** A connection to a list of items. */
export type LayoutConnection = {
  __typename?: 'LayoutConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<LayoutEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type LayoutCreateInput = {
  cl6hxwz5p4cl301un2xaxgvxq?: InputMaybe<PageCreateManyInlineInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  footer?: InputMaybe<FooterCreateOneInlineInput>;
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<LayoutCreateLocalizationsInput>;
  navigation?: InputMaybe<NavigationCreateOneInlineInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type LayoutCreateLocalizationDataInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type LayoutCreateLocalizationInput = {
  /** Localization input */
  data: LayoutCreateLocalizationDataInput;
  locale: Locale;
};

export type LayoutCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<LayoutCreateLocalizationInput>>;
};

export type LayoutCreateManyInlineInput = {
  /** Connect multiple existing Layout documents */
  connect?: InputMaybe<Array<LayoutWhereUniqueInput>>;
  /** Create and connect multiple existing Layout documents */
  create?: InputMaybe<Array<LayoutCreateInput>>;
};

export type LayoutCreateOneInlineInput = {
  /** Connect one existing Layout document */
  connect?: InputMaybe<LayoutWhereUniqueInput>;
  /** Create and connect one Layout document */
  create?: InputMaybe<LayoutCreateInput>;
};

/** An edge in a connection. */
export type LayoutEdge = {
  __typename?: 'LayoutEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Layout;
};

/** Identifies documents */
export type LayoutManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<LayoutWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<LayoutWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<LayoutWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  footer?: InputMaybe<FooterWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  navigation?: InputMaybe<NavigationWhereInput>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

export enum LayoutOrderByInput {
  CreatedAtAsc = 'createdAt_ASC',
  CreatedAtDesc = 'createdAt_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  PublishedAtAsc = 'publishedAt_ASC',
  PublishedAtDesc = 'publishedAt_DESC',
  UpdatedAtAsc = 'updatedAt_ASC',
  UpdatedAtDesc = 'updatedAt_DESC'
}

export type LayoutUpdateInput = {
  cl6hxwz5p4cl301un2xaxgvxq?: InputMaybe<PageUpdateManyInlineInput>;
  footer?: InputMaybe<FooterUpdateOneInlineInput>;
  /** Manage document localizations */
  localizations?: InputMaybe<LayoutUpdateLocalizationsInput>;
  navigation?: InputMaybe<NavigationUpdateOneInlineInput>;
};

export type LayoutUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<LayoutCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
};

export type LayoutUpdateManyInlineInput = {
  /** Connect multiple existing Layout documents */
  connect?: InputMaybe<Array<LayoutConnectInput>>;
  /** Create and connect multiple Layout documents */
  create?: InputMaybe<Array<LayoutCreateInput>>;
  /** Delete multiple Layout documents */
  delete?: InputMaybe<Array<LayoutWhereUniqueInput>>;
  /** Disconnect multiple Layout documents */
  disconnect?: InputMaybe<Array<LayoutWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing Layout documents */
  set?: InputMaybe<Array<LayoutWhereUniqueInput>>;
  /** Update multiple Layout documents */
  update?: InputMaybe<Array<LayoutUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple Layout documents */
  upsert?: InputMaybe<Array<LayoutUpsertWithNestedWhereUniqueInput>>;
};

export type LayoutUpdateManyInput = {
  /** No fields in updateMany data input */
  _?: InputMaybe<Scalars['String']>;
};

export type LayoutUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: LayoutUpdateManyInput;
  /** Document search */
  where: LayoutWhereInput;
};

export type LayoutUpdateOneInlineInput = {
  /** Connect existing Layout document */
  connect?: InputMaybe<LayoutWhereUniqueInput>;
  /** Create and connect one Layout document */
  create?: InputMaybe<LayoutCreateInput>;
  /** Delete currently connected Layout document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected Layout document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single Layout document */
  update?: InputMaybe<LayoutUpdateWithNestedWhereUniqueInput>;
  /** Upsert single Layout document */
  upsert?: InputMaybe<LayoutUpsertWithNestedWhereUniqueInput>;
};

export type LayoutUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: LayoutUpdateInput;
  /** Unique document search */
  where: LayoutWhereUniqueInput;
};

export type LayoutUpsertInput = {
  /** Create document if it didn't exist */
  create: LayoutCreateInput;
  /** Update document if it exists */
  update: LayoutUpdateInput;
};

export type LayoutUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: LayoutUpsertInput;
  /** Unique document search */
  where: LayoutWhereUniqueInput;
};

/** Identifies documents */
export type LayoutWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<LayoutWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<LayoutWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<LayoutWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  footer?: InputMaybe<FooterWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  navigation?: InputMaybe<NavigationWhereInput>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

/** References Layout record uniquely */
export type LayoutWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export type Link = {
  __typename?: 'Link';
  href: Scalars['String'];
  /** The unique identifier */
  id: Scalars['ID'];
  isExternal?: Maybe<Scalars['Boolean']>;
  label: Scalars['String'];
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<Link>;
  /** System stage field */
  stage: Stage;
};


export type LinkLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};

export type LinkConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: LinkWhereUniqueInput;
};

/** A connection to a list of items. */
export type LinkConnection = {
  __typename?: 'LinkConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<LinkEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type LinkCreateInput = {
  href: Scalars['String'];
  isExternal?: InputMaybe<Scalars['Boolean']>;
  /** label input for default locale (en) */
  label: Scalars['String'];
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<LinkCreateLocalizationsInput>;
};

export type LinkCreateLocalizationDataInput = {
  label: Scalars['String'];
};

export type LinkCreateLocalizationInput = {
  /** Localization input */
  data: LinkCreateLocalizationDataInput;
  locale: Locale;
};

export type LinkCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<LinkCreateLocalizationInput>>;
};

export type LinkCreateManyInlineInput = {
  /** Create and connect multiple existing Link documents */
  create?: InputMaybe<Array<LinkCreateInput>>;
};

export type LinkCreateOneInlineInput = {
  /** Create and connect one Link document */
  create?: InputMaybe<LinkCreateInput>;
};

export type LinkCreateWithPositionInput = {
  /** Document to create */
  data: LinkCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type LinkEdge = {
  __typename?: 'LinkEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Link;
};

/** Identifies documents */
export type LinkManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<LinkWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<LinkWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<LinkWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  href?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  href_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  href_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  href_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  href_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  href_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  href_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  href_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  href_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  href_starts_with?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  isExternal?: InputMaybe<Scalars['Boolean']>;
  /** All values that are not equal to given value. */
  isExternal_not?: InputMaybe<Scalars['Boolean']>;
};

export enum LinkOrderByInput {
  HrefAsc = 'href_ASC',
  HrefDesc = 'href_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  IsExternalAsc = 'isExternal_ASC',
  IsExternalDesc = 'isExternal_DESC',
  LabelAsc = 'label_ASC',
  LabelDesc = 'label_DESC'
}

export type LinkParent = CarouselSlide | Footer;

export type LinkParentConnectInput = {
  CarouselSlide?: InputMaybe<CarouselSlideConnectInput>;
  Footer?: InputMaybe<FooterConnectInput>;
};

export type LinkParentCreateInput = {
  CarouselSlide?: InputMaybe<CarouselSlideCreateInput>;
  Footer?: InputMaybe<FooterCreateInput>;
};

export type LinkParentCreateManyInlineInput = {
  /** Create and connect multiple existing LinkParent documents */
  create?: InputMaybe<Array<LinkParentCreateInput>>;
};

export type LinkParentCreateOneInlineInput = {
  /** Create and connect one LinkParent document */
  create?: InputMaybe<LinkParentCreateInput>;
};

export type LinkParentCreateWithPositionInput = {
  CarouselSlide?: InputMaybe<CarouselSlideCreateWithPositionInput>;
  Footer?: InputMaybe<FooterCreateWithPositionInput>;
};

export type LinkParentUpdateInput = {
  CarouselSlide?: InputMaybe<CarouselSlideUpdateInput>;
  Footer?: InputMaybe<FooterUpdateInput>;
};

export type LinkParentUpdateManyInlineInput = {
  /** Create and connect multiple LinkParent component instances */
  create?: InputMaybe<Array<LinkParentCreateWithPositionInput>>;
  /** Delete multiple LinkParent documents */
  delete?: InputMaybe<Array<LinkParentWhereUniqueInput>>;
  /** Update multiple LinkParent component instances */
  update?: InputMaybe<Array<LinkParentUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple LinkParent component instances */
  upsert?: InputMaybe<Array<LinkParentUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type LinkParentUpdateManyWithNestedWhereInput = {
  CarouselSlide?: InputMaybe<CarouselSlideUpdateManyWithNestedWhereInput>;
  Footer?: InputMaybe<FooterUpdateManyWithNestedWhereInput>;
};

export type LinkParentUpdateOneInlineInput = {
  /** Create and connect one LinkParent document */
  create?: InputMaybe<LinkParentCreateInput>;
  /** Delete currently connected LinkParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single LinkParent document */
  update?: InputMaybe<LinkParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single LinkParent document */
  upsert?: InputMaybe<LinkParentUpsertWithNestedWhereUniqueInput>;
};

export type LinkParentUpdateWithNestedWhereUniqueAndPositionInput = {
  CarouselSlide?: InputMaybe<CarouselSlideUpdateWithNestedWhereUniqueAndPositionInput>;
  Footer?: InputMaybe<FooterUpdateWithNestedWhereUniqueAndPositionInput>;
};

export type LinkParentUpdateWithNestedWhereUniqueInput = {
  CarouselSlide?: InputMaybe<CarouselSlideUpdateWithNestedWhereUniqueInput>;
  Footer?: InputMaybe<FooterUpdateWithNestedWhereUniqueInput>;
};

export type LinkParentUpsertWithNestedWhereUniqueAndPositionInput = {
  CarouselSlide?: InputMaybe<CarouselSlideUpsertWithNestedWhereUniqueAndPositionInput>;
  Footer?: InputMaybe<FooterUpsertWithNestedWhereUniqueAndPositionInput>;
};

export type LinkParentUpsertWithNestedWhereUniqueInput = {
  CarouselSlide?: InputMaybe<CarouselSlideUpsertWithNestedWhereUniqueInput>;
  Footer?: InputMaybe<FooterUpsertWithNestedWhereUniqueInput>;
};

export type LinkParentWhereInput = {
  CarouselSlide?: InputMaybe<CarouselSlideWhereInput>;
  Footer?: InputMaybe<FooterWhereInput>;
};

export type LinkParentWhereUniqueInput = {
  CarouselSlide?: InputMaybe<CarouselSlideWhereUniqueInput>;
  Footer?: InputMaybe<FooterWhereUniqueInput>;
};

export enum LinkStyle {
  Footer = 'FOOTER'
}

export type LinkUpdateInput = {
  href?: InputMaybe<Scalars['String']>;
  isExternal?: InputMaybe<Scalars['Boolean']>;
  /** label input for default locale (en) */
  label?: InputMaybe<Scalars['String']>;
  /** Manage document localizations */
  localizations?: InputMaybe<LinkUpdateLocalizationsInput>;
};

export type LinkUpdateLocalizationDataInput = {
  label?: InputMaybe<Scalars['String']>;
};

export type LinkUpdateLocalizationInput = {
  data: LinkUpdateLocalizationDataInput;
  locale: Locale;
};

export type LinkUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<LinkCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<LinkUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<LinkUpsertLocalizationInput>>;
};

export type LinkUpdateManyInlineInput = {
  /** Create and connect multiple Link component instances */
  create?: InputMaybe<Array<LinkCreateWithPositionInput>>;
  /** Delete multiple Link documents */
  delete?: InputMaybe<Array<LinkWhereUniqueInput>>;
  /** Update multiple Link component instances */
  update?: InputMaybe<Array<LinkUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple Link component instances */
  upsert?: InputMaybe<Array<LinkUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type LinkUpdateManyInput = {
  isExternal?: InputMaybe<Scalars['Boolean']>;
  /** label input for default locale (en) */
  label?: InputMaybe<Scalars['String']>;
  /** Optional updates to localizations */
  localizations?: InputMaybe<LinkUpdateManyLocalizationsInput>;
};

export type LinkUpdateManyLocalizationDataInput = {
  label?: InputMaybe<Scalars['String']>;
};

export type LinkUpdateManyLocalizationInput = {
  data: LinkUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type LinkUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<LinkUpdateManyLocalizationInput>>;
};

export type LinkUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: LinkUpdateManyInput;
  /** Document search */
  where: LinkWhereInput;
};

export type LinkUpdateOneInlineInput = {
  /** Create and connect one Link document */
  create?: InputMaybe<LinkCreateInput>;
  /** Delete currently connected Link document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single Link document */
  update?: InputMaybe<LinkUpdateWithNestedWhereUniqueInput>;
  /** Upsert single Link document */
  upsert?: InputMaybe<LinkUpsertWithNestedWhereUniqueInput>;
};

export type LinkUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<LinkUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: LinkWhereUniqueInput;
};

export type LinkUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: LinkUpdateInput;
  /** Unique document search */
  where: LinkWhereUniqueInput;
};

export type LinkUpsertInput = {
  /** Create document if it didn't exist */
  create: LinkCreateInput;
  /** Update document if it exists */
  update: LinkUpdateInput;
};

export type LinkUpsertLocalizationInput = {
  create: LinkCreateLocalizationDataInput;
  locale: Locale;
  update: LinkUpdateLocalizationDataInput;
};

export type LinkUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<LinkUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: LinkWhereUniqueInput;
};

export type LinkUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: LinkUpsertInput;
  /** Unique document search */
  where: LinkWhereUniqueInput;
};

/** Identifies documents */
export type LinkWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<LinkWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<LinkWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<LinkWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  href?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  href_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  href_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  href_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  href_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  href_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  href_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  href_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  href_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  href_starts_with?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  isExternal?: InputMaybe<Scalars['Boolean']>;
  /** All values that are not equal to given value. */
  isExternal_not?: InputMaybe<Scalars['Boolean']>;
  label?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  label_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  label_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  label_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  label_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  label_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  label_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  label_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  label_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  label_starts_with?: InputMaybe<Scalars['String']>;
};

/** References Link record uniquely */
export type LinkWhereUniqueInput = {
  href?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
};

/** Locale system enumeration */
export enum Locale {
  De = 'de',
  /** System locale */
  En = 'en'
}

/** Representing a geolocation point with latitude and longitude */
export type Location = {
  __typename?: 'Location';
  distance: Scalars['Float'];
  latitude: Scalars['Float'];
  longitude: Scalars['Float'];
};


/** Representing a geolocation point with latitude and longitude */
export type LocationDistanceArgs = {
  from: LocationInput;
};

/** Input for a geolocation point with latitude and longitude */
export type LocationInput = {
  latitude: Scalars['Float'];
  longitude: Scalars['Float'];
};

export type MdText = {
  __typename?: 'MdText';
  /** The unique identifier */
  id: Scalars['ID'];
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<MdText>;
  /** System stage field */
  stage: Stage;
  style?: Maybe<Style>;
  value: Scalars['String'];
};


export type MdTextLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};


export type MdTextStyleArgs = {
  locales?: InputMaybe<Array<Locale>>;
};

export type MdTextConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: MdTextWhereUniqueInput;
};

/** A connection to a list of items. */
export type MdTextConnection = {
  __typename?: 'MdTextConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<MdTextEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type MdTextCreateInput = {
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<MdTextCreateLocalizationsInput>;
  style?: InputMaybe<StyleCreateOneInlineInput>;
  /** value input for default locale (en) */
  value: Scalars['String'];
};

export type MdTextCreateLocalizationDataInput = {
  value: Scalars['String'];
};

export type MdTextCreateLocalizationInput = {
  /** Localization input */
  data: MdTextCreateLocalizationDataInput;
  locale: Locale;
};

export type MdTextCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<MdTextCreateLocalizationInput>>;
};

export type MdTextCreateManyInlineInput = {
  /** Create and connect multiple existing MdText documents */
  create?: InputMaybe<Array<MdTextCreateInput>>;
};

export type MdTextCreateOneInlineInput = {
  /** Create and connect one MdText document */
  create?: InputMaybe<MdTextCreateInput>;
};

export type MdTextCreateWithPositionInput = {
  /** Document to create */
  data: MdTextCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type MdTextEdge = {
  __typename?: 'MdTextEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: MdText;
};

/** Identifies documents */
export type MdTextManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<MdTextWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<MdTextWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<MdTextWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  style?: InputMaybe<StyleWhereInput>;
};

export enum MdTextOrderByInput {
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  ValueAsc = 'value_ASC',
  ValueDesc = 'value_DESC'
}

export type MdTextParent = Container;

export type MdTextParentConnectInput = {
  Container?: InputMaybe<ContainerConnectInput>;
};

export type MdTextParentCreateInput = {
  Container?: InputMaybe<ContainerCreateInput>;
};

export type MdTextParentCreateManyInlineInput = {
  /** Connect multiple existing MdTextParent documents */
  connect?: InputMaybe<Array<MdTextParentWhereUniqueInput>>;
  /** Create and connect multiple existing MdTextParent documents */
  create?: InputMaybe<Array<MdTextParentCreateInput>>;
};

export type MdTextParentCreateOneInlineInput = {
  /** Connect one existing MdTextParent document */
  connect?: InputMaybe<MdTextParentWhereUniqueInput>;
  /** Create and connect one MdTextParent document */
  create?: InputMaybe<MdTextParentCreateInput>;
};

export type MdTextParentUpdateInput = {
  Container?: InputMaybe<ContainerUpdateInput>;
};

export type MdTextParentUpdateManyInlineInput = {
  /** Connect multiple existing MdTextParent documents */
  connect?: InputMaybe<Array<MdTextParentConnectInput>>;
  /** Create and connect multiple MdTextParent documents */
  create?: InputMaybe<Array<MdTextParentCreateInput>>;
  /** Delete multiple MdTextParent documents */
  delete?: InputMaybe<Array<MdTextParentWhereUniqueInput>>;
  /** Disconnect multiple MdTextParent documents */
  disconnect?: InputMaybe<Array<MdTextParentWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing MdTextParent documents */
  set?: InputMaybe<Array<MdTextParentWhereUniqueInput>>;
  /** Update multiple MdTextParent documents */
  update?: InputMaybe<Array<MdTextParentUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple MdTextParent documents */
  upsert?: InputMaybe<Array<MdTextParentUpsertWithNestedWhereUniqueInput>>;
};

export type MdTextParentUpdateManyWithNestedWhereInput = {
  Container?: InputMaybe<ContainerUpdateManyWithNestedWhereInput>;
};

export type MdTextParentUpdateOneInlineInput = {
  /** Connect existing MdTextParent document */
  connect?: InputMaybe<MdTextParentWhereUniqueInput>;
  /** Create and connect one MdTextParent document */
  create?: InputMaybe<MdTextParentCreateInput>;
  /** Delete currently connected MdTextParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected MdTextParent document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single MdTextParent document */
  update?: InputMaybe<MdTextParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single MdTextParent document */
  upsert?: InputMaybe<MdTextParentUpsertWithNestedWhereUniqueInput>;
};

export type MdTextParentUpdateWithNestedWhereUniqueInput = {
  Container?: InputMaybe<ContainerUpdateWithNestedWhereUniqueInput>;
};

export type MdTextParentUpsertWithNestedWhereUniqueInput = {
  Container?: InputMaybe<ContainerUpsertWithNestedWhereUniqueInput>;
};

export type MdTextParentWhereInput = {
  Container?: InputMaybe<ContainerWhereInput>;
};

export type MdTextParentWhereUniqueInput = {
  Container?: InputMaybe<ContainerWhereUniqueInput>;
};

export type MdTextUpdateInput = {
  /** Manage document localizations */
  localizations?: InputMaybe<MdTextUpdateLocalizationsInput>;
  style?: InputMaybe<StyleUpdateOneInlineInput>;
  /** value input for default locale (en) */
  value?: InputMaybe<Scalars['String']>;
};

export type MdTextUpdateLocalizationDataInput = {
  value?: InputMaybe<Scalars['String']>;
};

export type MdTextUpdateLocalizationInput = {
  data: MdTextUpdateLocalizationDataInput;
  locale: Locale;
};

export type MdTextUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<MdTextCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<MdTextUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<MdTextUpsertLocalizationInput>>;
};

export type MdTextUpdateManyInlineInput = {
  /** Create and connect multiple MdText component instances */
  create?: InputMaybe<Array<MdTextCreateWithPositionInput>>;
  /** Delete multiple MdText documents */
  delete?: InputMaybe<Array<MdTextWhereUniqueInput>>;
  /** Update multiple MdText component instances */
  update?: InputMaybe<Array<MdTextUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple MdText component instances */
  upsert?: InputMaybe<Array<MdTextUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type MdTextUpdateManyInput = {
  /** Optional updates to localizations */
  localizations?: InputMaybe<MdTextUpdateManyLocalizationsInput>;
  /** value input for default locale (en) */
  value?: InputMaybe<Scalars['String']>;
};

export type MdTextUpdateManyLocalizationDataInput = {
  value?: InputMaybe<Scalars['String']>;
};

export type MdTextUpdateManyLocalizationInput = {
  data: MdTextUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type MdTextUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<MdTextUpdateManyLocalizationInput>>;
};

export type MdTextUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: MdTextUpdateManyInput;
  /** Document search */
  where: MdTextWhereInput;
};

export type MdTextUpdateOneInlineInput = {
  /** Create and connect one MdText document */
  create?: InputMaybe<MdTextCreateInput>;
  /** Delete currently connected MdText document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single MdText document */
  update?: InputMaybe<MdTextUpdateWithNestedWhereUniqueInput>;
  /** Upsert single MdText document */
  upsert?: InputMaybe<MdTextUpsertWithNestedWhereUniqueInput>;
};

export type MdTextUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<MdTextUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: MdTextWhereUniqueInput;
};

export type MdTextUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: MdTextUpdateInput;
  /** Unique document search */
  where: MdTextWhereUniqueInput;
};

export type MdTextUpsertInput = {
  /** Create document if it didn't exist */
  create: MdTextCreateInput;
  /** Update document if it exists */
  update: MdTextUpdateInput;
};

export type MdTextUpsertLocalizationInput = {
  create: MdTextCreateLocalizationDataInput;
  locale: Locale;
  update: MdTextUpdateLocalizationDataInput;
};

export type MdTextUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<MdTextUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: MdTextWhereUniqueInput;
};

export type MdTextUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: MdTextUpsertInput;
  /** Unique document search */
  where: MdTextWhereUniqueInput;
};

/** Identifies documents */
export type MdTextWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<MdTextWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<MdTextWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<MdTextWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  style?: InputMaybe<StyleWhereInput>;
  value?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  value_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  value_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  value_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  value_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  value_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  value_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  value_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  value_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  value_starts_with?: InputMaybe<Scalars['String']>;
};

/** References MdText record uniquely */
export type MdTextWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export type Mutation = {
  __typename?: 'Mutation';
  /**
   * Create one asset
   * @deprecated Asset mutations will be overhauled soon
   */
  createAsset?: Maybe<Asset>;
  /** Create one button */
  createButton?: Maybe<Button>;
  /** Create one card */
  createCard?: Maybe<Card>;
  /** Create one contactCard */
  createContactCard?: Maybe<ContactCard>;
  /** Create one container */
  createContainer?: Maybe<Container>;
  /** Create one event */
  createEvent?: Maybe<Event>;
  /** Create one form */
  createForm?: Maybe<Form>;
  /** Create one layout */
  createLayout?: Maybe<Layout>;
  /** Create one page */
  createPage?: Maybe<Page>;
  /** Create one person */
  createPerson?: Maybe<Person>;
  /** Create one project */
  createProject?: Maybe<Project>;
  /** Create one projectCategory */
  createProjectCategory?: Maybe<ProjectCategory>;
  /** Create one richTextWrapper */
  createRichTextWrapper?: Maybe<RichTextWrapper>;
  /** Create one scheduledRelease */
  createScheduledRelease?: Maybe<ScheduledRelease>;
  /** Create one service */
  createService?: Maybe<Service>;
  /** Create one sponsor */
  createSponsor?: Maybe<Sponsor>;
  /** Delete one asset from _all_ existing stages. Returns deleted document. */
  deleteAsset?: Maybe<Asset>;
  /** Delete one button from _all_ existing stages. Returns deleted document. */
  deleteButton?: Maybe<Button>;
  /** Delete one card from _all_ existing stages. Returns deleted document. */
  deleteCard?: Maybe<Card>;
  /** Delete one contactCard from _all_ existing stages. Returns deleted document. */
  deleteContactCard?: Maybe<ContactCard>;
  /** Delete one container from _all_ existing stages. Returns deleted document. */
  deleteContainer?: Maybe<Container>;
  /** Delete one event from _all_ existing stages. Returns deleted document. */
  deleteEvent?: Maybe<Event>;
  /** Delete one form from _all_ existing stages. Returns deleted document. */
  deleteForm?: Maybe<Form>;
  /** Delete one layout from _all_ existing stages. Returns deleted document. */
  deleteLayout?: Maybe<Layout>;
  /**
   * Delete many Asset documents
   * @deprecated Please use the new paginated many mutation (deleteManyAssetsConnection)
   */
  deleteManyAssets: BatchPayload;
  /** Delete many Asset documents, return deleted documents */
  deleteManyAssetsConnection: AssetConnection;
  /**
   * Delete many Button documents
   * @deprecated Please use the new paginated many mutation (deleteManyButtonsConnection)
   */
  deleteManyButtons: BatchPayload;
  /** Delete many Button documents, return deleted documents */
  deleteManyButtonsConnection: ButtonConnection;
  /**
   * Delete many Card documents
   * @deprecated Please use the new paginated many mutation (deleteManyCardsConnection)
   */
  deleteManyCards: BatchPayload;
  /** Delete many Card documents, return deleted documents */
  deleteManyCardsConnection: CardConnection;
  /**
   * Delete many ContactCard documents
   * @deprecated Please use the new paginated many mutation (deleteManyContactCardsConnection)
   */
  deleteManyContactCards: BatchPayload;
  /** Delete many ContactCard documents, return deleted documents */
  deleteManyContactCardsConnection: ContactCardConnection;
  /**
   * Delete many Container documents
   * @deprecated Please use the new paginated many mutation (deleteManyContainersConnection)
   */
  deleteManyContainers: BatchPayload;
  /** Delete many Container documents, return deleted documents */
  deleteManyContainersConnection: ContainerConnection;
  /**
   * Delete many Event documents
   * @deprecated Please use the new paginated many mutation (deleteManyEventsConnection)
   */
  deleteManyEvents: BatchPayload;
  /** Delete many Event documents, return deleted documents */
  deleteManyEventsConnection: EventConnection;
  /**
   * Delete many Form documents
   * @deprecated Please use the new paginated many mutation (deleteManyFormsConnection)
   */
  deleteManyForms: BatchPayload;
  /** Delete many Form documents, return deleted documents */
  deleteManyFormsConnection: FormConnection;
  /**
   * Delete many Layout documents
   * @deprecated Please use the new paginated many mutation (deleteManyLayoutsConnection)
   */
  deleteManyLayouts: BatchPayload;
  /** Delete many Layout documents, return deleted documents */
  deleteManyLayoutsConnection: LayoutConnection;
  /**
   * Delete many Page documents
   * @deprecated Please use the new paginated many mutation (deleteManyPagesConnection)
   */
  deleteManyPages: BatchPayload;
  /** Delete many Page documents, return deleted documents */
  deleteManyPagesConnection: PageConnection;
  /**
   * Delete many Person documents
   * @deprecated Please use the new paginated many mutation (deleteManyPeopleConnection)
   */
  deleteManyPeople: BatchPayload;
  /** Delete many Person documents, return deleted documents */
  deleteManyPeopleConnection: PersonConnection;
  /**
   * Delete many ProjectCategory documents
   * @deprecated Please use the new paginated many mutation (deleteManyProjectCategoriesConnection)
   */
  deleteManyProjectCategories: BatchPayload;
  /** Delete many ProjectCategory documents, return deleted documents */
  deleteManyProjectCategoriesConnection: ProjectCategoryConnection;
  /**
   * Delete many Project documents
   * @deprecated Please use the new paginated many mutation (deleteManyProjectsConnection)
   */
  deleteManyProjects: BatchPayload;
  /** Delete many Project documents, return deleted documents */
  deleteManyProjectsConnection: ProjectConnection;
  /**
   * Delete many RichTextWrapper documents
   * @deprecated Please use the new paginated many mutation (deleteManyRichTextWrappersConnection)
   */
  deleteManyRichTextWrappers: BatchPayload;
  /** Delete many RichTextWrapper documents, return deleted documents */
  deleteManyRichTextWrappersConnection: RichTextWrapperConnection;
  /**
   * Delete many Service documents
   * @deprecated Please use the new paginated many mutation (deleteManyServicesConnection)
   */
  deleteManyServices: BatchPayload;
  /** Delete many Service documents, return deleted documents */
  deleteManyServicesConnection: ServiceConnection;
  /**
   * Delete many Sponsor documents
   * @deprecated Please use the new paginated many mutation (deleteManySponsorsConnection)
   */
  deleteManySponsors: BatchPayload;
  /** Delete many Sponsor documents, return deleted documents */
  deleteManySponsorsConnection: SponsorConnection;
  /** Delete one page from _all_ existing stages. Returns deleted document. */
  deletePage?: Maybe<Page>;
  /** Delete one person from _all_ existing stages. Returns deleted document. */
  deletePerson?: Maybe<Person>;
  /** Delete one project from _all_ existing stages. Returns deleted document. */
  deleteProject?: Maybe<Project>;
  /** Delete one projectCategory from _all_ existing stages. Returns deleted document. */
  deleteProjectCategory?: Maybe<ProjectCategory>;
  /** Delete one richTextWrapper from _all_ existing stages. Returns deleted document. */
  deleteRichTextWrapper?: Maybe<RichTextWrapper>;
  /** Delete and return scheduled operation */
  deleteScheduledOperation?: Maybe<ScheduledOperation>;
  /** Delete one scheduledRelease from _all_ existing stages. Returns deleted document. */
  deleteScheduledRelease?: Maybe<ScheduledRelease>;
  /** Delete one service from _all_ existing stages. Returns deleted document. */
  deleteService?: Maybe<Service>;
  /** Delete one sponsor from _all_ existing stages. Returns deleted document. */
  deleteSponsor?: Maybe<Sponsor>;
  /** Publish one asset */
  publishAsset?: Maybe<Asset>;
  /** Publish one button */
  publishButton?: Maybe<Button>;
  /** Publish one card */
  publishCard?: Maybe<Card>;
  /** Publish one contactCard */
  publishContactCard?: Maybe<ContactCard>;
  /** Publish one container */
  publishContainer?: Maybe<Container>;
  /** Publish one event */
  publishEvent?: Maybe<Event>;
  /** Publish one form */
  publishForm?: Maybe<Form>;
  /** Publish one layout */
  publishLayout?: Maybe<Layout>;
  /**
   * Publish many Asset documents
   * @deprecated Please use the new paginated many mutation (publishManyAssetsConnection)
   */
  publishManyAssets: BatchPayload;
  /** Publish many Asset documents */
  publishManyAssetsConnection: AssetConnection;
  /**
   * Publish many Button documents
   * @deprecated Please use the new paginated many mutation (publishManyButtonsConnection)
   */
  publishManyButtons: BatchPayload;
  /** Publish many Button documents */
  publishManyButtonsConnection: ButtonConnection;
  /**
   * Publish many Card documents
   * @deprecated Please use the new paginated many mutation (publishManyCardsConnection)
   */
  publishManyCards: BatchPayload;
  /** Publish many Card documents */
  publishManyCardsConnection: CardConnection;
  /**
   * Publish many ContactCard documents
   * @deprecated Please use the new paginated many mutation (publishManyContactCardsConnection)
   */
  publishManyContactCards: BatchPayload;
  /** Publish many ContactCard documents */
  publishManyContactCardsConnection: ContactCardConnection;
  /**
   * Publish many Container documents
   * @deprecated Please use the new paginated many mutation (publishManyContainersConnection)
   */
  publishManyContainers: BatchPayload;
  /** Publish many Container documents */
  publishManyContainersConnection: ContainerConnection;
  /**
   * Publish many Event documents
   * @deprecated Please use the new paginated many mutation (publishManyEventsConnection)
   */
  publishManyEvents: BatchPayload;
  /** Publish many Event documents */
  publishManyEventsConnection: EventConnection;
  /**
   * Publish many Form documents
   * @deprecated Please use the new paginated many mutation (publishManyFormsConnection)
   */
  publishManyForms: BatchPayload;
  /** Publish many Form documents */
  publishManyFormsConnection: FormConnection;
  /**
   * Publish many Layout documents
   * @deprecated Please use the new paginated many mutation (publishManyLayoutsConnection)
   */
  publishManyLayouts: BatchPayload;
  /** Publish many Layout documents */
  publishManyLayoutsConnection: LayoutConnection;
  /**
   * Publish many Page documents
   * @deprecated Please use the new paginated many mutation (publishManyPagesConnection)
   */
  publishManyPages: BatchPayload;
  /** Publish many Page documents */
  publishManyPagesConnection: PageConnection;
  /**
   * Publish many Person documents
   * @deprecated Please use the new paginated many mutation (publishManyPeopleConnection)
   */
  publishManyPeople: BatchPayload;
  /** Publish many Person documents */
  publishManyPeopleConnection: PersonConnection;
  /**
   * Publish many ProjectCategory documents
   * @deprecated Please use the new paginated many mutation (publishManyProjectCategoriesConnection)
   */
  publishManyProjectCategories: BatchPayload;
  /** Publish many ProjectCategory documents */
  publishManyProjectCategoriesConnection: ProjectCategoryConnection;
  /**
   * Publish many Project documents
   * @deprecated Please use the new paginated many mutation (publishManyProjectsConnection)
   */
  publishManyProjects: BatchPayload;
  /** Publish many Project documents */
  publishManyProjectsConnection: ProjectConnection;
  /**
   * Publish many RichTextWrapper documents
   * @deprecated Please use the new paginated many mutation (publishManyRichTextWrappersConnection)
   */
  publishManyRichTextWrappers: BatchPayload;
  /** Publish many RichTextWrapper documents */
  publishManyRichTextWrappersConnection: RichTextWrapperConnection;
  /**
   * Publish many Service documents
   * @deprecated Please use the new paginated many mutation (publishManyServicesConnection)
   */
  publishManyServices: BatchPayload;
  /** Publish many Service documents */
  publishManyServicesConnection: ServiceConnection;
  /**
   * Publish many Sponsor documents
   * @deprecated Please use the new paginated many mutation (publishManySponsorsConnection)
   */
  publishManySponsors: BatchPayload;
  /** Publish many Sponsor documents */
  publishManySponsorsConnection: SponsorConnection;
  /** Publish one page */
  publishPage?: Maybe<Page>;
  /** Publish one person */
  publishPerson?: Maybe<Person>;
  /** Publish one project */
  publishProject?: Maybe<Project>;
  /** Publish one projectCategory */
  publishProjectCategory?: Maybe<ProjectCategory>;
  /** Publish one richTextWrapper */
  publishRichTextWrapper?: Maybe<RichTextWrapper>;
  /** Publish one service */
  publishService?: Maybe<Service>;
  /** Publish one sponsor */
  publishSponsor?: Maybe<Sponsor>;
  /** Schedule to publish one asset */
  schedulePublishAsset?: Maybe<Asset>;
  /** Schedule to publish one button */
  schedulePublishButton?: Maybe<Button>;
  /** Schedule to publish one card */
  schedulePublishCard?: Maybe<Card>;
  /** Schedule to publish one contactCard */
  schedulePublishContactCard?: Maybe<ContactCard>;
  /** Schedule to publish one container */
  schedulePublishContainer?: Maybe<Container>;
  /** Schedule to publish one event */
  schedulePublishEvent?: Maybe<Event>;
  /** Schedule to publish one form */
  schedulePublishForm?: Maybe<Form>;
  /** Schedule to publish one layout */
  schedulePublishLayout?: Maybe<Layout>;
  /** Schedule to publish one page */
  schedulePublishPage?: Maybe<Page>;
  /** Schedule to publish one person */
  schedulePublishPerson?: Maybe<Person>;
  /** Schedule to publish one project */
  schedulePublishProject?: Maybe<Project>;
  /** Schedule to publish one projectCategory */
  schedulePublishProjectCategory?: Maybe<ProjectCategory>;
  /** Schedule to publish one richTextWrapper */
  schedulePublishRichTextWrapper?: Maybe<RichTextWrapper>;
  /** Schedule to publish one service */
  schedulePublishService?: Maybe<Service>;
  /** Schedule to publish one sponsor */
  schedulePublishSponsor?: Maybe<Sponsor>;
  /** Unpublish one asset from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  scheduleUnpublishAsset?: Maybe<Asset>;
  /** Unpublish one button from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  scheduleUnpublishButton?: Maybe<Button>;
  /** Unpublish one card from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  scheduleUnpublishCard?: Maybe<Card>;
  /** Unpublish one contactCard from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  scheduleUnpublishContactCard?: Maybe<ContactCard>;
  /** Unpublish one container from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  scheduleUnpublishContainer?: Maybe<Container>;
  /** Unpublish one event from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  scheduleUnpublishEvent?: Maybe<Event>;
  /** Unpublish one form from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  scheduleUnpublishForm?: Maybe<Form>;
  /** Unpublish one layout from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  scheduleUnpublishLayout?: Maybe<Layout>;
  /** Unpublish one page from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  scheduleUnpublishPage?: Maybe<Page>;
  /** Unpublish one person from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  scheduleUnpublishPerson?: Maybe<Person>;
  /** Unpublish one project from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  scheduleUnpublishProject?: Maybe<Project>;
  /** Unpublish one projectCategory from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  scheduleUnpublishProjectCategory?: Maybe<ProjectCategory>;
  /** Unpublish one richTextWrapper from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  scheduleUnpublishRichTextWrapper?: Maybe<RichTextWrapper>;
  /** Unpublish one service from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  scheduleUnpublishService?: Maybe<Service>;
  /** Unpublish one sponsor from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  scheduleUnpublishSponsor?: Maybe<Sponsor>;
  /** Unpublish one asset from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  unpublishAsset?: Maybe<Asset>;
  /** Unpublish one button from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  unpublishButton?: Maybe<Button>;
  /** Unpublish one card from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  unpublishCard?: Maybe<Card>;
  /** Unpublish one contactCard from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  unpublishContactCard?: Maybe<ContactCard>;
  /** Unpublish one container from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  unpublishContainer?: Maybe<Container>;
  /** Unpublish one event from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  unpublishEvent?: Maybe<Event>;
  /** Unpublish one form from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  unpublishForm?: Maybe<Form>;
  /** Unpublish one layout from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  unpublishLayout?: Maybe<Layout>;
  /**
   * Unpublish many Asset documents
   * @deprecated Please use the new paginated many mutation (unpublishManyAssetsConnection)
   */
  unpublishManyAssets: BatchPayload;
  /** Find many Asset documents that match criteria in specified stage and unpublish from target stages */
  unpublishManyAssetsConnection: AssetConnection;
  /**
   * Unpublish many Button documents
   * @deprecated Please use the new paginated many mutation (unpublishManyButtonsConnection)
   */
  unpublishManyButtons: BatchPayload;
  /** Find many Button documents that match criteria in specified stage and unpublish from target stages */
  unpublishManyButtonsConnection: ButtonConnection;
  /**
   * Unpublish many Card documents
   * @deprecated Please use the new paginated many mutation (unpublishManyCardsConnection)
   */
  unpublishManyCards: BatchPayload;
  /** Find many Card documents that match criteria in specified stage and unpublish from target stages */
  unpublishManyCardsConnection: CardConnection;
  /**
   * Unpublish many ContactCard documents
   * @deprecated Please use the new paginated many mutation (unpublishManyContactCardsConnection)
   */
  unpublishManyContactCards: BatchPayload;
  /** Find many ContactCard documents that match criteria in specified stage and unpublish from target stages */
  unpublishManyContactCardsConnection: ContactCardConnection;
  /**
   * Unpublish many Container documents
   * @deprecated Please use the new paginated many mutation (unpublishManyContainersConnection)
   */
  unpublishManyContainers: BatchPayload;
  /** Find many Container documents that match criteria in specified stage and unpublish from target stages */
  unpublishManyContainersConnection: ContainerConnection;
  /**
   * Unpublish many Event documents
   * @deprecated Please use the new paginated many mutation (unpublishManyEventsConnection)
   */
  unpublishManyEvents: BatchPayload;
  /** Find many Event documents that match criteria in specified stage and unpublish from target stages */
  unpublishManyEventsConnection: EventConnection;
  /**
   * Unpublish many Form documents
   * @deprecated Please use the new paginated many mutation (unpublishManyFormsConnection)
   */
  unpublishManyForms: BatchPayload;
  /** Find many Form documents that match criteria in specified stage and unpublish from target stages */
  unpublishManyFormsConnection: FormConnection;
  /**
   * Unpublish many Layout documents
   * @deprecated Please use the new paginated many mutation (unpublishManyLayoutsConnection)
   */
  unpublishManyLayouts: BatchPayload;
  /** Find many Layout documents that match criteria in specified stage and unpublish from target stages */
  unpublishManyLayoutsConnection: LayoutConnection;
  /**
   * Unpublish many Page documents
   * @deprecated Please use the new paginated many mutation (unpublishManyPagesConnection)
   */
  unpublishManyPages: BatchPayload;
  /** Find many Page documents that match criteria in specified stage and unpublish from target stages */
  unpublishManyPagesConnection: PageConnection;
  /**
   * Unpublish many Person documents
   * @deprecated Please use the new paginated many mutation (unpublishManyPeopleConnection)
   */
  unpublishManyPeople: BatchPayload;
  /** Find many Person documents that match criteria in specified stage and unpublish from target stages */
  unpublishManyPeopleConnection: PersonConnection;
  /**
   * Unpublish many ProjectCategory documents
   * @deprecated Please use the new paginated many mutation (unpublishManyProjectCategoriesConnection)
   */
  unpublishManyProjectCategories: BatchPayload;
  /** Find many ProjectCategory documents that match criteria in specified stage and unpublish from target stages */
  unpublishManyProjectCategoriesConnection: ProjectCategoryConnection;
  /**
   * Unpublish many Project documents
   * @deprecated Please use the new paginated many mutation (unpublishManyProjectsConnection)
   */
  unpublishManyProjects: BatchPayload;
  /** Find many Project documents that match criteria in specified stage and unpublish from target stages */
  unpublishManyProjectsConnection: ProjectConnection;
  /**
   * Unpublish many RichTextWrapper documents
   * @deprecated Please use the new paginated many mutation (unpublishManyRichTextWrappersConnection)
   */
  unpublishManyRichTextWrappers: BatchPayload;
  /** Find many RichTextWrapper documents that match criteria in specified stage and unpublish from target stages */
  unpublishManyRichTextWrappersConnection: RichTextWrapperConnection;
  /**
   * Unpublish many Service documents
   * @deprecated Please use the new paginated many mutation (unpublishManyServicesConnection)
   */
  unpublishManyServices: BatchPayload;
  /** Find many Service documents that match criteria in specified stage and unpublish from target stages */
  unpublishManyServicesConnection: ServiceConnection;
  /**
   * Unpublish many Sponsor documents
   * @deprecated Please use the new paginated many mutation (unpublishManySponsorsConnection)
   */
  unpublishManySponsors: BatchPayload;
  /** Find many Sponsor documents that match criteria in specified stage and unpublish from target stages */
  unpublishManySponsorsConnection: SponsorConnection;
  /** Unpublish one page from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  unpublishPage?: Maybe<Page>;
  /** Unpublish one person from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  unpublishPerson?: Maybe<Person>;
  /** Unpublish one project from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  unpublishProject?: Maybe<Project>;
  /** Unpublish one projectCategory from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  unpublishProjectCategory?: Maybe<ProjectCategory>;
  /** Unpublish one richTextWrapper from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  unpublishRichTextWrapper?: Maybe<RichTextWrapper>;
  /** Unpublish one service from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  unpublishService?: Maybe<Service>;
  /** Unpublish one sponsor from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only. */
  unpublishSponsor?: Maybe<Sponsor>;
  /** Update one asset */
  updateAsset?: Maybe<Asset>;
  /** Update one button */
  updateButton?: Maybe<Button>;
  /** Update one card */
  updateCard?: Maybe<Card>;
  /** Update one contactCard */
  updateContactCard?: Maybe<ContactCard>;
  /** Update one container */
  updateContainer?: Maybe<Container>;
  /** Update one event */
  updateEvent?: Maybe<Event>;
  /** Update one form */
  updateForm?: Maybe<Form>;
  /** Update one layout */
  updateLayout?: Maybe<Layout>;
  /**
   * Update many assets
   * @deprecated Please use the new paginated many mutation (updateManyAssetsConnection)
   */
  updateManyAssets: BatchPayload;
  /** Update many Asset documents */
  updateManyAssetsConnection: AssetConnection;
  /**
   * Update many buttons
   * @deprecated Please use the new paginated many mutation (updateManyButtonsConnection)
   */
  updateManyButtons: BatchPayload;
  /** Update many Button documents */
  updateManyButtonsConnection: ButtonConnection;
  /**
   * Update many cards
   * @deprecated Please use the new paginated many mutation (updateManyCardsConnection)
   */
  updateManyCards: BatchPayload;
  /** Update many Card documents */
  updateManyCardsConnection: CardConnection;
  /**
   * Update many contactCards
   * @deprecated Please use the new paginated many mutation (updateManyContactCardsConnection)
   */
  updateManyContactCards: BatchPayload;
  /** Update many ContactCard documents */
  updateManyContactCardsConnection: ContactCardConnection;
  /**
   * Update many containers
   * @deprecated Please use the new paginated many mutation (updateManyContainersConnection)
   */
  updateManyContainers: BatchPayload;
  /** Update many Container documents */
  updateManyContainersConnection: ContainerConnection;
  /**
   * Update many events
   * @deprecated Please use the new paginated many mutation (updateManyEventsConnection)
   */
  updateManyEvents: BatchPayload;
  /** Update many Event documents */
  updateManyEventsConnection: EventConnection;
  /**
   * Update many forms
   * @deprecated Please use the new paginated many mutation (updateManyFormsConnection)
   */
  updateManyForms: BatchPayload;
  /** Update many Form documents */
  updateManyFormsConnection: FormConnection;
  /**
   * Update many layouts
   * @deprecated Please use the new paginated many mutation (updateManyLayoutsConnection)
   */
  updateManyLayouts: BatchPayload;
  /** Update many Layout documents */
  updateManyLayoutsConnection: LayoutConnection;
  /**
   * Update many pages
   * @deprecated Please use the new paginated many mutation (updateManyPagesConnection)
   */
  updateManyPages: BatchPayload;
  /** Update many Page documents */
  updateManyPagesConnection: PageConnection;
  /**
   * Update many people
   * @deprecated Please use the new paginated many mutation (updateManyPeopleConnection)
   */
  updateManyPeople: BatchPayload;
  /** Update many Person documents */
  updateManyPeopleConnection: PersonConnection;
  /**
   * Update many projectCategories
   * @deprecated Please use the new paginated many mutation (updateManyProjectCategoriesConnection)
   */
  updateManyProjectCategories: BatchPayload;
  /** Update many ProjectCategory documents */
  updateManyProjectCategoriesConnection: ProjectCategoryConnection;
  /**
   * Update many projects
   * @deprecated Please use the new paginated many mutation (updateManyProjectsConnection)
   */
  updateManyProjects: BatchPayload;
  /** Update many Project documents */
  updateManyProjectsConnection: ProjectConnection;
  /**
   * Update many richTextWrappers
   * @deprecated Please use the new paginated many mutation (updateManyRichTextWrappersConnection)
   */
  updateManyRichTextWrappers: BatchPayload;
  /** Update many RichTextWrapper documents */
  updateManyRichTextWrappersConnection: RichTextWrapperConnection;
  /**
   * Update many services
   * @deprecated Please use the new paginated many mutation (updateManyServicesConnection)
   */
  updateManyServices: BatchPayload;
  /** Update many Service documents */
  updateManyServicesConnection: ServiceConnection;
  /**
   * Update many sponsors
   * @deprecated Please use the new paginated many mutation (updateManySponsorsConnection)
   */
  updateManySponsors: BatchPayload;
  /** Update many Sponsor documents */
  updateManySponsorsConnection: SponsorConnection;
  /** Update one page */
  updatePage?: Maybe<Page>;
  /** Update one person */
  updatePerson?: Maybe<Person>;
  /** Update one project */
  updateProject?: Maybe<Project>;
  /** Update one projectCategory */
  updateProjectCategory?: Maybe<ProjectCategory>;
  /** Update one richTextWrapper */
  updateRichTextWrapper?: Maybe<RichTextWrapper>;
  /** Update one scheduledRelease */
  updateScheduledRelease?: Maybe<ScheduledRelease>;
  /** Update one service */
  updateService?: Maybe<Service>;
  /** Update one sponsor */
  updateSponsor?: Maybe<Sponsor>;
  /** Upsert one asset */
  upsertAsset?: Maybe<Asset>;
  /** Upsert one button */
  upsertButton?: Maybe<Button>;
  /** Upsert one card */
  upsertCard?: Maybe<Card>;
  /** Upsert one contactCard */
  upsertContactCard?: Maybe<ContactCard>;
  /** Upsert one container */
  upsertContainer?: Maybe<Container>;
  /** Upsert one event */
  upsertEvent?: Maybe<Event>;
  /** Upsert one form */
  upsertForm?: Maybe<Form>;
  /** Upsert one layout */
  upsertLayout?: Maybe<Layout>;
  /** Upsert one page */
  upsertPage?: Maybe<Page>;
  /** Upsert one person */
  upsertPerson?: Maybe<Person>;
  /** Upsert one project */
  upsertProject?: Maybe<Project>;
  /** Upsert one projectCategory */
  upsertProjectCategory?: Maybe<ProjectCategory>;
  /** Upsert one richTextWrapper */
  upsertRichTextWrapper?: Maybe<RichTextWrapper>;
  /** Upsert one service */
  upsertService?: Maybe<Service>;
  /** Upsert one sponsor */
  upsertSponsor?: Maybe<Sponsor>;
};


export type MutationCreateAssetArgs = {
  data: AssetCreateInput;
};


export type MutationCreateButtonArgs = {
  data: ButtonCreateInput;
};


export type MutationCreateCardArgs = {
  data: CardCreateInput;
};


export type MutationCreateContactCardArgs = {
  data: ContactCardCreateInput;
};


export type MutationCreateContainerArgs = {
  data: ContainerCreateInput;
};


export type MutationCreateEventArgs = {
  data: EventCreateInput;
};


export type MutationCreateFormArgs = {
  data: FormCreateInput;
};


export type MutationCreateLayoutArgs = {
  data: LayoutCreateInput;
};


export type MutationCreatePageArgs = {
  data: PageCreateInput;
};


export type MutationCreatePersonArgs = {
  data: PersonCreateInput;
};


export type MutationCreateProjectArgs = {
  data: ProjectCreateInput;
};


export type MutationCreateProjectCategoryArgs = {
  data: ProjectCategoryCreateInput;
};


export type MutationCreateRichTextWrapperArgs = {
  data: RichTextWrapperCreateInput;
};


export type MutationCreateScheduledReleaseArgs = {
  data: ScheduledReleaseCreateInput;
};


export type MutationCreateServiceArgs = {
  data: ServiceCreateInput;
};


export type MutationCreateSponsorArgs = {
  data: SponsorCreateInput;
};


export type MutationDeleteAssetArgs = {
  where: AssetWhereUniqueInput;
};


export type MutationDeleteButtonArgs = {
  where: ButtonWhereUniqueInput;
};


export type MutationDeleteCardArgs = {
  where: CardWhereUniqueInput;
};


export type MutationDeleteContactCardArgs = {
  where: ContactCardWhereUniqueInput;
};


export type MutationDeleteContainerArgs = {
  where: ContainerWhereUniqueInput;
};


export type MutationDeleteEventArgs = {
  where: EventWhereUniqueInput;
};


export type MutationDeleteFormArgs = {
  where: FormWhereUniqueInput;
};


export type MutationDeleteLayoutArgs = {
  where: LayoutWhereUniqueInput;
};


export type MutationDeleteManyAssetsArgs = {
  where?: InputMaybe<AssetManyWhereInput>;
};


export type MutationDeleteManyAssetsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AssetManyWhereInput>;
};


export type MutationDeleteManyButtonsArgs = {
  where?: InputMaybe<ButtonManyWhereInput>;
};


export type MutationDeleteManyButtonsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ButtonManyWhereInput>;
};


export type MutationDeleteManyCardsArgs = {
  where?: InputMaybe<CardManyWhereInput>;
};


export type MutationDeleteManyCardsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CardManyWhereInput>;
};


export type MutationDeleteManyContactCardsArgs = {
  where?: InputMaybe<ContactCardManyWhereInput>;
};


export type MutationDeleteManyContactCardsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ContactCardManyWhereInput>;
};


export type MutationDeleteManyContainersArgs = {
  where?: InputMaybe<ContainerManyWhereInput>;
};


export type MutationDeleteManyContainersConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ContainerManyWhereInput>;
};


export type MutationDeleteManyEventsArgs = {
  where?: InputMaybe<EventManyWhereInput>;
};


export type MutationDeleteManyEventsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<EventManyWhereInput>;
};


export type MutationDeleteManyFormsArgs = {
  where?: InputMaybe<FormManyWhereInput>;
};


export type MutationDeleteManyFormsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<FormManyWhereInput>;
};


export type MutationDeleteManyLayoutsArgs = {
  where?: InputMaybe<LayoutManyWhereInput>;
};


export type MutationDeleteManyLayoutsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<LayoutManyWhereInput>;
};


export type MutationDeleteManyPagesArgs = {
  where?: InputMaybe<PageManyWhereInput>;
};


export type MutationDeleteManyPagesConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PageManyWhereInput>;
};


export type MutationDeleteManyPeopleArgs = {
  where?: InputMaybe<PersonManyWhereInput>;
};


export type MutationDeleteManyPeopleConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PersonManyWhereInput>;
};


export type MutationDeleteManyProjectCategoriesArgs = {
  where?: InputMaybe<ProjectCategoryManyWhereInput>;
};


export type MutationDeleteManyProjectCategoriesConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ProjectCategoryManyWhereInput>;
};


export type MutationDeleteManyProjectsArgs = {
  where?: InputMaybe<ProjectManyWhereInput>;
};


export type MutationDeleteManyProjectsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ProjectManyWhereInput>;
};


export type MutationDeleteManyRichTextWrappersArgs = {
  where?: InputMaybe<RichTextWrapperManyWhereInput>;
};


export type MutationDeleteManyRichTextWrappersConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RichTextWrapperManyWhereInput>;
};


export type MutationDeleteManyServicesArgs = {
  where?: InputMaybe<ServiceManyWhereInput>;
};


export type MutationDeleteManyServicesConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ServiceManyWhereInput>;
};


export type MutationDeleteManySponsorsArgs = {
  where?: InputMaybe<SponsorManyWhereInput>;
};


export type MutationDeleteManySponsorsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<SponsorManyWhereInput>;
};


export type MutationDeletePageArgs = {
  where: PageWhereUniqueInput;
};


export type MutationDeletePersonArgs = {
  where: PersonWhereUniqueInput;
};


export type MutationDeleteProjectArgs = {
  where: ProjectWhereUniqueInput;
};


export type MutationDeleteProjectCategoryArgs = {
  where: ProjectCategoryWhereUniqueInput;
};


export type MutationDeleteRichTextWrapperArgs = {
  where: RichTextWrapperWhereUniqueInput;
};


export type MutationDeleteScheduledOperationArgs = {
  where: ScheduledOperationWhereUniqueInput;
};


export type MutationDeleteScheduledReleaseArgs = {
  where: ScheduledReleaseWhereUniqueInput;
};


export type MutationDeleteServiceArgs = {
  where: ServiceWhereUniqueInput;
};


export type MutationDeleteSponsorArgs = {
  where: SponsorWhereUniqueInput;
};


export type MutationPublishAssetArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  to?: Array<Stage>;
  where: AssetWhereUniqueInput;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishButtonArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  to?: Array<Stage>;
  where: ButtonWhereUniqueInput;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishCardArgs = {
  to?: Array<Stage>;
  where: CardWhereUniqueInput;
};


export type MutationPublishContactCardArgs = {
  to?: Array<Stage>;
  where: ContactCardWhereUniqueInput;
};


export type MutationPublishContainerArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  to?: Array<Stage>;
  where: ContainerWhereUniqueInput;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishEventArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  to?: Array<Stage>;
  where: EventWhereUniqueInput;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishFormArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  to?: Array<Stage>;
  where: FormWhereUniqueInput;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishLayoutArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  to?: Array<Stage>;
  where: LayoutWhereUniqueInput;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishManyAssetsArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  to?: Array<Stage>;
  where?: InputMaybe<AssetManyWhereInput>;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishManyAssetsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: InputMaybe<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
  to?: Array<Stage>;
  where?: InputMaybe<AssetManyWhereInput>;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishManyButtonsArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  to?: Array<Stage>;
  where?: InputMaybe<ButtonManyWhereInput>;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishManyButtonsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: InputMaybe<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
  to?: Array<Stage>;
  where?: InputMaybe<ButtonManyWhereInput>;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishManyCardsArgs = {
  to?: Array<Stage>;
  where?: InputMaybe<CardManyWhereInput>;
};


export type MutationPublishManyCardsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: InputMaybe<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  to?: Array<Stage>;
  where?: InputMaybe<CardManyWhereInput>;
};


export type MutationPublishManyContactCardsArgs = {
  to?: Array<Stage>;
  where?: InputMaybe<ContactCardManyWhereInput>;
};


export type MutationPublishManyContactCardsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: InputMaybe<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  to?: Array<Stage>;
  where?: InputMaybe<ContactCardManyWhereInput>;
};


export type MutationPublishManyContainersArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  to?: Array<Stage>;
  where?: InputMaybe<ContainerManyWhereInput>;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishManyContainersConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: InputMaybe<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
  to?: Array<Stage>;
  where?: InputMaybe<ContainerManyWhereInput>;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishManyEventsArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  to?: Array<Stage>;
  where?: InputMaybe<EventManyWhereInput>;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishManyEventsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: InputMaybe<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
  to?: Array<Stage>;
  where?: InputMaybe<EventManyWhereInput>;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishManyFormsArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  to?: Array<Stage>;
  where?: InputMaybe<FormManyWhereInput>;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishManyFormsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: InputMaybe<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
  to?: Array<Stage>;
  where?: InputMaybe<FormManyWhereInput>;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishManyLayoutsArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  to?: Array<Stage>;
  where?: InputMaybe<LayoutManyWhereInput>;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishManyLayoutsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: InputMaybe<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
  to?: Array<Stage>;
  where?: InputMaybe<LayoutManyWhereInput>;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishManyPagesArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  to?: Array<Stage>;
  where?: InputMaybe<PageManyWhereInput>;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishManyPagesConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: InputMaybe<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
  to?: Array<Stage>;
  where?: InputMaybe<PageManyWhereInput>;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishManyPeopleArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  to?: Array<Stage>;
  where?: InputMaybe<PersonManyWhereInput>;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishManyPeopleConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: InputMaybe<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
  to?: Array<Stage>;
  where?: InputMaybe<PersonManyWhereInput>;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishManyProjectCategoriesArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  to?: Array<Stage>;
  where?: InputMaybe<ProjectCategoryManyWhereInput>;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishManyProjectCategoriesConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: InputMaybe<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
  to?: Array<Stage>;
  where?: InputMaybe<ProjectCategoryManyWhereInput>;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishManyProjectsArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  to?: Array<Stage>;
  where?: InputMaybe<ProjectManyWhereInput>;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishManyProjectsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: InputMaybe<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
  to?: Array<Stage>;
  where?: InputMaybe<ProjectManyWhereInput>;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishManyRichTextWrappersArgs = {
  to?: Array<Stage>;
  where?: InputMaybe<RichTextWrapperManyWhereInput>;
};


export type MutationPublishManyRichTextWrappersConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: InputMaybe<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  to?: Array<Stage>;
  where?: InputMaybe<RichTextWrapperManyWhereInput>;
};


export type MutationPublishManyServicesArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  to?: Array<Stage>;
  where?: InputMaybe<ServiceManyWhereInput>;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishManyServicesConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: InputMaybe<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
  to?: Array<Stage>;
  where?: InputMaybe<ServiceManyWhereInput>;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishManySponsorsArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  to?: Array<Stage>;
  where?: InputMaybe<SponsorManyWhereInput>;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishManySponsorsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: InputMaybe<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  skip?: InputMaybe<Scalars['Int']>;
  to?: Array<Stage>;
  where?: InputMaybe<SponsorManyWhereInput>;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishPageArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  to?: Array<Stage>;
  where: PageWhereUniqueInput;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishPersonArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  to?: Array<Stage>;
  where: PersonWhereUniqueInput;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishProjectArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  to?: Array<Stage>;
  where: ProjectWhereUniqueInput;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishProjectCategoryArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  to?: Array<Stage>;
  where: ProjectCategoryWhereUniqueInput;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishRichTextWrapperArgs = {
  to?: Array<Stage>;
  where: RichTextWrapperWhereUniqueInput;
};


export type MutationPublishServiceArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  to?: Array<Stage>;
  where: ServiceWhereUniqueInput;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationPublishSponsorArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  to?: Array<Stage>;
  where: SponsorWhereUniqueInput;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationSchedulePublishAssetArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  to?: Array<Stage>;
  where: AssetWhereUniqueInput;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationSchedulePublishButtonArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  to?: Array<Stage>;
  where: ButtonWhereUniqueInput;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationSchedulePublishCardArgs = {
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  to?: Array<Stage>;
  where: CardWhereUniqueInput;
};


export type MutationSchedulePublishContactCardArgs = {
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  to?: Array<Stage>;
  where: ContactCardWhereUniqueInput;
};


export type MutationSchedulePublishContainerArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  to?: Array<Stage>;
  where: ContainerWhereUniqueInput;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationSchedulePublishEventArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  to?: Array<Stage>;
  where: EventWhereUniqueInput;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationSchedulePublishFormArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  to?: Array<Stage>;
  where: FormWhereUniqueInput;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationSchedulePublishLayoutArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  to?: Array<Stage>;
  where: LayoutWhereUniqueInput;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationSchedulePublishPageArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  to?: Array<Stage>;
  where: PageWhereUniqueInput;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationSchedulePublishPersonArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  to?: Array<Stage>;
  where: PersonWhereUniqueInput;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationSchedulePublishProjectArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  to?: Array<Stage>;
  where: ProjectWhereUniqueInput;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationSchedulePublishProjectCategoryArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  to?: Array<Stage>;
  where: ProjectCategoryWhereUniqueInput;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationSchedulePublishRichTextWrapperArgs = {
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  to?: Array<Stage>;
  where: RichTextWrapperWhereUniqueInput;
};


export type MutationSchedulePublishServiceArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  to?: Array<Stage>;
  where: ServiceWhereUniqueInput;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationSchedulePublishSponsorArgs = {
  locales?: InputMaybe<Array<Locale>>;
  publishBase?: InputMaybe<Scalars['Boolean']>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  to?: Array<Stage>;
  where: SponsorWhereUniqueInput;
  withDefaultLocale?: InputMaybe<Scalars['Boolean']>;
};


export type MutationScheduleUnpublishAssetArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where: AssetWhereUniqueInput;
};


export type MutationScheduleUnpublishButtonArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where: ButtonWhereUniqueInput;
};


export type MutationScheduleUnpublishCardArgs = {
  from?: Array<Stage>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  where: CardWhereUniqueInput;
};


export type MutationScheduleUnpublishContactCardArgs = {
  from?: Array<Stage>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  where: ContactCardWhereUniqueInput;
};


export type MutationScheduleUnpublishContainerArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where: ContainerWhereUniqueInput;
};


export type MutationScheduleUnpublishEventArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where: EventWhereUniqueInput;
};


export type MutationScheduleUnpublishFormArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where: FormWhereUniqueInput;
};


export type MutationScheduleUnpublishLayoutArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where: LayoutWhereUniqueInput;
};


export type MutationScheduleUnpublishPageArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where: PageWhereUniqueInput;
};


export type MutationScheduleUnpublishPersonArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where: PersonWhereUniqueInput;
};


export type MutationScheduleUnpublishProjectArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where: ProjectWhereUniqueInput;
};


export type MutationScheduleUnpublishProjectCategoryArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where: ProjectCategoryWhereUniqueInput;
};


export type MutationScheduleUnpublishRichTextWrapperArgs = {
  from?: Array<Stage>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  where: RichTextWrapperWhereUniqueInput;
};


export type MutationScheduleUnpublishServiceArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where: ServiceWhereUniqueInput;
};


export type MutationScheduleUnpublishSponsorArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  releaseId?: InputMaybe<Scalars['String']>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where: SponsorWhereUniqueInput;
};


export type MutationUnpublishAssetArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where: AssetWhereUniqueInput;
};


export type MutationUnpublishButtonArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where: ButtonWhereUniqueInput;
};


export type MutationUnpublishCardArgs = {
  from?: Array<Stage>;
  where: CardWhereUniqueInput;
};


export type MutationUnpublishContactCardArgs = {
  from?: Array<Stage>;
  where: ContactCardWhereUniqueInput;
};


export type MutationUnpublishContainerArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where: ContainerWhereUniqueInput;
};


export type MutationUnpublishEventArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where: EventWhereUniqueInput;
};


export type MutationUnpublishFormArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where: FormWhereUniqueInput;
};


export type MutationUnpublishLayoutArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where: LayoutWhereUniqueInput;
};


export type MutationUnpublishManyAssetsArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where?: InputMaybe<AssetManyWhereInput>;
};


export type MutationUnpublishManyAssetsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: Array<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: InputMaybe<Stage>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where?: InputMaybe<AssetManyWhereInput>;
};


export type MutationUnpublishManyButtonsArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where?: InputMaybe<ButtonManyWhereInput>;
};


export type MutationUnpublishManyButtonsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: Array<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: InputMaybe<Stage>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where?: InputMaybe<ButtonManyWhereInput>;
};


export type MutationUnpublishManyCardsArgs = {
  from?: Array<Stage>;
  where?: InputMaybe<CardManyWhereInput>;
};


export type MutationUnpublishManyCardsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: Array<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: InputMaybe<Stage>;
  where?: InputMaybe<CardManyWhereInput>;
};


export type MutationUnpublishManyContactCardsArgs = {
  from?: Array<Stage>;
  where?: InputMaybe<ContactCardManyWhereInput>;
};


export type MutationUnpublishManyContactCardsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: Array<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: InputMaybe<Stage>;
  where?: InputMaybe<ContactCardManyWhereInput>;
};


export type MutationUnpublishManyContainersArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where?: InputMaybe<ContainerManyWhereInput>;
};


export type MutationUnpublishManyContainersConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: Array<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: InputMaybe<Stage>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where?: InputMaybe<ContainerManyWhereInput>;
};


export type MutationUnpublishManyEventsArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where?: InputMaybe<EventManyWhereInput>;
};


export type MutationUnpublishManyEventsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: Array<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: InputMaybe<Stage>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where?: InputMaybe<EventManyWhereInput>;
};


export type MutationUnpublishManyFormsArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where?: InputMaybe<FormManyWhereInput>;
};


export type MutationUnpublishManyFormsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: Array<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: InputMaybe<Stage>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where?: InputMaybe<FormManyWhereInput>;
};


export type MutationUnpublishManyLayoutsArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where?: InputMaybe<LayoutManyWhereInput>;
};


export type MutationUnpublishManyLayoutsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: Array<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: InputMaybe<Stage>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where?: InputMaybe<LayoutManyWhereInput>;
};


export type MutationUnpublishManyPagesArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where?: InputMaybe<PageManyWhereInput>;
};


export type MutationUnpublishManyPagesConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: Array<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: InputMaybe<Stage>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where?: InputMaybe<PageManyWhereInput>;
};


export type MutationUnpublishManyPeopleArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where?: InputMaybe<PersonManyWhereInput>;
};


export type MutationUnpublishManyPeopleConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: Array<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: InputMaybe<Stage>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where?: InputMaybe<PersonManyWhereInput>;
};


export type MutationUnpublishManyProjectCategoriesArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where?: InputMaybe<ProjectCategoryManyWhereInput>;
};


export type MutationUnpublishManyProjectCategoriesConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: Array<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: InputMaybe<Stage>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where?: InputMaybe<ProjectCategoryManyWhereInput>;
};


export type MutationUnpublishManyProjectsArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where?: InputMaybe<ProjectManyWhereInput>;
};


export type MutationUnpublishManyProjectsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: Array<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: InputMaybe<Stage>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where?: InputMaybe<ProjectManyWhereInput>;
};


export type MutationUnpublishManyRichTextWrappersArgs = {
  from?: Array<Stage>;
  where?: InputMaybe<RichTextWrapperManyWhereInput>;
};


export type MutationUnpublishManyRichTextWrappersConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: Array<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: InputMaybe<Stage>;
  where?: InputMaybe<RichTextWrapperManyWhereInput>;
};


export type MutationUnpublishManyServicesArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where?: InputMaybe<ServiceManyWhereInput>;
};


export type MutationUnpublishManyServicesConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: Array<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: InputMaybe<Stage>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where?: InputMaybe<ServiceManyWhereInput>;
};


export type MutationUnpublishManySponsorsArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where?: InputMaybe<SponsorManyWhereInput>;
};


export type MutationUnpublishManySponsorsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  from?: Array<Stage>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: InputMaybe<Stage>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where?: InputMaybe<SponsorManyWhereInput>;
};


export type MutationUnpublishPageArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where: PageWhereUniqueInput;
};


export type MutationUnpublishPersonArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where: PersonWhereUniqueInput;
};


export type MutationUnpublishProjectArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where: ProjectWhereUniqueInput;
};


export type MutationUnpublishProjectCategoryArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where: ProjectCategoryWhereUniqueInput;
};


export type MutationUnpublishRichTextWrapperArgs = {
  from?: Array<Stage>;
  where: RichTextWrapperWhereUniqueInput;
};


export type MutationUnpublishServiceArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where: ServiceWhereUniqueInput;
};


export type MutationUnpublishSponsorArgs = {
  from?: Array<Stage>;
  locales?: InputMaybe<Array<Locale>>;
  unpublishBase?: InputMaybe<Scalars['Boolean']>;
  where: SponsorWhereUniqueInput;
};


export type MutationUpdateAssetArgs = {
  data: AssetUpdateInput;
  where: AssetWhereUniqueInput;
};


export type MutationUpdateButtonArgs = {
  data: ButtonUpdateInput;
  where: ButtonWhereUniqueInput;
};


export type MutationUpdateCardArgs = {
  data: CardUpdateInput;
  where: CardWhereUniqueInput;
};


export type MutationUpdateContactCardArgs = {
  data: ContactCardUpdateInput;
  where: ContactCardWhereUniqueInput;
};


export type MutationUpdateContainerArgs = {
  data: ContainerUpdateInput;
  where: ContainerWhereUniqueInput;
};


export type MutationUpdateEventArgs = {
  data: EventUpdateInput;
  where: EventWhereUniqueInput;
};


export type MutationUpdateFormArgs = {
  data: FormUpdateInput;
  where: FormWhereUniqueInput;
};


export type MutationUpdateLayoutArgs = {
  data: LayoutUpdateInput;
  where: LayoutWhereUniqueInput;
};


export type MutationUpdateManyAssetsArgs = {
  data: AssetUpdateManyInput;
  where?: InputMaybe<AssetManyWhereInput>;
};


export type MutationUpdateManyAssetsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  data: AssetUpdateManyInput;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AssetManyWhereInput>;
};


export type MutationUpdateManyButtonsArgs = {
  data: ButtonUpdateManyInput;
  where?: InputMaybe<ButtonManyWhereInput>;
};


export type MutationUpdateManyButtonsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  data: ButtonUpdateManyInput;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ButtonManyWhereInput>;
};


export type MutationUpdateManyCardsArgs = {
  data: CardUpdateManyInput;
  where?: InputMaybe<CardManyWhereInput>;
};


export type MutationUpdateManyCardsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  data: CardUpdateManyInput;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CardManyWhereInput>;
};


export type MutationUpdateManyContactCardsArgs = {
  data: ContactCardUpdateManyInput;
  where?: InputMaybe<ContactCardManyWhereInput>;
};


export type MutationUpdateManyContactCardsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  data: ContactCardUpdateManyInput;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ContactCardManyWhereInput>;
};


export type MutationUpdateManyContainersArgs = {
  data: ContainerUpdateManyInput;
  where?: InputMaybe<ContainerManyWhereInput>;
};


export type MutationUpdateManyContainersConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  data: ContainerUpdateManyInput;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ContainerManyWhereInput>;
};


export type MutationUpdateManyEventsArgs = {
  data: EventUpdateManyInput;
  where?: InputMaybe<EventManyWhereInput>;
};


export type MutationUpdateManyEventsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  data: EventUpdateManyInput;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<EventManyWhereInput>;
};


export type MutationUpdateManyFormsArgs = {
  data: FormUpdateManyInput;
  where?: InputMaybe<FormManyWhereInput>;
};


export type MutationUpdateManyFormsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  data: FormUpdateManyInput;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<FormManyWhereInput>;
};


export type MutationUpdateManyLayoutsArgs = {
  data: LayoutUpdateManyInput;
  where?: InputMaybe<LayoutManyWhereInput>;
};


export type MutationUpdateManyLayoutsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  data: LayoutUpdateManyInput;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<LayoutManyWhereInput>;
};


export type MutationUpdateManyPagesArgs = {
  data: PageUpdateManyInput;
  where?: InputMaybe<PageManyWhereInput>;
};


export type MutationUpdateManyPagesConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  data: PageUpdateManyInput;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PageManyWhereInput>;
};


export type MutationUpdateManyPeopleArgs = {
  data: PersonUpdateManyInput;
  where?: InputMaybe<PersonManyWhereInput>;
};


export type MutationUpdateManyPeopleConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  data: PersonUpdateManyInput;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PersonManyWhereInput>;
};


export type MutationUpdateManyProjectCategoriesArgs = {
  data: ProjectCategoryUpdateManyInput;
  where?: InputMaybe<ProjectCategoryManyWhereInput>;
};


export type MutationUpdateManyProjectCategoriesConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  data: ProjectCategoryUpdateManyInput;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ProjectCategoryManyWhereInput>;
};


export type MutationUpdateManyProjectsArgs = {
  data: ProjectUpdateManyInput;
  where?: InputMaybe<ProjectManyWhereInput>;
};


export type MutationUpdateManyProjectsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  data: ProjectUpdateManyInput;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ProjectManyWhereInput>;
};


export type MutationUpdateManyRichTextWrappersArgs = {
  data: RichTextWrapperUpdateManyInput;
  where?: InputMaybe<RichTextWrapperManyWhereInput>;
};


export type MutationUpdateManyRichTextWrappersConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  data: RichTextWrapperUpdateManyInput;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RichTextWrapperManyWhereInput>;
};


export type MutationUpdateManyServicesArgs = {
  data: ServiceUpdateManyInput;
  where?: InputMaybe<ServiceManyWhereInput>;
};


export type MutationUpdateManyServicesConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  data: ServiceUpdateManyInput;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ServiceManyWhereInput>;
};


export type MutationUpdateManySponsorsArgs = {
  data: SponsorUpdateManyInput;
  where?: InputMaybe<SponsorManyWhereInput>;
};


export type MutationUpdateManySponsorsConnectionArgs = {
  after?: InputMaybe<Scalars['ID']>;
  before?: InputMaybe<Scalars['ID']>;
  data: SponsorUpdateManyInput;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<SponsorManyWhereInput>;
};


export type MutationUpdatePageArgs = {
  data: PageUpdateInput;
  where: PageWhereUniqueInput;
};


export type MutationUpdatePersonArgs = {
  data: PersonUpdateInput;
  where: PersonWhereUniqueInput;
};


export type MutationUpdateProjectArgs = {
  data: ProjectUpdateInput;
  where: ProjectWhereUniqueInput;
};


export type MutationUpdateProjectCategoryArgs = {
  data: ProjectCategoryUpdateInput;
  where: ProjectCategoryWhereUniqueInput;
};


export type MutationUpdateRichTextWrapperArgs = {
  data: RichTextWrapperUpdateInput;
  where: RichTextWrapperWhereUniqueInput;
};


export type MutationUpdateScheduledReleaseArgs = {
  data: ScheduledReleaseUpdateInput;
  where: ScheduledReleaseWhereUniqueInput;
};


export type MutationUpdateServiceArgs = {
  data: ServiceUpdateInput;
  where: ServiceWhereUniqueInput;
};


export type MutationUpdateSponsorArgs = {
  data: SponsorUpdateInput;
  where: SponsorWhereUniqueInput;
};


export type MutationUpsertAssetArgs = {
  upsert: AssetUpsertInput;
  where: AssetWhereUniqueInput;
};


export type MutationUpsertButtonArgs = {
  upsert: ButtonUpsertInput;
  where: ButtonWhereUniqueInput;
};


export type MutationUpsertCardArgs = {
  upsert: CardUpsertInput;
  where: CardWhereUniqueInput;
};


export type MutationUpsertContactCardArgs = {
  upsert: ContactCardUpsertInput;
  where: ContactCardWhereUniqueInput;
};


export type MutationUpsertContainerArgs = {
  upsert: ContainerUpsertInput;
  where: ContainerWhereUniqueInput;
};


export type MutationUpsertEventArgs = {
  upsert: EventUpsertInput;
  where: EventWhereUniqueInput;
};


export type MutationUpsertFormArgs = {
  upsert: FormUpsertInput;
  where: FormWhereUniqueInput;
};


export type MutationUpsertLayoutArgs = {
  upsert: LayoutUpsertInput;
  where: LayoutWhereUniqueInput;
};


export type MutationUpsertPageArgs = {
  upsert: PageUpsertInput;
  where: PageWhereUniqueInput;
};


export type MutationUpsertPersonArgs = {
  upsert: PersonUpsertInput;
  where: PersonWhereUniqueInput;
};


export type MutationUpsertProjectArgs = {
  upsert: ProjectUpsertInput;
  where: ProjectWhereUniqueInput;
};


export type MutationUpsertProjectCategoryArgs = {
  upsert: ProjectCategoryUpsertInput;
  where: ProjectCategoryWhereUniqueInput;
};


export type MutationUpsertRichTextWrapperArgs = {
  upsert: RichTextWrapperUpsertInput;
  where: RichTextWrapperWhereUniqueInput;
};


export type MutationUpsertServiceArgs = {
  upsert: ServiceUpsertInput;
  where: ServiceWhereUniqueInput;
};


export type MutationUpsertSponsorArgs = {
  upsert: SponsorUpsertInput;
  where: SponsorWhereUniqueInput;
};

export type Navigation = {
  __typename?: 'Navigation';
  ctas: Array<Button>;
  /** The unique identifier */
  id: Scalars['ID'];
  logo?: Maybe<Asset>;
  pages: Array<Page>;
  /** System stage field */
  stage: Stage;
};


export type NavigationCtasArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  orderBy?: InputMaybe<ButtonOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ButtonWhereInput>;
};


export type NavigationLogoArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type NavigationPagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  orderBy?: InputMaybe<PageOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PageWhereInput>;
};

export type NavigationConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: NavigationWhereUniqueInput;
};

/** A connection to a list of items. */
export type NavigationConnection = {
  __typename?: 'NavigationConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<NavigationEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type NavigationCreateInput = {
  ctas?: InputMaybe<ButtonCreateManyInlineInput>;
  logo?: InputMaybe<AssetCreateOneInlineInput>;
  pages?: InputMaybe<PageCreateManyInlineInput>;
};

export type NavigationCreateManyInlineInput = {
  /** Create and connect multiple existing Navigation documents */
  create?: InputMaybe<Array<NavigationCreateInput>>;
};

export type NavigationCreateOneInlineInput = {
  /** Create and connect one Navigation document */
  create?: InputMaybe<NavigationCreateInput>;
};

export type NavigationCreateWithPositionInput = {
  /** Document to create */
  data: NavigationCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type NavigationEdge = {
  __typename?: 'NavigationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Navigation;
};

/** Identifies documents */
export type NavigationManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<NavigationWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<NavigationWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<NavigationWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  ctas_every?: InputMaybe<ButtonWhereInput>;
  ctas_none?: InputMaybe<ButtonWhereInput>;
  ctas_some?: InputMaybe<ButtonWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  logo?: InputMaybe<AssetWhereInput>;
  pages_every?: InputMaybe<PageWhereInput>;
  pages_none?: InputMaybe<PageWhereInput>;
  pages_some?: InputMaybe<PageWhereInput>;
};

export enum NavigationOrderByInput {
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC'
}

export type NavigationParent = Layout;

export type NavigationParentConnectInput = {
  Layout?: InputMaybe<LayoutConnectInput>;
};

export type NavigationParentCreateInput = {
  Layout?: InputMaybe<LayoutCreateInput>;
};

export type NavigationParentCreateManyInlineInput = {
  /** Connect multiple existing NavigationParent documents */
  connect?: InputMaybe<Array<NavigationParentWhereUniqueInput>>;
  /** Create and connect multiple existing NavigationParent documents */
  create?: InputMaybe<Array<NavigationParentCreateInput>>;
};

export type NavigationParentCreateOneInlineInput = {
  /** Connect one existing NavigationParent document */
  connect?: InputMaybe<NavigationParentWhereUniqueInput>;
  /** Create and connect one NavigationParent document */
  create?: InputMaybe<NavigationParentCreateInput>;
};

export type NavigationParentUpdateInput = {
  Layout?: InputMaybe<LayoutUpdateInput>;
};

export type NavigationParentUpdateManyInlineInput = {
  /** Connect multiple existing NavigationParent documents */
  connect?: InputMaybe<Array<NavigationParentConnectInput>>;
  /** Create and connect multiple NavigationParent documents */
  create?: InputMaybe<Array<NavigationParentCreateInput>>;
  /** Delete multiple NavigationParent documents */
  delete?: InputMaybe<Array<NavigationParentWhereUniqueInput>>;
  /** Disconnect multiple NavigationParent documents */
  disconnect?: InputMaybe<Array<NavigationParentWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing NavigationParent documents */
  set?: InputMaybe<Array<NavigationParentWhereUniqueInput>>;
  /** Update multiple NavigationParent documents */
  update?: InputMaybe<Array<NavigationParentUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple NavigationParent documents */
  upsert?: InputMaybe<Array<NavigationParentUpsertWithNestedWhereUniqueInput>>;
};

export type NavigationParentUpdateManyWithNestedWhereInput = {
  Layout?: InputMaybe<LayoutUpdateManyWithNestedWhereInput>;
};

export type NavigationParentUpdateOneInlineInput = {
  /** Connect existing NavigationParent document */
  connect?: InputMaybe<NavigationParentWhereUniqueInput>;
  /** Create and connect one NavigationParent document */
  create?: InputMaybe<NavigationParentCreateInput>;
  /** Delete currently connected NavigationParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected NavigationParent document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single NavigationParent document */
  update?: InputMaybe<NavigationParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single NavigationParent document */
  upsert?: InputMaybe<NavigationParentUpsertWithNestedWhereUniqueInput>;
};

export type NavigationParentUpdateWithNestedWhereUniqueInput = {
  Layout?: InputMaybe<LayoutUpdateWithNestedWhereUniqueInput>;
};

export type NavigationParentUpsertWithNestedWhereUniqueInput = {
  Layout?: InputMaybe<LayoutUpsertWithNestedWhereUniqueInput>;
};

export type NavigationParentWhereInput = {
  Layout?: InputMaybe<LayoutWhereInput>;
};

export type NavigationParentWhereUniqueInput = {
  Layout?: InputMaybe<LayoutWhereUniqueInput>;
};

export type NavigationUpdateInput = {
  ctas?: InputMaybe<ButtonUpdateManyInlineInput>;
  logo?: InputMaybe<AssetUpdateOneInlineInput>;
  pages?: InputMaybe<PageUpdateManyInlineInput>;
};

export type NavigationUpdateManyInlineInput = {
  /** Create and connect multiple Navigation component instances */
  create?: InputMaybe<Array<NavigationCreateWithPositionInput>>;
  /** Delete multiple Navigation documents */
  delete?: InputMaybe<Array<NavigationWhereUniqueInput>>;
  /** Update multiple Navigation component instances */
  update?: InputMaybe<Array<NavigationUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple Navigation component instances */
  upsert?: InputMaybe<Array<NavigationUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type NavigationUpdateManyInput = {
  /** No fields in updateMany data input */
  _?: InputMaybe<Scalars['String']>;
};

export type NavigationUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: NavigationUpdateManyInput;
  /** Document search */
  where: NavigationWhereInput;
};

export type NavigationUpdateOneInlineInput = {
  /** Create and connect one Navigation document */
  create?: InputMaybe<NavigationCreateInput>;
  /** Delete currently connected Navigation document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single Navigation document */
  update?: InputMaybe<NavigationUpdateWithNestedWhereUniqueInput>;
  /** Upsert single Navigation document */
  upsert?: InputMaybe<NavigationUpsertWithNestedWhereUniqueInput>;
};

export type NavigationUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<NavigationUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: NavigationWhereUniqueInput;
};

export type NavigationUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: NavigationUpdateInput;
  /** Unique document search */
  where: NavigationWhereUniqueInput;
};

export type NavigationUpsertInput = {
  /** Create document if it didn't exist */
  create: NavigationCreateInput;
  /** Update document if it exists */
  update: NavigationUpdateInput;
};

export type NavigationUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<NavigationUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: NavigationWhereUniqueInput;
};

export type NavigationUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: NavigationUpsertInput;
  /** Unique document search */
  where: NavigationWhereUniqueInput;
};

/** Identifies documents */
export type NavigationWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<NavigationWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<NavigationWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<NavigationWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  ctas_every?: InputMaybe<ButtonWhereInput>;
  ctas_none?: InputMaybe<ButtonWhereInput>;
  ctas_some?: InputMaybe<ButtonWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  logo?: InputMaybe<AssetWhereInput>;
  pages_every?: InputMaybe<PageWhereInput>;
  pages_none?: InputMaybe<PageWhereInput>;
  pages_some?: InputMaybe<PageWhereInput>;
};

/** References Navigation record uniquely */
export type NavigationWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

/** An object with an ID */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID'];
  /** The Stage of an object */
  stage: Stage;
};

export type OldButton = {
  __typename?: 'OldButton';
  href?: Maybe<Page>;
  /** The unique identifier */
  id: Scalars['ID'];
  label?: Maybe<Scalars['String']>;
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<OldButton>;
  /** System stage field */
  stage: Stage;
};


export type OldButtonHrefArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type OldButtonLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};

export type OldButtonConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: OldButtonWhereUniqueInput;
};

/** A connection to a list of items. */
export type OldButtonConnection = {
  __typename?: 'OldButtonConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<OldButtonEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type OldButtonCreateInput = {
  href?: InputMaybe<PageCreateOneInlineInput>;
  /** label input for default locale (en) */
  label?: InputMaybe<Scalars['String']>;
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<OldButtonCreateLocalizationsInput>;
};

export type OldButtonCreateLocalizationDataInput = {
  label?: InputMaybe<Scalars['String']>;
};

export type OldButtonCreateLocalizationInput = {
  /** Localization input */
  data: OldButtonCreateLocalizationDataInput;
  locale: Locale;
};

export type OldButtonCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<OldButtonCreateLocalizationInput>>;
};

export type OldButtonCreateManyInlineInput = {
  /** Create and connect multiple existing OldButton documents */
  create?: InputMaybe<Array<OldButtonCreateInput>>;
};

export type OldButtonCreateOneInlineInput = {
  /** Create and connect one OldButton document */
  create?: InputMaybe<OldButtonCreateInput>;
};

export type OldButtonCreateWithPositionInput = {
  /** Document to create */
  data: OldButtonCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type OldButtonEdge = {
  __typename?: 'OldButtonEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: OldButton;
};

/** Identifies documents */
export type OldButtonManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<OldButtonWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<OldButtonWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<OldButtonWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  href?: InputMaybe<PageWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
};

export enum OldButtonOrderByInput {
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  LabelAsc = 'label_ASC',
  LabelDesc = 'label_DESC'
}

export type OldButtonParent = CarouselSlide | JoinUsSection;

export type OldButtonParentConnectInput = {
  CarouselSlide?: InputMaybe<CarouselSlideConnectInput>;
  JoinUsSection?: InputMaybe<JoinUsSectionConnectInput>;
};

export type OldButtonParentCreateInput = {
  CarouselSlide?: InputMaybe<CarouselSlideCreateInput>;
  JoinUsSection?: InputMaybe<JoinUsSectionCreateInput>;
};

export type OldButtonParentCreateManyInlineInput = {
  /** Create and connect multiple existing OldButtonParent documents */
  create?: InputMaybe<Array<OldButtonParentCreateInput>>;
};

export type OldButtonParentCreateOneInlineInput = {
  /** Create and connect one OldButtonParent document */
  create?: InputMaybe<OldButtonParentCreateInput>;
};

export type OldButtonParentCreateWithPositionInput = {
  CarouselSlide?: InputMaybe<CarouselSlideCreateWithPositionInput>;
  JoinUsSection?: InputMaybe<JoinUsSectionCreateWithPositionInput>;
};

export type OldButtonParentUpdateInput = {
  CarouselSlide?: InputMaybe<CarouselSlideUpdateInput>;
  JoinUsSection?: InputMaybe<JoinUsSectionUpdateInput>;
};

export type OldButtonParentUpdateManyInlineInput = {
  /** Create and connect multiple OldButtonParent component instances */
  create?: InputMaybe<Array<OldButtonParentCreateWithPositionInput>>;
  /** Delete multiple OldButtonParent documents */
  delete?: InputMaybe<Array<OldButtonParentWhereUniqueInput>>;
  /** Update multiple OldButtonParent component instances */
  update?: InputMaybe<Array<OldButtonParentUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple OldButtonParent component instances */
  upsert?: InputMaybe<Array<OldButtonParentUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type OldButtonParentUpdateManyWithNestedWhereInput = {
  CarouselSlide?: InputMaybe<CarouselSlideUpdateManyWithNestedWhereInput>;
  JoinUsSection?: InputMaybe<JoinUsSectionUpdateManyWithNestedWhereInput>;
};

export type OldButtonParentUpdateOneInlineInput = {
  /** Create and connect one OldButtonParent document */
  create?: InputMaybe<OldButtonParentCreateInput>;
  /** Delete currently connected OldButtonParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single OldButtonParent document */
  update?: InputMaybe<OldButtonParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single OldButtonParent document */
  upsert?: InputMaybe<OldButtonParentUpsertWithNestedWhereUniqueInput>;
};

export type OldButtonParentUpdateWithNestedWhereUniqueAndPositionInput = {
  CarouselSlide?: InputMaybe<CarouselSlideUpdateWithNestedWhereUniqueAndPositionInput>;
  JoinUsSection?: InputMaybe<JoinUsSectionUpdateWithNestedWhereUniqueAndPositionInput>;
};

export type OldButtonParentUpdateWithNestedWhereUniqueInput = {
  CarouselSlide?: InputMaybe<CarouselSlideUpdateWithNestedWhereUniqueInput>;
  JoinUsSection?: InputMaybe<JoinUsSectionUpdateWithNestedWhereUniqueInput>;
};

export type OldButtonParentUpsertWithNestedWhereUniqueAndPositionInput = {
  CarouselSlide?: InputMaybe<CarouselSlideUpsertWithNestedWhereUniqueAndPositionInput>;
  JoinUsSection?: InputMaybe<JoinUsSectionUpsertWithNestedWhereUniqueAndPositionInput>;
};

export type OldButtonParentUpsertWithNestedWhereUniqueInput = {
  CarouselSlide?: InputMaybe<CarouselSlideUpsertWithNestedWhereUniqueInput>;
  JoinUsSection?: InputMaybe<JoinUsSectionUpsertWithNestedWhereUniqueInput>;
};

export type OldButtonParentWhereInput = {
  CarouselSlide?: InputMaybe<CarouselSlideWhereInput>;
  JoinUsSection?: InputMaybe<JoinUsSectionWhereInput>;
};

export type OldButtonParentWhereUniqueInput = {
  CarouselSlide?: InputMaybe<CarouselSlideWhereUniqueInput>;
  JoinUsSection?: InputMaybe<JoinUsSectionWhereUniqueInput>;
};

export type OldButtonUpdateInput = {
  href?: InputMaybe<PageUpdateOneInlineInput>;
  /** label input for default locale (en) */
  label?: InputMaybe<Scalars['String']>;
  /** Manage document localizations */
  localizations?: InputMaybe<OldButtonUpdateLocalizationsInput>;
};

export type OldButtonUpdateLocalizationDataInput = {
  label?: InputMaybe<Scalars['String']>;
};

export type OldButtonUpdateLocalizationInput = {
  data: OldButtonUpdateLocalizationDataInput;
  locale: Locale;
};

export type OldButtonUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<OldButtonCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<OldButtonUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<OldButtonUpsertLocalizationInput>>;
};

export type OldButtonUpdateManyInlineInput = {
  /** Create and connect multiple OldButton component instances */
  create?: InputMaybe<Array<OldButtonCreateWithPositionInput>>;
  /** Delete multiple OldButton documents */
  delete?: InputMaybe<Array<OldButtonWhereUniqueInput>>;
  /** Update multiple OldButton component instances */
  update?: InputMaybe<Array<OldButtonUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple OldButton component instances */
  upsert?: InputMaybe<Array<OldButtonUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type OldButtonUpdateManyInput = {
  /** No fields in updateMany data input */
  _?: InputMaybe<Scalars['String']>;
};

export type OldButtonUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: OldButtonUpdateManyInput;
  /** Document search */
  where: OldButtonWhereInput;
};

export type OldButtonUpdateOneInlineInput = {
  /** Create and connect one OldButton document */
  create?: InputMaybe<OldButtonCreateInput>;
  /** Delete currently connected OldButton document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single OldButton document */
  update?: InputMaybe<OldButtonUpdateWithNestedWhereUniqueInput>;
  /** Upsert single OldButton document */
  upsert?: InputMaybe<OldButtonUpsertWithNestedWhereUniqueInput>;
};

export type OldButtonUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<OldButtonUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: OldButtonWhereUniqueInput;
};

export type OldButtonUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: OldButtonUpdateInput;
  /** Unique document search */
  where: OldButtonWhereUniqueInput;
};

export type OldButtonUpsertInput = {
  /** Create document if it didn't exist */
  create: OldButtonCreateInput;
  /** Update document if it exists */
  update: OldButtonUpdateInput;
};

export type OldButtonUpsertLocalizationInput = {
  create: OldButtonCreateLocalizationDataInput;
  locale: Locale;
  update: OldButtonUpdateLocalizationDataInput;
};

export type OldButtonUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<OldButtonUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: OldButtonWhereUniqueInput;
};

export type OldButtonUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: OldButtonUpsertInput;
  /** Unique document search */
  where: OldButtonWhereUniqueInput;
};

/** Identifies documents */
export type OldButtonWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<OldButtonWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<OldButtonWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<OldButtonWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  href?: InputMaybe<PageWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  label?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  label_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  label_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  label_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  label_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  label_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  label_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  label_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  label_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  label_starts_with?: InputMaybe<Scalars['String']>;
};

/** References OldButton record uniquely */
export type OldButtonWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

/** This component is meant to be used inside containers having multiple columns.  */
export type OldColumn = {
  __typename?: 'OldColumn';
  contactCard?: Maybe<ContactCard>;
  /** The unique identifier */
  id: Scalars['ID'];
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<OldColumn>;
  pages: Array<Page>;
  /** System stage field */
  stage: Stage;
  /** The title of the column */
  title?: Maybe<Scalars['String']>;
};


/** This component is meant to be used inside containers having multiple columns.  */
export type OldColumnContactCardArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


/** This component is meant to be used inside containers having multiple columns.  */
export type OldColumnLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};


/** This component is meant to be used inside containers having multiple columns.  */
export type OldColumnPagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  orderBy?: InputMaybe<PageOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PageWhereInput>;
};

export type OldColumnConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: OldColumnWhereUniqueInput;
};

/** A connection to a list of items. */
export type OldColumnConnection = {
  __typename?: 'OldColumnConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<OldColumnEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type OldColumnCreateInput = {
  contactCard?: InputMaybe<ContactCardCreateOneInlineInput>;
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<OldColumnCreateLocalizationsInput>;
  pages?: InputMaybe<PageCreateManyInlineInput>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
};

export type OldColumnCreateLocalizationDataInput = {
  title?: InputMaybe<Scalars['String']>;
};

export type OldColumnCreateLocalizationInput = {
  /** Localization input */
  data: OldColumnCreateLocalizationDataInput;
  locale: Locale;
};

export type OldColumnCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<OldColumnCreateLocalizationInput>>;
};

export type OldColumnCreateManyInlineInput = {
  /** Create and connect multiple existing OldColumn documents */
  create?: InputMaybe<Array<OldColumnCreateInput>>;
};

export type OldColumnCreateOneInlineInput = {
  /** Create and connect one OldColumn document */
  create?: InputMaybe<OldColumnCreateInput>;
};

export type OldColumnCreateWithPositionInput = {
  /** Document to create */
  data: OldColumnCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type OldColumnEdge = {
  __typename?: 'OldColumnEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: OldColumn;
};

/** Identifies documents */
export type OldColumnManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<OldColumnWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<OldColumnWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<OldColumnWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  contactCard?: InputMaybe<ContactCardWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  pages_every?: InputMaybe<PageWhereInput>;
  pages_none?: InputMaybe<PageWhereInput>;
  pages_some?: InputMaybe<PageWhereInput>;
};

export enum OldColumnOrderByInput {
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  TitleAsc = 'title_ASC',
  TitleDesc = 'title_DESC'
}

export type OldColumnParent = Footer | Page;

export type OldColumnParentConnectInput = {
  Footer?: InputMaybe<FooterConnectInput>;
  Page?: InputMaybe<PageConnectInput>;
};

export type OldColumnParentCreateInput = {
  Footer?: InputMaybe<FooterCreateInput>;
  Page?: InputMaybe<PageCreateInput>;
};

export type OldColumnParentCreateManyInlineInput = {
  /** Connect multiple existing OldColumnParent documents */
  connect?: InputMaybe<Array<OldColumnParentWhereUniqueInput>>;
  /** Create and connect multiple existing OldColumnParent documents */
  create?: InputMaybe<Array<OldColumnParentCreateInput>>;
};

export type OldColumnParentCreateOneInlineInput = {
  /** Connect one existing OldColumnParent document */
  connect?: InputMaybe<OldColumnParentWhereUniqueInput>;
  /** Create and connect one OldColumnParent document */
  create?: InputMaybe<OldColumnParentCreateInput>;
};

export type OldColumnParentUpdateInput = {
  Footer?: InputMaybe<FooterUpdateInput>;
  Page?: InputMaybe<PageUpdateInput>;
};

export type OldColumnParentUpdateManyInlineInput = {
  /** Connect multiple existing OldColumnParent documents */
  connect?: InputMaybe<Array<OldColumnParentConnectInput>>;
  /** Create and connect multiple OldColumnParent documents */
  create?: InputMaybe<Array<OldColumnParentCreateInput>>;
  /** Delete multiple OldColumnParent documents */
  delete?: InputMaybe<Array<OldColumnParentWhereUniqueInput>>;
  /** Disconnect multiple OldColumnParent documents */
  disconnect?: InputMaybe<Array<OldColumnParentWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing OldColumnParent documents */
  set?: InputMaybe<Array<OldColumnParentWhereUniqueInput>>;
  /** Update multiple OldColumnParent documents */
  update?: InputMaybe<Array<OldColumnParentUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple OldColumnParent documents */
  upsert?: InputMaybe<Array<OldColumnParentUpsertWithNestedWhereUniqueInput>>;
};

export type OldColumnParentUpdateManyWithNestedWhereInput = {
  Footer?: InputMaybe<FooterUpdateManyWithNestedWhereInput>;
  Page?: InputMaybe<PageUpdateManyWithNestedWhereInput>;
};

export type OldColumnParentUpdateOneInlineInput = {
  /** Connect existing OldColumnParent document */
  connect?: InputMaybe<OldColumnParentWhereUniqueInput>;
  /** Create and connect one OldColumnParent document */
  create?: InputMaybe<OldColumnParentCreateInput>;
  /** Delete currently connected OldColumnParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected OldColumnParent document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single OldColumnParent document */
  update?: InputMaybe<OldColumnParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single OldColumnParent document */
  upsert?: InputMaybe<OldColumnParentUpsertWithNestedWhereUniqueInput>;
};

export type OldColumnParentUpdateWithNestedWhereUniqueInput = {
  Footer?: InputMaybe<FooterUpdateWithNestedWhereUniqueInput>;
  Page?: InputMaybe<PageUpdateWithNestedWhereUniqueInput>;
};

export type OldColumnParentUpsertWithNestedWhereUniqueInput = {
  Footer?: InputMaybe<FooterUpsertWithNestedWhereUniqueInput>;
  Page?: InputMaybe<PageUpsertWithNestedWhereUniqueInput>;
};

export type OldColumnParentWhereInput = {
  Footer?: InputMaybe<FooterWhereInput>;
  Page?: InputMaybe<PageWhereInput>;
};

export type OldColumnParentWhereUniqueInput = {
  Footer?: InputMaybe<FooterWhereUniqueInput>;
  Page?: InputMaybe<PageWhereUniqueInput>;
};

export type OldColumnUpdateInput = {
  contactCard?: InputMaybe<ContactCardUpdateOneInlineInput>;
  /** Manage document localizations */
  localizations?: InputMaybe<OldColumnUpdateLocalizationsInput>;
  pages?: InputMaybe<PageUpdateManyInlineInput>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
};

export type OldColumnUpdateLocalizationDataInput = {
  title?: InputMaybe<Scalars['String']>;
};

export type OldColumnUpdateLocalizationInput = {
  data: OldColumnUpdateLocalizationDataInput;
  locale: Locale;
};

export type OldColumnUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<OldColumnCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<OldColumnUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<OldColumnUpsertLocalizationInput>>;
};

export type OldColumnUpdateManyInlineInput = {
  /** Create and connect multiple OldColumn component instances */
  create?: InputMaybe<Array<OldColumnCreateWithPositionInput>>;
  /** Delete multiple OldColumn documents */
  delete?: InputMaybe<Array<OldColumnWhereUniqueInput>>;
  /** Update multiple OldColumn component instances */
  update?: InputMaybe<Array<OldColumnUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple OldColumn component instances */
  upsert?: InputMaybe<Array<OldColumnUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type OldColumnUpdateManyInput = {
  /** Optional updates to localizations */
  localizations?: InputMaybe<OldColumnUpdateManyLocalizationsInput>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
};

export type OldColumnUpdateManyLocalizationDataInput = {
  title?: InputMaybe<Scalars['String']>;
};

export type OldColumnUpdateManyLocalizationInput = {
  data: OldColumnUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type OldColumnUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<OldColumnUpdateManyLocalizationInput>>;
};

export type OldColumnUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: OldColumnUpdateManyInput;
  /** Document search */
  where: OldColumnWhereInput;
};

export type OldColumnUpdateOneInlineInput = {
  /** Create and connect one OldColumn document */
  create?: InputMaybe<OldColumnCreateInput>;
  /** Delete currently connected OldColumn document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single OldColumn document */
  update?: InputMaybe<OldColumnUpdateWithNestedWhereUniqueInput>;
  /** Upsert single OldColumn document */
  upsert?: InputMaybe<OldColumnUpsertWithNestedWhereUniqueInput>;
};

export type OldColumnUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<OldColumnUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: OldColumnWhereUniqueInput;
};

export type OldColumnUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: OldColumnUpdateInput;
  /** Unique document search */
  where: OldColumnWhereUniqueInput;
};

export type OldColumnUpsertInput = {
  /** Create document if it didn't exist */
  create: OldColumnCreateInput;
  /** Update document if it exists */
  update: OldColumnUpdateInput;
};

export type OldColumnUpsertLocalizationInput = {
  create: OldColumnCreateLocalizationDataInput;
  locale: Locale;
  update: OldColumnUpdateLocalizationDataInput;
};

export type OldColumnUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<OldColumnUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: OldColumnWhereUniqueInput;
};

export type OldColumnUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: OldColumnUpsertInput;
  /** Unique document search */
  where: OldColumnWhereUniqueInput;
};

/** Identifies documents */
export type OldColumnWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<OldColumnWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<OldColumnWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<OldColumnWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  contactCard?: InputMaybe<ContactCardWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  pages_every?: InputMaybe<PageWhereInput>;
  pages_none?: InputMaybe<PageWhereInput>;
  pages_some?: InputMaybe<PageWhereInput>;
  title?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  title_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  title_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  title_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  title_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  title_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  title_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  title_starts_with?: InputMaybe<Scalars['String']>;
};

/** References OldColumn record uniquely */
export type OldColumnWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export type Page = Node & {
  __typename?: 'Page';
  blocs: Array<PageblocsUnion>;
  /** The time the document was created */
  createdAt: Scalars['DateTime'];
  /** User that created this document */
  createdBy?: Maybe<User>;
  /** Get the document in other stages */
  documentInStages: Array<Page>;
  /** List of Page versions */
  history: Array<Version>;
  /** The unique identifier */
  id: Scalars['ID'];
  layout?: Maybe<Layout>;
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<Page>;
  /** This field represents the label for the navigation */
  navigationLabel: Scalars['String'];
  /** The time the document was published. Null on documents in draft stage. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** User that last published this document */
  publishedBy?: Maybe<User>;
  scheduledIn: Array<ScheduledOperation>;
  /** search engine optimization information for the given page. */
  seo?: Maybe<Seo>;
  slug: Scalars['String'];
  /** System stage field */
  stage: Stage;
  title: Scalars['String'];
  /** The time the document was updated */
  updatedAt: Scalars['DateTime'];
  /** User that last updated this document */
  updatedBy?: Maybe<User>;
};


export type PageBlocsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
};


export type PageCreatedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type PageCreatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type PageDocumentInStagesArgs = {
  includeCurrent?: Scalars['Boolean'];
  inheritLocale?: Scalars['Boolean'];
  stages?: Array<Stage>;
};


export type PageHistoryArgs = {
  limit?: Scalars['Int'];
  skip?: Scalars['Int'];
  stageOverride?: InputMaybe<Stage>;
};


export type PageLayoutArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type PageLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};


export type PagePublishedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type PagePublishedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type PageScheduledInArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ScheduledOperationWhereInput>;
};


export type PageSeoArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type PageUpdatedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type PageUpdatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};

export type PageConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: PageWhereUniqueInput;
};

/** A connection to a list of items. */
export type PageConnection = {
  __typename?: 'PageConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<PageEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type PageCreateInput = {
  blocs?: InputMaybe<PageblocsUnionCreateManyInlineInput>;
  cl6ahixkm016701un8kfa61nv?: InputMaybe<OldButtonCreateManyInlineInput>;
  cl6ajoqhz02sl01um8mzl59tf?: InputMaybe<NavigationCreateManyInlineInput>;
  cl6chxw7c160401ui1kv70qmi?: InputMaybe<OldColumnCreateManyInlineInput>;
  cl6gud9ss3ldn01uhe0gpb0wf?: InputMaybe<FormCreateManyInlineInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  layout?: InputMaybe<LayoutCreateOneInlineInput>;
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<PageCreateLocalizationsInput>;
  /** navigationLabel input for default locale (en) */
  navigationLabel: Scalars['String'];
  seo?: InputMaybe<SeoCreateOneInlineInput>;
  slug: Scalars['String'];
  title: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type PageCreateLocalizationDataInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  navigationLabel: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type PageCreateLocalizationInput = {
  /** Localization input */
  data: PageCreateLocalizationDataInput;
  locale: Locale;
};

export type PageCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<PageCreateLocalizationInput>>;
};

export type PageCreateManyInlineInput = {
  /** Connect multiple existing Page documents */
  connect?: InputMaybe<Array<PageWhereUniqueInput>>;
  /** Create and connect multiple existing Page documents */
  create?: InputMaybe<Array<PageCreateInput>>;
};

export type PageCreateOneInlineInput = {
  /** Connect one existing Page document */
  connect?: InputMaybe<PageWhereUniqueInput>;
  /** Create and connect one Page document */
  create?: InputMaybe<PageCreateInput>;
};

/** An edge in a connection. */
export type PageEdge = {
  __typename?: 'PageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Page;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** Number of items in the current page. */
  pageSize?: Maybe<Scalars['Int']>;
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>;
};

/** Identifies documents */
export type PageManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<PageWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<PageWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<PageWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  layout?: InputMaybe<LayoutWhereInput>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  seo?: InputMaybe<SeoWhereInput>;
  slug?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  slug_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  slug_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  slug_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  slug_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  slug_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  slug_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  slug_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  slug_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  slug_starts_with?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  title_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  title_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  title_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  title_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  title_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  title_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  title_starts_with?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

export enum PageOrderByInput {
  CreatedAtAsc = 'createdAt_ASC',
  CreatedAtDesc = 'createdAt_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  NavigationLabelAsc = 'navigationLabel_ASC',
  NavigationLabelDesc = 'navigationLabel_DESC',
  PublishedAtAsc = 'publishedAt_ASC',
  PublishedAtDesc = 'publishedAt_DESC',
  SlugAsc = 'slug_ASC',
  SlugDesc = 'slug_DESC',
  TitleAsc = 'title_ASC',
  TitleDesc = 'title_DESC',
  UpdatedAtAsc = 'updatedAt_ASC',
  UpdatedAtDesc = 'updatedAt_DESC'
}

export type PageUpdateInput = {
  blocs?: InputMaybe<PageblocsUnionUpdateManyInlineInput>;
  cl6ahixkm016701un8kfa61nv?: InputMaybe<OldButtonUpdateManyInlineInput>;
  cl6ajoqhz02sl01um8mzl59tf?: InputMaybe<NavigationUpdateManyInlineInput>;
  cl6chxw7c160401ui1kv70qmi?: InputMaybe<OldColumnUpdateManyInlineInput>;
  cl6gud9ss3ldn01uhe0gpb0wf?: InputMaybe<FormUpdateManyInlineInput>;
  layout?: InputMaybe<LayoutUpdateOneInlineInput>;
  /** Manage document localizations */
  localizations?: InputMaybe<PageUpdateLocalizationsInput>;
  /** navigationLabel input for default locale (en) */
  navigationLabel?: InputMaybe<Scalars['String']>;
  seo?: InputMaybe<SeoUpdateOneInlineInput>;
  slug?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export type PageUpdateLocalizationDataInput = {
  navigationLabel?: InputMaybe<Scalars['String']>;
};

export type PageUpdateLocalizationInput = {
  data: PageUpdateLocalizationDataInput;
  locale: Locale;
};

export type PageUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<PageCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<PageUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<PageUpsertLocalizationInput>>;
};

export type PageUpdateManyInlineInput = {
  /** Connect multiple existing Page documents */
  connect?: InputMaybe<Array<PageConnectInput>>;
  /** Create and connect multiple Page documents */
  create?: InputMaybe<Array<PageCreateInput>>;
  /** Delete multiple Page documents */
  delete?: InputMaybe<Array<PageWhereUniqueInput>>;
  /** Disconnect multiple Page documents */
  disconnect?: InputMaybe<Array<PageWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing Page documents */
  set?: InputMaybe<Array<PageWhereUniqueInput>>;
  /** Update multiple Page documents */
  update?: InputMaybe<Array<PageUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple Page documents */
  upsert?: InputMaybe<Array<PageUpsertWithNestedWhereUniqueInput>>;
};

export type PageUpdateManyInput = {
  /** No fields in updateMany data input */
  _?: InputMaybe<Scalars['String']>;
};

export type PageUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: PageUpdateManyInput;
  /** Document search */
  where: PageWhereInput;
};

export type PageUpdateOneInlineInput = {
  /** Connect existing Page document */
  connect?: InputMaybe<PageWhereUniqueInput>;
  /** Create and connect one Page document */
  create?: InputMaybe<PageCreateInput>;
  /** Delete currently connected Page document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected Page document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single Page document */
  update?: InputMaybe<PageUpdateWithNestedWhereUniqueInput>;
  /** Upsert single Page document */
  upsert?: InputMaybe<PageUpsertWithNestedWhereUniqueInput>;
};

export type PageUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: PageUpdateInput;
  /** Unique document search */
  where: PageWhereUniqueInput;
};

export type PageUpsertInput = {
  /** Create document if it didn't exist */
  create: PageCreateInput;
  /** Update document if it exists */
  update: PageUpdateInput;
};

export type PageUpsertLocalizationInput = {
  create: PageCreateLocalizationDataInput;
  locale: Locale;
  update: PageUpdateLocalizationDataInput;
};

export type PageUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: PageUpsertInput;
  /** Unique document search */
  where: PageWhereUniqueInput;
};

/** Identifies documents */
export type PageWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<PageWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<PageWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<PageWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  layout?: InputMaybe<LayoutWhereInput>;
  navigationLabel?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  navigationLabel_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  navigationLabel_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  navigationLabel_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  navigationLabel_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  navigationLabel_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  navigationLabel_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  navigationLabel_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  navigationLabel_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  navigationLabel_starts_with?: InputMaybe<Scalars['String']>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  seo?: InputMaybe<SeoWhereInput>;
  slug?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  slug_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  slug_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  slug_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  slug_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  slug_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  slug_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  slug_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  slug_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  slug_starts_with?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  title_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  title_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  title_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  title_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  title_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  title_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  title_starts_with?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

/** References Page record uniquely */
export type PageWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
  slug?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export type PageblocsUnion = AssociationProfileSection | Carousel | Grid | Hero | JoinUsSection | OldColumn | ProjectsContainer | Section | SectionWithImage | SponsorSection | TeamSection;

export type PageblocsUnionConnectInput = {
  AssociationProfileSection?: InputMaybe<AssociationProfileSectionConnectInput>;
  Carousel?: InputMaybe<CarouselConnectInput>;
  Grid?: InputMaybe<GridConnectInput>;
  Hero?: InputMaybe<HeroConnectInput>;
  JoinUsSection?: InputMaybe<JoinUsSectionConnectInput>;
  OldColumn?: InputMaybe<OldColumnConnectInput>;
  ProjectsContainer?: InputMaybe<ProjectsContainerConnectInput>;
  Section?: InputMaybe<SectionConnectInput>;
  SectionWithImage?: InputMaybe<SectionWithImageConnectInput>;
  SponsorSection?: InputMaybe<SponsorSectionConnectInput>;
  TeamSection?: InputMaybe<TeamSectionConnectInput>;
};

export type PageblocsUnionCreateInput = {
  AssociationProfileSection?: InputMaybe<AssociationProfileSectionCreateInput>;
  Carousel?: InputMaybe<CarouselCreateInput>;
  Grid?: InputMaybe<GridCreateInput>;
  Hero?: InputMaybe<HeroCreateInput>;
  JoinUsSection?: InputMaybe<JoinUsSectionCreateInput>;
  OldColumn?: InputMaybe<OldColumnCreateInput>;
  ProjectsContainer?: InputMaybe<ProjectsContainerCreateInput>;
  Section?: InputMaybe<SectionCreateInput>;
  SectionWithImage?: InputMaybe<SectionWithImageCreateInput>;
  SponsorSection?: InputMaybe<SponsorSectionCreateInput>;
  TeamSection?: InputMaybe<TeamSectionCreateInput>;
};

export type PageblocsUnionCreateManyInlineInput = {
  /** Create and connect multiple existing PageblocsUnion documents */
  create?: InputMaybe<Array<PageblocsUnionCreateInput>>;
};

export type PageblocsUnionCreateOneInlineInput = {
  /** Create and connect one PageblocsUnion document */
  create?: InputMaybe<PageblocsUnionCreateInput>;
};

export type PageblocsUnionCreateWithPositionInput = {
  AssociationProfileSection?: InputMaybe<AssociationProfileSectionCreateWithPositionInput>;
  Carousel?: InputMaybe<CarouselCreateWithPositionInput>;
  Grid?: InputMaybe<GridCreateWithPositionInput>;
  Hero?: InputMaybe<HeroCreateWithPositionInput>;
  JoinUsSection?: InputMaybe<JoinUsSectionCreateWithPositionInput>;
  OldColumn?: InputMaybe<OldColumnCreateWithPositionInput>;
  ProjectsContainer?: InputMaybe<ProjectsContainerCreateWithPositionInput>;
  Section?: InputMaybe<SectionCreateWithPositionInput>;
  SectionWithImage?: InputMaybe<SectionWithImageCreateWithPositionInput>;
  SponsorSection?: InputMaybe<SponsorSectionCreateWithPositionInput>;
  TeamSection?: InputMaybe<TeamSectionCreateWithPositionInput>;
};

export type PageblocsUnionUpdateInput = {
  AssociationProfileSection?: InputMaybe<AssociationProfileSectionUpdateInput>;
  Carousel?: InputMaybe<CarouselUpdateInput>;
  Grid?: InputMaybe<GridUpdateInput>;
  Hero?: InputMaybe<HeroUpdateInput>;
  JoinUsSection?: InputMaybe<JoinUsSectionUpdateInput>;
  OldColumn?: InputMaybe<OldColumnUpdateInput>;
  ProjectsContainer?: InputMaybe<ProjectsContainerUpdateInput>;
  Section?: InputMaybe<SectionUpdateInput>;
  SectionWithImage?: InputMaybe<SectionWithImageUpdateInput>;
  SponsorSection?: InputMaybe<SponsorSectionUpdateInput>;
  TeamSection?: InputMaybe<TeamSectionUpdateInput>;
};

export type PageblocsUnionUpdateManyInlineInput = {
  /** Create and connect multiple PageblocsUnion component instances */
  create?: InputMaybe<Array<PageblocsUnionCreateWithPositionInput>>;
  /** Delete multiple PageblocsUnion documents */
  delete?: InputMaybe<Array<PageblocsUnionWhereUniqueInput>>;
  /** Update multiple PageblocsUnion component instances */
  update?: InputMaybe<Array<PageblocsUnionUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple PageblocsUnion component instances */
  upsert?: InputMaybe<Array<PageblocsUnionUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type PageblocsUnionUpdateManyWithNestedWhereInput = {
  AssociationProfileSection?: InputMaybe<AssociationProfileSectionUpdateManyWithNestedWhereInput>;
  Carousel?: InputMaybe<CarouselUpdateManyWithNestedWhereInput>;
  Grid?: InputMaybe<GridUpdateManyWithNestedWhereInput>;
  Hero?: InputMaybe<HeroUpdateManyWithNestedWhereInput>;
  JoinUsSection?: InputMaybe<JoinUsSectionUpdateManyWithNestedWhereInput>;
  OldColumn?: InputMaybe<OldColumnUpdateManyWithNestedWhereInput>;
  ProjectsContainer?: InputMaybe<ProjectsContainerUpdateManyWithNestedWhereInput>;
  Section?: InputMaybe<SectionUpdateManyWithNestedWhereInput>;
  SectionWithImage?: InputMaybe<SectionWithImageUpdateManyWithNestedWhereInput>;
  SponsorSection?: InputMaybe<SponsorSectionUpdateManyWithNestedWhereInput>;
  TeamSection?: InputMaybe<TeamSectionUpdateManyWithNestedWhereInput>;
};

export type PageblocsUnionUpdateOneInlineInput = {
  /** Create and connect one PageblocsUnion document */
  create?: InputMaybe<PageblocsUnionCreateInput>;
  /** Delete currently connected PageblocsUnion document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single PageblocsUnion document */
  update?: InputMaybe<PageblocsUnionUpdateWithNestedWhereUniqueInput>;
  /** Upsert single PageblocsUnion document */
  upsert?: InputMaybe<PageblocsUnionUpsertWithNestedWhereUniqueInput>;
};

export type PageblocsUnionUpdateWithNestedWhereUniqueAndPositionInput = {
  AssociationProfileSection?: InputMaybe<AssociationProfileSectionUpdateWithNestedWhereUniqueAndPositionInput>;
  Carousel?: InputMaybe<CarouselUpdateWithNestedWhereUniqueAndPositionInput>;
  Grid?: InputMaybe<GridUpdateWithNestedWhereUniqueAndPositionInput>;
  Hero?: InputMaybe<HeroUpdateWithNestedWhereUniqueAndPositionInput>;
  JoinUsSection?: InputMaybe<JoinUsSectionUpdateWithNestedWhereUniqueAndPositionInput>;
  OldColumn?: InputMaybe<OldColumnUpdateWithNestedWhereUniqueAndPositionInput>;
  ProjectsContainer?: InputMaybe<ProjectsContainerUpdateWithNestedWhereUniqueAndPositionInput>;
  Section?: InputMaybe<SectionUpdateWithNestedWhereUniqueAndPositionInput>;
  SectionWithImage?: InputMaybe<SectionWithImageUpdateWithNestedWhereUniqueAndPositionInput>;
  SponsorSection?: InputMaybe<SponsorSectionUpdateWithNestedWhereUniqueAndPositionInput>;
  TeamSection?: InputMaybe<TeamSectionUpdateWithNestedWhereUniqueAndPositionInput>;
};

export type PageblocsUnionUpdateWithNestedWhereUniqueInput = {
  AssociationProfileSection?: InputMaybe<AssociationProfileSectionUpdateWithNestedWhereUniqueInput>;
  Carousel?: InputMaybe<CarouselUpdateWithNestedWhereUniqueInput>;
  Grid?: InputMaybe<GridUpdateWithNestedWhereUniqueInput>;
  Hero?: InputMaybe<HeroUpdateWithNestedWhereUniqueInput>;
  JoinUsSection?: InputMaybe<JoinUsSectionUpdateWithNestedWhereUniqueInput>;
  OldColumn?: InputMaybe<OldColumnUpdateWithNestedWhereUniqueInput>;
  ProjectsContainer?: InputMaybe<ProjectsContainerUpdateWithNestedWhereUniqueInput>;
  Section?: InputMaybe<SectionUpdateWithNestedWhereUniqueInput>;
  SectionWithImage?: InputMaybe<SectionWithImageUpdateWithNestedWhereUniqueInput>;
  SponsorSection?: InputMaybe<SponsorSectionUpdateWithNestedWhereUniqueInput>;
  TeamSection?: InputMaybe<TeamSectionUpdateWithNestedWhereUniqueInput>;
};

export type PageblocsUnionUpsertWithNestedWhereUniqueAndPositionInput = {
  AssociationProfileSection?: InputMaybe<AssociationProfileSectionUpsertWithNestedWhereUniqueAndPositionInput>;
  Carousel?: InputMaybe<CarouselUpsertWithNestedWhereUniqueAndPositionInput>;
  Grid?: InputMaybe<GridUpsertWithNestedWhereUniqueAndPositionInput>;
  Hero?: InputMaybe<HeroUpsertWithNestedWhereUniqueAndPositionInput>;
  JoinUsSection?: InputMaybe<JoinUsSectionUpsertWithNestedWhereUniqueAndPositionInput>;
  OldColumn?: InputMaybe<OldColumnUpsertWithNestedWhereUniqueAndPositionInput>;
  ProjectsContainer?: InputMaybe<ProjectsContainerUpsertWithNestedWhereUniqueAndPositionInput>;
  Section?: InputMaybe<SectionUpsertWithNestedWhereUniqueAndPositionInput>;
  SectionWithImage?: InputMaybe<SectionWithImageUpsertWithNestedWhereUniqueAndPositionInput>;
  SponsorSection?: InputMaybe<SponsorSectionUpsertWithNestedWhereUniqueAndPositionInput>;
  TeamSection?: InputMaybe<TeamSectionUpsertWithNestedWhereUniqueAndPositionInput>;
};

export type PageblocsUnionUpsertWithNestedWhereUniqueInput = {
  AssociationProfileSection?: InputMaybe<AssociationProfileSectionUpsertWithNestedWhereUniqueInput>;
  Carousel?: InputMaybe<CarouselUpsertWithNestedWhereUniqueInput>;
  Grid?: InputMaybe<GridUpsertWithNestedWhereUniqueInput>;
  Hero?: InputMaybe<HeroUpsertWithNestedWhereUniqueInput>;
  JoinUsSection?: InputMaybe<JoinUsSectionUpsertWithNestedWhereUniqueInput>;
  OldColumn?: InputMaybe<OldColumnUpsertWithNestedWhereUniqueInput>;
  ProjectsContainer?: InputMaybe<ProjectsContainerUpsertWithNestedWhereUniqueInput>;
  Section?: InputMaybe<SectionUpsertWithNestedWhereUniqueInput>;
  SectionWithImage?: InputMaybe<SectionWithImageUpsertWithNestedWhereUniqueInput>;
  SponsorSection?: InputMaybe<SponsorSectionUpsertWithNestedWhereUniqueInput>;
  TeamSection?: InputMaybe<TeamSectionUpsertWithNestedWhereUniqueInput>;
};

export type PageblocsUnionWhereInput = {
  AssociationProfileSection?: InputMaybe<AssociationProfileSectionWhereInput>;
  Carousel?: InputMaybe<CarouselWhereInput>;
  Grid?: InputMaybe<GridWhereInput>;
  Hero?: InputMaybe<HeroWhereInput>;
  JoinUsSection?: InputMaybe<JoinUsSectionWhereInput>;
  OldColumn?: InputMaybe<OldColumnWhereInput>;
  ProjectsContainer?: InputMaybe<ProjectsContainerWhereInput>;
  Section?: InputMaybe<SectionWhereInput>;
  SectionWithImage?: InputMaybe<SectionWithImageWhereInput>;
  SponsorSection?: InputMaybe<SponsorSectionWhereInput>;
  TeamSection?: InputMaybe<TeamSectionWhereInput>;
};

export type PageblocsUnionWhereUniqueInput = {
  AssociationProfileSection?: InputMaybe<AssociationProfileSectionWhereUniqueInput>;
  Carousel?: InputMaybe<CarouselWhereUniqueInput>;
  Grid?: InputMaybe<GridWhereUniqueInput>;
  Hero?: InputMaybe<HeroWhereUniqueInput>;
  JoinUsSection?: InputMaybe<JoinUsSectionWhereUniqueInput>;
  OldColumn?: InputMaybe<OldColumnWhereUniqueInput>;
  ProjectsContainer?: InputMaybe<ProjectsContainerWhereUniqueInput>;
  Section?: InputMaybe<SectionWhereUniqueInput>;
  SectionWithImage?: InputMaybe<SectionWithImageWhereUniqueInput>;
  SponsorSection?: InputMaybe<SponsorSectionWhereUniqueInput>;
  TeamSection?: InputMaybe<TeamSectionWhereUniqueInput>;
};

export type Person = Node & {
  __typename?: 'Person';
  card?: Maybe<Card>;
  /** The time the document was created */
  createdAt: Scalars['DateTime'];
  /** User that created this document */
  createdBy?: Maybe<User>;
  /** Get the document in other stages */
  documentInStages: Array<Person>;
  /** List of Person versions */
  history: Array<Version>;
  /** The unique identifier */
  id: Scalars['ID'];
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<Person>;
  name: Scalars['String'];
  photo?: Maybe<Asset>;
  position?: Maybe<Scalars['String']>;
  /** The time the document was published. Null on documents in draft stage. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** User that last published this document */
  publishedBy?: Maybe<User>;
  roleDescription?: Maybe<Scalars['String']>;
  scheduledIn: Array<ScheduledOperation>;
  /** System stage field */
  stage: Stage;
  /** The time the document was updated */
  updatedAt: Scalars['DateTime'];
  /** User that last updated this document */
  updatedBy?: Maybe<User>;
};


export type PersonCardArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type PersonCreatedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type PersonCreatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type PersonDocumentInStagesArgs = {
  includeCurrent?: Scalars['Boolean'];
  inheritLocale?: Scalars['Boolean'];
  stages?: Array<Stage>;
};


export type PersonHistoryArgs = {
  limit?: Scalars['Int'];
  skip?: Scalars['Int'];
  stageOverride?: InputMaybe<Stage>;
};


export type PersonLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};


export type PersonPhotoArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type PersonPublishedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type PersonPublishedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type PersonScheduledInArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ScheduledOperationWhereInput>;
};


export type PersonUpdatedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type PersonUpdatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};

export type PersonConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: PersonWhereUniqueInput;
};

/** A connection to a list of items. */
export type PersonConnection = {
  __typename?: 'PersonConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<PersonEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type PersonCreateInput = {
  card?: InputMaybe<CardCreateOneInlineInput>;
  cl6fgehwa2dcv01uq1v4zbiot?: InputMaybe<TeamSectionCreateManyInlineInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<PersonCreateLocalizationsInput>;
  name: Scalars['String'];
  photo?: InputMaybe<AssetCreateOneInlineInput>;
  /** position input for default locale (en) */
  position?: InputMaybe<Scalars['String']>;
  /** roleDescription input for default locale (en) */
  roleDescription?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type PersonCreateLocalizationDataInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  position?: InputMaybe<Scalars['String']>;
  roleDescription?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type PersonCreateLocalizationInput = {
  /** Localization input */
  data: PersonCreateLocalizationDataInput;
  locale: Locale;
};

export type PersonCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<PersonCreateLocalizationInput>>;
};

export type PersonCreateManyInlineInput = {
  /** Connect multiple existing Person documents */
  connect?: InputMaybe<Array<PersonWhereUniqueInput>>;
  /** Create and connect multiple existing Person documents */
  create?: InputMaybe<Array<PersonCreateInput>>;
};

export type PersonCreateOneInlineInput = {
  /** Connect one existing Person document */
  connect?: InputMaybe<PersonWhereUniqueInput>;
  /** Create and connect one Person document */
  create?: InputMaybe<PersonCreateInput>;
};

/** An edge in a connection. */
export type PersonEdge = {
  __typename?: 'PersonEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Person;
};

/** Identifies documents */
export type PersonManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<PersonWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<PersonWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<PersonWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  card?: InputMaybe<CardWhereInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  name?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  name_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  name_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  name_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  name_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  name_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  name_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  name_starts_with?: InputMaybe<Scalars['String']>;
  photo?: InputMaybe<AssetWhereInput>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

export enum PersonOrderByInput {
  CreatedAtAsc = 'createdAt_ASC',
  CreatedAtDesc = 'createdAt_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  NameAsc = 'name_ASC',
  NameDesc = 'name_DESC',
  PositionAsc = 'position_ASC',
  PositionDesc = 'position_DESC',
  PublishedAtAsc = 'publishedAt_ASC',
  PublishedAtDesc = 'publishedAt_DESC',
  RoleDescriptionAsc = 'roleDescription_ASC',
  RoleDescriptionDesc = 'roleDescription_DESC',
  UpdatedAtAsc = 'updatedAt_ASC',
  UpdatedAtDesc = 'updatedAt_DESC'
}

export type PersonUpdateInput = {
  card?: InputMaybe<CardUpdateOneInlineInput>;
  cl6fgehwa2dcv01uq1v4zbiot?: InputMaybe<TeamSectionUpdateManyInlineInput>;
  /** Manage document localizations */
  localizations?: InputMaybe<PersonUpdateLocalizationsInput>;
  name?: InputMaybe<Scalars['String']>;
  photo?: InputMaybe<AssetUpdateOneInlineInput>;
  /** position input for default locale (en) */
  position?: InputMaybe<Scalars['String']>;
  /** roleDescription input for default locale (en) */
  roleDescription?: InputMaybe<Scalars['String']>;
};

export type PersonUpdateLocalizationDataInput = {
  position?: InputMaybe<Scalars['String']>;
  roleDescription?: InputMaybe<Scalars['String']>;
};

export type PersonUpdateLocalizationInput = {
  data: PersonUpdateLocalizationDataInput;
  locale: Locale;
};

export type PersonUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<PersonCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<PersonUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<PersonUpsertLocalizationInput>>;
};

export type PersonUpdateManyInlineInput = {
  /** Connect multiple existing Person documents */
  connect?: InputMaybe<Array<PersonConnectInput>>;
  /** Create and connect multiple Person documents */
  create?: InputMaybe<Array<PersonCreateInput>>;
  /** Delete multiple Person documents */
  delete?: InputMaybe<Array<PersonWhereUniqueInput>>;
  /** Disconnect multiple Person documents */
  disconnect?: InputMaybe<Array<PersonWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing Person documents */
  set?: InputMaybe<Array<PersonWhereUniqueInput>>;
  /** Update multiple Person documents */
  update?: InputMaybe<Array<PersonUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple Person documents */
  upsert?: InputMaybe<Array<PersonUpsertWithNestedWhereUniqueInput>>;
};

export type PersonUpdateManyInput = {
  /** Optional updates to localizations */
  localizations?: InputMaybe<PersonUpdateManyLocalizationsInput>;
  name?: InputMaybe<Scalars['String']>;
  /** position input for default locale (en) */
  position?: InputMaybe<Scalars['String']>;
  /** roleDescription input for default locale (en) */
  roleDescription?: InputMaybe<Scalars['String']>;
};

export type PersonUpdateManyLocalizationDataInput = {
  position?: InputMaybe<Scalars['String']>;
  roleDescription?: InputMaybe<Scalars['String']>;
};

export type PersonUpdateManyLocalizationInput = {
  data: PersonUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type PersonUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<PersonUpdateManyLocalizationInput>>;
};

export type PersonUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: PersonUpdateManyInput;
  /** Document search */
  where: PersonWhereInput;
};

export type PersonUpdateOneInlineInput = {
  /** Connect existing Person document */
  connect?: InputMaybe<PersonWhereUniqueInput>;
  /** Create and connect one Person document */
  create?: InputMaybe<PersonCreateInput>;
  /** Delete currently connected Person document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected Person document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single Person document */
  update?: InputMaybe<PersonUpdateWithNestedWhereUniqueInput>;
  /** Upsert single Person document */
  upsert?: InputMaybe<PersonUpsertWithNestedWhereUniqueInput>;
};

export type PersonUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: PersonUpdateInput;
  /** Unique document search */
  where: PersonWhereUniqueInput;
};

export type PersonUpsertInput = {
  /** Create document if it didn't exist */
  create: PersonCreateInput;
  /** Update document if it exists */
  update: PersonUpdateInput;
};

export type PersonUpsertLocalizationInput = {
  create: PersonCreateLocalizationDataInput;
  locale: Locale;
  update: PersonUpdateLocalizationDataInput;
};

export type PersonUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: PersonUpsertInput;
  /** Unique document search */
  where: PersonWhereUniqueInput;
};

/** Identifies documents */
export type PersonWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<PersonWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<PersonWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<PersonWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  card?: InputMaybe<CardWhereInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  name?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  name_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  name_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  name_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  name_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  name_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  name_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  name_starts_with?: InputMaybe<Scalars['String']>;
  photo?: InputMaybe<AssetWhereInput>;
  position?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  position_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  position_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  position_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  position_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  position_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  position_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  position_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  position_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  position_starts_with?: InputMaybe<Scalars['String']>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  roleDescription?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  roleDescription_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  roleDescription_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  roleDescription_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  roleDescription_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  roleDescription_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  roleDescription_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  roleDescription_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  roleDescription_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  roleDescription_starts_with?: InputMaybe<Scalars['String']>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

/** References Person record uniquely */
export type PersonWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export enum PositionType {
  Absolute = 'ABSOLUTE',
  Relative = 'RELATIVE'
}

export type Project = Node & {
  __typename?: 'Project';
  card?: Maybe<Card>;
  /** The time the document was created */
  createdAt: Scalars['DateTime'];
  /** User that created this document */
  createdBy?: Maybe<User>;
  description: RichText;
  details: Scalars['String'];
  /** Get the document in other stages */
  documentInStages: Array<Project>;
  /** Add all the assets you may like to associate to a project  */
  gellery: Array<Asset>;
  /** List of Project versions */
  history: Array<Version>;
  /** The unique identifier */
  id: Scalars['ID'];
  image?: Maybe<Asset>;
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<Project>;
  name: Scalars['String'];
  projectCategories: Array<ProjectCategory>;
  /** The time the document was published. Null on documents in draft stage. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** User that last published this document */
  publishedBy?: Maybe<User>;
  scheduledIn: Array<ScheduledOperation>;
  slug: Scalars['String'];
  /** System stage field */
  stage: Stage;
  /** The time the document was updated */
  updatedAt: Scalars['DateTime'];
  /** User that last updated this document */
  updatedBy?: Maybe<User>;
};


export type ProjectCardArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type ProjectCreatedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type ProjectCreatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type ProjectDocumentInStagesArgs = {
  includeCurrent?: Scalars['Boolean'];
  inheritLocale?: Scalars['Boolean'];
  stages?: Array<Stage>;
};


export type ProjectGelleryArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  orderBy?: InputMaybe<AssetOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AssetWhereInput>;
};


export type ProjectHistoryArgs = {
  limit?: Scalars['Int'];
  skip?: Scalars['Int'];
  stageOverride?: InputMaybe<Stage>;
};


export type ProjectImageArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type ProjectLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};


export type ProjectProjectCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  orderBy?: InputMaybe<ProjectCategoryOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ProjectCategoryWhereInput>;
};


export type ProjectPublishedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type ProjectPublishedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type ProjectScheduledInArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ScheduledOperationWhereInput>;
};


export type ProjectUpdatedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type ProjectUpdatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};

export type ProjectCategory = Node & {
  __typename?: 'ProjectCategory';
  /** The time the document was created */
  createdAt: Scalars['DateTime'];
  /** User that created this document */
  createdBy?: Maybe<User>;
  /** Get the document in other stages */
  documentInStages: Array<ProjectCategory>;
  /** List of ProjectCategory versions */
  history: Array<Version>;
  /** The unique identifier */
  id: Scalars['ID'];
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<ProjectCategory>;
  name: Scalars['String'];
  projects: Array<Project>;
  /** The time the document was published. Null on documents in draft stage. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** User that last published this document */
  publishedBy?: Maybe<User>;
  scheduledIn: Array<ScheduledOperation>;
  /** System stage field */
  stage: Stage;
  /** The time the document was updated */
  updatedAt: Scalars['DateTime'];
  /** User that last updated this document */
  updatedBy?: Maybe<User>;
};


export type ProjectCategoryCreatedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type ProjectCategoryCreatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type ProjectCategoryDocumentInStagesArgs = {
  includeCurrent?: Scalars['Boolean'];
  inheritLocale?: Scalars['Boolean'];
  stages?: Array<Stage>;
};


export type ProjectCategoryHistoryArgs = {
  limit?: Scalars['Int'];
  skip?: Scalars['Int'];
  stageOverride?: InputMaybe<Stage>;
};


export type ProjectCategoryLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};


export type ProjectCategoryProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  orderBy?: InputMaybe<ProjectOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ProjectWhereInput>;
};


export type ProjectCategoryPublishedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type ProjectCategoryPublishedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type ProjectCategoryScheduledInArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ScheduledOperationWhereInput>;
};


export type ProjectCategoryUpdatedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type ProjectCategoryUpdatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};

export type ProjectCategoryConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: ProjectCategoryWhereUniqueInput;
};

/** A connection to a list of items. */
export type ProjectCategoryConnection = {
  __typename?: 'ProjectCategoryConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<ProjectCategoryEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type ProjectCategoryCreateInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<ProjectCategoryCreateLocalizationsInput>;
  /** name input for default locale (en) */
  name: Scalars['String'];
  projects?: InputMaybe<ProjectCreateManyInlineInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type ProjectCategoryCreateLocalizationDataInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  name: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type ProjectCategoryCreateLocalizationInput = {
  /** Localization input */
  data: ProjectCategoryCreateLocalizationDataInput;
  locale: Locale;
};

export type ProjectCategoryCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<ProjectCategoryCreateLocalizationInput>>;
};

export type ProjectCategoryCreateManyInlineInput = {
  /** Connect multiple existing ProjectCategory documents */
  connect?: InputMaybe<Array<ProjectCategoryWhereUniqueInput>>;
  /** Create and connect multiple existing ProjectCategory documents */
  create?: InputMaybe<Array<ProjectCategoryCreateInput>>;
};

export type ProjectCategoryCreateOneInlineInput = {
  /** Connect one existing ProjectCategory document */
  connect?: InputMaybe<ProjectCategoryWhereUniqueInput>;
  /** Create and connect one ProjectCategory document */
  create?: InputMaybe<ProjectCategoryCreateInput>;
};

/** An edge in a connection. */
export type ProjectCategoryEdge = {
  __typename?: 'ProjectCategoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: ProjectCategory;
};

/** Identifies documents */
export type ProjectCategoryManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<ProjectCategoryWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<ProjectCategoryWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<ProjectCategoryWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  projects_every?: InputMaybe<ProjectWhereInput>;
  projects_none?: InputMaybe<ProjectWhereInput>;
  projects_some?: InputMaybe<ProjectWhereInput>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

export enum ProjectCategoryOrderByInput {
  CreatedAtAsc = 'createdAt_ASC',
  CreatedAtDesc = 'createdAt_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  NameAsc = 'name_ASC',
  NameDesc = 'name_DESC',
  PublishedAtAsc = 'publishedAt_ASC',
  PublishedAtDesc = 'publishedAt_DESC',
  UpdatedAtAsc = 'updatedAt_ASC',
  UpdatedAtDesc = 'updatedAt_DESC'
}

export type ProjectCategoryUpdateInput = {
  /** Manage document localizations */
  localizations?: InputMaybe<ProjectCategoryUpdateLocalizationsInput>;
  /** name input for default locale (en) */
  name?: InputMaybe<Scalars['String']>;
  projects?: InputMaybe<ProjectUpdateManyInlineInput>;
};

export type ProjectCategoryUpdateLocalizationDataInput = {
  name?: InputMaybe<Scalars['String']>;
};

export type ProjectCategoryUpdateLocalizationInput = {
  data: ProjectCategoryUpdateLocalizationDataInput;
  locale: Locale;
};

export type ProjectCategoryUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<ProjectCategoryCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<ProjectCategoryUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<ProjectCategoryUpsertLocalizationInput>>;
};

export type ProjectCategoryUpdateManyInlineInput = {
  /** Connect multiple existing ProjectCategory documents */
  connect?: InputMaybe<Array<ProjectCategoryConnectInput>>;
  /** Create and connect multiple ProjectCategory documents */
  create?: InputMaybe<Array<ProjectCategoryCreateInput>>;
  /** Delete multiple ProjectCategory documents */
  delete?: InputMaybe<Array<ProjectCategoryWhereUniqueInput>>;
  /** Disconnect multiple ProjectCategory documents */
  disconnect?: InputMaybe<Array<ProjectCategoryWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing ProjectCategory documents */
  set?: InputMaybe<Array<ProjectCategoryWhereUniqueInput>>;
  /** Update multiple ProjectCategory documents */
  update?: InputMaybe<Array<ProjectCategoryUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple ProjectCategory documents */
  upsert?: InputMaybe<Array<ProjectCategoryUpsertWithNestedWhereUniqueInput>>;
};

export type ProjectCategoryUpdateManyInput = {
  /** Optional updates to localizations */
  localizations?: InputMaybe<ProjectCategoryUpdateManyLocalizationsInput>;
  /** name input for default locale (en) */
  name?: InputMaybe<Scalars['String']>;
};

export type ProjectCategoryUpdateManyLocalizationDataInput = {
  name?: InputMaybe<Scalars['String']>;
};

export type ProjectCategoryUpdateManyLocalizationInput = {
  data: ProjectCategoryUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type ProjectCategoryUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<ProjectCategoryUpdateManyLocalizationInput>>;
};

export type ProjectCategoryUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: ProjectCategoryUpdateManyInput;
  /** Document search */
  where: ProjectCategoryWhereInput;
};

export type ProjectCategoryUpdateOneInlineInput = {
  /** Connect existing ProjectCategory document */
  connect?: InputMaybe<ProjectCategoryWhereUniqueInput>;
  /** Create and connect one ProjectCategory document */
  create?: InputMaybe<ProjectCategoryCreateInput>;
  /** Delete currently connected ProjectCategory document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected ProjectCategory document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single ProjectCategory document */
  update?: InputMaybe<ProjectCategoryUpdateWithNestedWhereUniqueInput>;
  /** Upsert single ProjectCategory document */
  upsert?: InputMaybe<ProjectCategoryUpsertWithNestedWhereUniqueInput>;
};

export type ProjectCategoryUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: ProjectCategoryUpdateInput;
  /** Unique document search */
  where: ProjectCategoryWhereUniqueInput;
};

export type ProjectCategoryUpsertInput = {
  /** Create document if it didn't exist */
  create: ProjectCategoryCreateInput;
  /** Update document if it exists */
  update: ProjectCategoryUpdateInput;
};

export type ProjectCategoryUpsertLocalizationInput = {
  create: ProjectCategoryCreateLocalizationDataInput;
  locale: Locale;
  update: ProjectCategoryUpdateLocalizationDataInput;
};

export type ProjectCategoryUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: ProjectCategoryUpsertInput;
  /** Unique document search */
  where: ProjectCategoryWhereUniqueInput;
};

/** Identifies documents */
export type ProjectCategoryWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<ProjectCategoryWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<ProjectCategoryWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<ProjectCategoryWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  name?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  name_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  name_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  name_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  name_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  name_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  name_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  name_starts_with?: InputMaybe<Scalars['String']>;
  projects_every?: InputMaybe<ProjectWhereInput>;
  projects_none?: InputMaybe<ProjectWhereInput>;
  projects_some?: InputMaybe<ProjectWhereInput>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

/** References ProjectCategory record uniquely */
export type ProjectCategoryWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export type ProjectConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: ProjectWhereUniqueInput;
};

/** A connection to a list of items. */
export type ProjectConnection = {
  __typename?: 'ProjectConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<ProjectEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type ProjectCreateInput = {
  card?: InputMaybe<CardCreateOneInlineInput>;
  cl6cd9zpr10uc01ui1eibc7jz?: InputMaybe<ProjectsContainerCreateManyInlineInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** description input for default locale (en) */
  description: Scalars['RichTextAST'];
  /** details input for default locale (en) */
  details: Scalars['String'];
  gellery?: InputMaybe<AssetCreateManyInlineInput>;
  image?: InputMaybe<AssetCreateOneInlineInput>;
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<ProjectCreateLocalizationsInput>;
  /** name input for default locale (en) */
  name: Scalars['String'];
  projectCategories?: InputMaybe<ProjectCategoryCreateManyInlineInput>;
  slug: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type ProjectCreateLocalizationDataInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  description: Scalars['RichTextAST'];
  details: Scalars['String'];
  name: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type ProjectCreateLocalizationInput = {
  /** Localization input */
  data: ProjectCreateLocalizationDataInput;
  locale: Locale;
};

export type ProjectCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<ProjectCreateLocalizationInput>>;
};

export type ProjectCreateManyInlineInput = {
  /** Connect multiple existing Project documents */
  connect?: InputMaybe<Array<ProjectWhereUniqueInput>>;
  /** Create and connect multiple existing Project documents */
  create?: InputMaybe<Array<ProjectCreateInput>>;
};

export type ProjectCreateOneInlineInput = {
  /** Connect one existing Project document */
  connect?: InputMaybe<ProjectWhereUniqueInput>;
  /** Create and connect one Project document */
  create?: InputMaybe<ProjectCreateInput>;
};

/** An edge in a connection. */
export type ProjectEdge = {
  __typename?: 'ProjectEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Project;
};

/** Identifies documents */
export type ProjectManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<ProjectWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<ProjectWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<ProjectWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  card?: InputMaybe<CardWhereInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  gellery_every?: InputMaybe<AssetWhereInput>;
  gellery_none?: InputMaybe<AssetWhereInput>;
  gellery_some?: InputMaybe<AssetWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  image?: InputMaybe<AssetWhereInput>;
  projectCategories_every?: InputMaybe<ProjectCategoryWhereInput>;
  projectCategories_none?: InputMaybe<ProjectCategoryWhereInput>;
  projectCategories_some?: InputMaybe<ProjectCategoryWhereInput>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  slug?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  slug_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  slug_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  slug_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  slug_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  slug_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  slug_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  slug_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  slug_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  slug_starts_with?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

export enum ProjectOrderByInput {
  CreatedAtAsc = 'createdAt_ASC',
  CreatedAtDesc = 'createdAt_DESC',
  DetailsAsc = 'details_ASC',
  DetailsDesc = 'details_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  NameAsc = 'name_ASC',
  NameDesc = 'name_DESC',
  PublishedAtAsc = 'publishedAt_ASC',
  PublishedAtDesc = 'publishedAt_DESC',
  SlugAsc = 'slug_ASC',
  SlugDesc = 'slug_DESC',
  UpdatedAtAsc = 'updatedAt_ASC',
  UpdatedAtDesc = 'updatedAt_DESC'
}

export type ProjectUpdateInput = {
  card?: InputMaybe<CardUpdateOneInlineInput>;
  cl6cd9zpr10uc01ui1eibc7jz?: InputMaybe<ProjectsContainerUpdateManyInlineInput>;
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['RichTextAST']>;
  /** details input for default locale (en) */
  details?: InputMaybe<Scalars['String']>;
  gellery?: InputMaybe<AssetUpdateManyInlineInput>;
  image?: InputMaybe<AssetUpdateOneInlineInput>;
  /** Manage document localizations */
  localizations?: InputMaybe<ProjectUpdateLocalizationsInput>;
  /** name input for default locale (en) */
  name?: InputMaybe<Scalars['String']>;
  projectCategories?: InputMaybe<ProjectCategoryUpdateManyInlineInput>;
  slug?: InputMaybe<Scalars['String']>;
};

export type ProjectUpdateLocalizationDataInput = {
  description?: InputMaybe<Scalars['RichTextAST']>;
  details?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
};

export type ProjectUpdateLocalizationInput = {
  data: ProjectUpdateLocalizationDataInput;
  locale: Locale;
};

export type ProjectUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<ProjectCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<ProjectUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<ProjectUpsertLocalizationInput>>;
};

export type ProjectUpdateManyInlineInput = {
  /** Connect multiple existing Project documents */
  connect?: InputMaybe<Array<ProjectConnectInput>>;
  /** Create and connect multiple Project documents */
  create?: InputMaybe<Array<ProjectCreateInput>>;
  /** Delete multiple Project documents */
  delete?: InputMaybe<Array<ProjectWhereUniqueInput>>;
  /** Disconnect multiple Project documents */
  disconnect?: InputMaybe<Array<ProjectWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing Project documents */
  set?: InputMaybe<Array<ProjectWhereUniqueInput>>;
  /** Update multiple Project documents */
  update?: InputMaybe<Array<ProjectUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple Project documents */
  upsert?: InputMaybe<Array<ProjectUpsertWithNestedWhereUniqueInput>>;
};

export type ProjectUpdateManyInput = {
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['RichTextAST']>;
  /** details input for default locale (en) */
  details?: InputMaybe<Scalars['String']>;
  /** Optional updates to localizations */
  localizations?: InputMaybe<ProjectUpdateManyLocalizationsInput>;
  /** name input for default locale (en) */
  name?: InputMaybe<Scalars['String']>;
};

export type ProjectUpdateManyLocalizationDataInput = {
  description?: InputMaybe<Scalars['RichTextAST']>;
  details?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
};

export type ProjectUpdateManyLocalizationInput = {
  data: ProjectUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type ProjectUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<ProjectUpdateManyLocalizationInput>>;
};

export type ProjectUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: ProjectUpdateManyInput;
  /** Document search */
  where: ProjectWhereInput;
};

export type ProjectUpdateOneInlineInput = {
  /** Connect existing Project document */
  connect?: InputMaybe<ProjectWhereUniqueInput>;
  /** Create and connect one Project document */
  create?: InputMaybe<ProjectCreateInput>;
  /** Delete currently connected Project document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected Project document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single Project document */
  update?: InputMaybe<ProjectUpdateWithNestedWhereUniqueInput>;
  /** Upsert single Project document */
  upsert?: InputMaybe<ProjectUpsertWithNestedWhereUniqueInput>;
};

export type ProjectUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: ProjectUpdateInput;
  /** Unique document search */
  where: ProjectWhereUniqueInput;
};

export type ProjectUpsertInput = {
  /** Create document if it didn't exist */
  create: ProjectCreateInput;
  /** Update document if it exists */
  update: ProjectUpdateInput;
};

export type ProjectUpsertLocalizationInput = {
  create: ProjectCreateLocalizationDataInput;
  locale: Locale;
  update: ProjectUpdateLocalizationDataInput;
};

export type ProjectUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: ProjectUpsertInput;
  /** Unique document search */
  where: ProjectWhereUniqueInput;
};

/** Identifies documents */
export type ProjectWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<ProjectWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<ProjectWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<ProjectWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  card?: InputMaybe<CardWhereInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  details?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  details_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  details_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  details_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  details_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  details_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  details_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  details_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  details_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  details_starts_with?: InputMaybe<Scalars['String']>;
  gellery_every?: InputMaybe<AssetWhereInput>;
  gellery_none?: InputMaybe<AssetWhereInput>;
  gellery_some?: InputMaybe<AssetWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  image?: InputMaybe<AssetWhereInput>;
  name?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  name_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  name_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  name_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  name_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  name_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  name_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  name_starts_with?: InputMaybe<Scalars['String']>;
  projectCategories_every?: InputMaybe<ProjectCategoryWhereInput>;
  projectCategories_none?: InputMaybe<ProjectCategoryWhereInput>;
  projectCategories_some?: InputMaybe<ProjectCategoryWhereInput>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  slug?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  slug_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  slug_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  slug_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  slug_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  slug_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  slug_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  slug_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  slug_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  slug_starts_with?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

/** References Project record uniquely */
export type ProjectWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
  slug?: InputMaybe<Scalars['String']>;
};

export type ProjectsContainer = {
  __typename?: 'ProjectsContainer';
  /** The unique identifier */
  id: Scalars['ID'];
  projects: Array<Project>;
  /** System stage field */
  stage: Stage;
};


export type ProjectsContainerProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  orderBy?: InputMaybe<ProjectOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ProjectWhereInput>;
};

export type ProjectsContainerConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: ProjectsContainerWhereUniqueInput;
};

/** A connection to a list of items. */
export type ProjectsContainerConnection = {
  __typename?: 'ProjectsContainerConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<ProjectsContainerEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type ProjectsContainerCreateInput = {
  projects?: InputMaybe<ProjectCreateManyInlineInput>;
};

export type ProjectsContainerCreateManyInlineInput = {
  /** Create and connect multiple existing ProjectsContainer documents */
  create?: InputMaybe<Array<ProjectsContainerCreateInput>>;
};

export type ProjectsContainerCreateOneInlineInput = {
  /** Create and connect one ProjectsContainer document */
  create?: InputMaybe<ProjectsContainerCreateInput>;
};

export type ProjectsContainerCreateWithPositionInput = {
  /** Document to create */
  data: ProjectsContainerCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type ProjectsContainerEdge = {
  __typename?: 'ProjectsContainerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: ProjectsContainer;
};

/** Identifies documents */
export type ProjectsContainerManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<ProjectsContainerWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<ProjectsContainerWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<ProjectsContainerWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  projects_every?: InputMaybe<ProjectWhereInput>;
  projects_none?: InputMaybe<ProjectWhereInput>;
  projects_some?: InputMaybe<ProjectWhereInput>;
};

export enum ProjectsContainerOrderByInput {
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC'
}

export type ProjectsContainerParent = Page;

export type ProjectsContainerParentConnectInput = {
  Page?: InputMaybe<PageConnectInput>;
};

export type ProjectsContainerParentCreateInput = {
  Page?: InputMaybe<PageCreateInput>;
};

export type ProjectsContainerParentCreateManyInlineInput = {
  /** Connect multiple existing ProjectsContainerParent documents */
  connect?: InputMaybe<Array<ProjectsContainerParentWhereUniqueInput>>;
  /** Create and connect multiple existing ProjectsContainerParent documents */
  create?: InputMaybe<Array<ProjectsContainerParentCreateInput>>;
};

export type ProjectsContainerParentCreateOneInlineInput = {
  /** Connect one existing ProjectsContainerParent document */
  connect?: InputMaybe<ProjectsContainerParentWhereUniqueInput>;
  /** Create and connect one ProjectsContainerParent document */
  create?: InputMaybe<ProjectsContainerParentCreateInput>;
};

export type ProjectsContainerParentUpdateInput = {
  Page?: InputMaybe<PageUpdateInput>;
};

export type ProjectsContainerParentUpdateManyInlineInput = {
  /** Connect multiple existing ProjectsContainerParent documents */
  connect?: InputMaybe<Array<ProjectsContainerParentConnectInput>>;
  /** Create and connect multiple ProjectsContainerParent documents */
  create?: InputMaybe<Array<ProjectsContainerParentCreateInput>>;
  /** Delete multiple ProjectsContainerParent documents */
  delete?: InputMaybe<Array<ProjectsContainerParentWhereUniqueInput>>;
  /** Disconnect multiple ProjectsContainerParent documents */
  disconnect?: InputMaybe<Array<ProjectsContainerParentWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing ProjectsContainerParent documents */
  set?: InputMaybe<Array<ProjectsContainerParentWhereUniqueInput>>;
  /** Update multiple ProjectsContainerParent documents */
  update?: InputMaybe<Array<ProjectsContainerParentUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple ProjectsContainerParent documents */
  upsert?: InputMaybe<Array<ProjectsContainerParentUpsertWithNestedWhereUniqueInput>>;
};

export type ProjectsContainerParentUpdateManyWithNestedWhereInput = {
  Page?: InputMaybe<PageUpdateManyWithNestedWhereInput>;
};

export type ProjectsContainerParentUpdateOneInlineInput = {
  /** Connect existing ProjectsContainerParent document */
  connect?: InputMaybe<ProjectsContainerParentWhereUniqueInput>;
  /** Create and connect one ProjectsContainerParent document */
  create?: InputMaybe<ProjectsContainerParentCreateInput>;
  /** Delete currently connected ProjectsContainerParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected ProjectsContainerParent document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single ProjectsContainerParent document */
  update?: InputMaybe<ProjectsContainerParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single ProjectsContainerParent document */
  upsert?: InputMaybe<ProjectsContainerParentUpsertWithNestedWhereUniqueInput>;
};

export type ProjectsContainerParentUpdateWithNestedWhereUniqueInput = {
  Page?: InputMaybe<PageUpdateWithNestedWhereUniqueInput>;
};

export type ProjectsContainerParentUpsertWithNestedWhereUniqueInput = {
  Page?: InputMaybe<PageUpsertWithNestedWhereUniqueInput>;
};

export type ProjectsContainerParentWhereInput = {
  Page?: InputMaybe<PageWhereInput>;
};

export type ProjectsContainerParentWhereUniqueInput = {
  Page?: InputMaybe<PageWhereUniqueInput>;
};

export type ProjectsContainerUpdateInput = {
  projects?: InputMaybe<ProjectUpdateManyInlineInput>;
};

export type ProjectsContainerUpdateManyInlineInput = {
  /** Create and connect multiple ProjectsContainer component instances */
  create?: InputMaybe<Array<ProjectsContainerCreateWithPositionInput>>;
  /** Delete multiple ProjectsContainer documents */
  delete?: InputMaybe<Array<ProjectsContainerWhereUniqueInput>>;
  /** Update multiple ProjectsContainer component instances */
  update?: InputMaybe<Array<ProjectsContainerUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple ProjectsContainer component instances */
  upsert?: InputMaybe<Array<ProjectsContainerUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type ProjectsContainerUpdateManyInput = {
  /** No fields in updateMany data input */
  _?: InputMaybe<Scalars['String']>;
};

export type ProjectsContainerUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: ProjectsContainerUpdateManyInput;
  /** Document search */
  where: ProjectsContainerWhereInput;
};

export type ProjectsContainerUpdateOneInlineInput = {
  /** Create and connect one ProjectsContainer document */
  create?: InputMaybe<ProjectsContainerCreateInput>;
  /** Delete currently connected ProjectsContainer document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single ProjectsContainer document */
  update?: InputMaybe<ProjectsContainerUpdateWithNestedWhereUniqueInput>;
  /** Upsert single ProjectsContainer document */
  upsert?: InputMaybe<ProjectsContainerUpsertWithNestedWhereUniqueInput>;
};

export type ProjectsContainerUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<ProjectsContainerUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: ProjectsContainerWhereUniqueInput;
};

export type ProjectsContainerUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: ProjectsContainerUpdateInput;
  /** Unique document search */
  where: ProjectsContainerWhereUniqueInput;
};

export type ProjectsContainerUpsertInput = {
  /** Create document if it didn't exist */
  create: ProjectsContainerCreateInput;
  /** Update document if it exists */
  update: ProjectsContainerUpdateInput;
};

export type ProjectsContainerUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<ProjectsContainerUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: ProjectsContainerWhereUniqueInput;
};

export type ProjectsContainerUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: ProjectsContainerUpsertInput;
  /** Unique document search */
  where: ProjectsContainerWhereUniqueInput;
};

/** Identifies documents */
export type ProjectsContainerWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<ProjectsContainerWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<ProjectsContainerWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<ProjectsContainerWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  projects_every?: InputMaybe<ProjectWhereInput>;
  projects_none?: InputMaybe<ProjectWhereInput>;
  projects_some?: InputMaybe<ProjectWhereInput>;
};

/** References ProjectsContainer record uniquely */
export type ProjectsContainerWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export type PublishLocaleInput = {
  /** Locales to publish */
  locale: Locale;
  /** Stages to publish selected locales to */
  stages: Array<Stage>;
};

export type Query = {
  __typename?: 'Query';
  /** Retrieve a single asset */
  asset?: Maybe<Asset>;
  /** Retrieve document version */
  assetVersion?: Maybe<DocumentVersion>;
  /** Retrieve multiple assets */
  assets: Array<Asset>;
  /** Retrieve multiple assets using the Relay connection interface */
  assetsConnection: AssetConnection;
  /** Retrieve a single button */
  button?: Maybe<Button>;
  /** Retrieve document version */
  buttonVersion?: Maybe<DocumentVersion>;
  /** Retrieve multiple buttons */
  buttons: Array<Button>;
  /** Retrieve multiple buttons using the Relay connection interface */
  buttonsConnection: ButtonConnection;
  /** Retrieve a single card */
  card?: Maybe<Card>;
  /** Retrieve document version */
  cardVersion?: Maybe<DocumentVersion>;
  /** Retrieve multiple cards */
  cards: Array<Card>;
  /** Retrieve multiple cards using the Relay connection interface */
  cardsConnection: CardConnection;
  /** Retrieve a single contactCard */
  contactCard?: Maybe<ContactCard>;
  /** Retrieve document version */
  contactCardVersion?: Maybe<DocumentVersion>;
  /** Retrieve multiple contactCards */
  contactCards: Array<ContactCard>;
  /** Retrieve multiple contactCards using the Relay connection interface */
  contactCardsConnection: ContactCardConnection;
  /** Retrieve a single container */
  container?: Maybe<Container>;
  /** Retrieve document version */
  containerVersion?: Maybe<DocumentVersion>;
  /** Retrieve multiple containers */
  containers: Array<Container>;
  /** Retrieve multiple containers using the Relay connection interface */
  containersConnection: ContainerConnection;
  /** Retrieve a single event */
  event?: Maybe<Event>;
  /** Retrieve document version */
  eventVersion?: Maybe<DocumentVersion>;
  /** Retrieve multiple events */
  events: Array<Event>;
  /** Retrieve multiple events using the Relay connection interface */
  eventsConnection: EventConnection;
  /** Retrieve a single form */
  form?: Maybe<Form>;
  /** Retrieve document version */
  formVersion?: Maybe<DocumentVersion>;
  /** Retrieve multiple forms */
  forms: Array<Form>;
  /** Retrieve multiple forms using the Relay connection interface */
  formsConnection: FormConnection;
  /** Retrieve a single layout */
  layout?: Maybe<Layout>;
  /** Retrieve document version */
  layoutVersion?: Maybe<DocumentVersion>;
  /** Retrieve multiple layouts */
  layouts: Array<Layout>;
  /** Retrieve multiple layouts using the Relay connection interface */
  layoutsConnection: LayoutConnection;
  /** Fetches an object given its ID */
  node?: Maybe<Node>;
  /** Retrieve a single page */
  page?: Maybe<Page>;
  /** Retrieve document version */
  pageVersion?: Maybe<DocumentVersion>;
  /** Retrieve multiple pages */
  pages: Array<Page>;
  /** Retrieve multiple pages using the Relay connection interface */
  pagesConnection: PageConnection;
  /** Retrieve multiple people */
  people: Array<Person>;
  /** Retrieve multiple people using the Relay connection interface */
  peopleConnection: PersonConnection;
  /** Retrieve a single person */
  person?: Maybe<Person>;
  /** Retrieve document version */
  personVersion?: Maybe<DocumentVersion>;
  /** Retrieve a single project */
  project?: Maybe<Project>;
  /** Retrieve multiple projectCategories */
  projectCategories: Array<ProjectCategory>;
  /** Retrieve multiple projectCategories using the Relay connection interface */
  projectCategoriesConnection: ProjectCategoryConnection;
  /** Retrieve a single projectCategory */
  projectCategory?: Maybe<ProjectCategory>;
  /** Retrieve document version */
  projectCategoryVersion?: Maybe<DocumentVersion>;
  /** Retrieve document version */
  projectVersion?: Maybe<DocumentVersion>;
  /** Retrieve multiple projects */
  projects: Array<Project>;
  /** Retrieve multiple projects using the Relay connection interface */
  projectsConnection: ProjectConnection;
  /** Retrieve a single richTextWrapper */
  richTextWrapper?: Maybe<RichTextWrapper>;
  /** Retrieve document version */
  richTextWrapperVersion?: Maybe<DocumentVersion>;
  /** Retrieve multiple richTextWrappers */
  richTextWrappers: Array<RichTextWrapper>;
  /** Retrieve multiple richTextWrappers using the Relay connection interface */
  richTextWrappersConnection: RichTextWrapperConnection;
  /** Retrieve a single scheduledOperation */
  scheduledOperation?: Maybe<ScheduledOperation>;
  /** Retrieve multiple scheduledOperations */
  scheduledOperations: Array<ScheduledOperation>;
  /** Retrieve multiple scheduledOperations using the Relay connection interface */
  scheduledOperationsConnection: ScheduledOperationConnection;
  /** Retrieve a single scheduledRelease */
  scheduledRelease?: Maybe<ScheduledRelease>;
  /** Retrieve multiple scheduledReleases */
  scheduledReleases: Array<ScheduledRelease>;
  /** Retrieve multiple scheduledReleases using the Relay connection interface */
  scheduledReleasesConnection: ScheduledReleaseConnection;
  /** Retrieve a single service */
  service?: Maybe<Service>;
  /** Retrieve document version */
  serviceVersion?: Maybe<DocumentVersion>;
  /** Retrieve multiple services */
  services: Array<Service>;
  /** Retrieve multiple services using the Relay connection interface */
  servicesConnection: ServiceConnection;
  /** Retrieve a single sponsor */
  sponsor?: Maybe<Sponsor>;
  /** Retrieve document version */
  sponsorVersion?: Maybe<DocumentVersion>;
  /** Retrieve multiple sponsors */
  sponsors: Array<Sponsor>;
  /** Retrieve multiple sponsors using the Relay connection interface */
  sponsorsConnection: SponsorConnection;
  /** Retrieve a single user */
  user?: Maybe<User>;
  /** Retrieve multiple users */
  users: Array<User>;
  /** Retrieve multiple users using the Relay connection interface */
  usersConnection: UserConnection;
};


export type QueryAssetArgs = {
  locales?: Array<Locale>;
  stage?: Stage;
  where: AssetWhereUniqueInput;
};


export type QueryAssetVersionArgs = {
  where: VersionWhereInput;
};


export type QueryAssetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<AssetOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<AssetWhereInput>;
};


export type QueryAssetsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<AssetOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<AssetWhereInput>;
};


export type QueryButtonArgs = {
  locales?: Array<Locale>;
  stage?: Stage;
  where: ButtonWhereUniqueInput;
};


export type QueryButtonVersionArgs = {
  where: VersionWhereInput;
};


export type QueryButtonsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<ButtonOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<ButtonWhereInput>;
};


export type QueryButtonsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<ButtonOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<ButtonWhereInput>;
};


export type QueryCardArgs = {
  locales?: Array<Locale>;
  stage?: Stage;
  where: CardWhereUniqueInput;
};


export type QueryCardVersionArgs = {
  where: VersionWhereInput;
};


export type QueryCardsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<CardOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<CardWhereInput>;
};


export type QueryCardsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<CardOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<CardWhereInput>;
};


export type QueryContactCardArgs = {
  locales?: Array<Locale>;
  stage?: Stage;
  where: ContactCardWhereUniqueInput;
};


export type QueryContactCardVersionArgs = {
  where: VersionWhereInput;
};


export type QueryContactCardsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<ContactCardOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<ContactCardWhereInput>;
};


export type QueryContactCardsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<ContactCardOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<ContactCardWhereInput>;
};


export type QueryContainerArgs = {
  locales?: Array<Locale>;
  stage?: Stage;
  where: ContainerWhereUniqueInput;
};


export type QueryContainerVersionArgs = {
  where: VersionWhereInput;
};


export type QueryContainersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<ContainerOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<ContainerWhereInput>;
};


export type QueryContainersConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<ContainerOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<ContainerWhereInput>;
};


export type QueryEventArgs = {
  locales?: Array<Locale>;
  stage?: Stage;
  where: EventWhereUniqueInput;
};


export type QueryEventVersionArgs = {
  where: VersionWhereInput;
};


export type QueryEventsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<EventOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<EventWhereInput>;
};


export type QueryEventsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<EventOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<EventWhereInput>;
};


export type QueryFormArgs = {
  locales?: Array<Locale>;
  stage?: Stage;
  where: FormWhereUniqueInput;
};


export type QueryFormVersionArgs = {
  where: VersionWhereInput;
};


export type QueryFormsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<FormOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<FormWhereInput>;
};


export type QueryFormsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<FormOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<FormWhereInput>;
};


export type QueryLayoutArgs = {
  locales?: Array<Locale>;
  stage?: Stage;
  where: LayoutWhereUniqueInput;
};


export type QueryLayoutVersionArgs = {
  where: VersionWhereInput;
};


export type QueryLayoutsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<LayoutOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<LayoutWhereInput>;
};


export type QueryLayoutsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<LayoutOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<LayoutWhereInput>;
};


export type QueryNodeArgs = {
  id: Scalars['ID'];
  locales?: Array<Locale>;
  stage?: Stage;
};


export type QueryPageArgs = {
  locales?: Array<Locale>;
  stage?: Stage;
  where: PageWhereUniqueInput;
};


export type QueryPageVersionArgs = {
  where: VersionWhereInput;
};


export type QueryPagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<PageOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<PageWhereInput>;
};


export type QueryPagesConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<PageOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<PageWhereInput>;
};


export type QueryPeopleArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<PersonOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<PersonWhereInput>;
};


export type QueryPeopleConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<PersonOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<PersonWhereInput>;
};


export type QueryPersonArgs = {
  locales?: Array<Locale>;
  stage?: Stage;
  where: PersonWhereUniqueInput;
};


export type QueryPersonVersionArgs = {
  where: VersionWhereInput;
};


export type QueryProjectArgs = {
  locales?: Array<Locale>;
  stage?: Stage;
  where: ProjectWhereUniqueInput;
};


export type QueryProjectCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<ProjectCategoryOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<ProjectCategoryWhereInput>;
};


export type QueryProjectCategoriesConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<ProjectCategoryOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<ProjectCategoryWhereInput>;
};


export type QueryProjectCategoryArgs = {
  locales?: Array<Locale>;
  stage?: Stage;
  where: ProjectCategoryWhereUniqueInput;
};


export type QueryProjectCategoryVersionArgs = {
  where: VersionWhereInput;
};


export type QueryProjectVersionArgs = {
  where: VersionWhereInput;
};


export type QueryProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<ProjectOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<ProjectWhereInput>;
};


export type QueryProjectsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<ProjectOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<ProjectWhereInput>;
};


export type QueryRichTextWrapperArgs = {
  locales?: Array<Locale>;
  stage?: Stage;
  where: RichTextWrapperWhereUniqueInput;
};


export type QueryRichTextWrapperVersionArgs = {
  where: VersionWhereInput;
};


export type QueryRichTextWrappersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<RichTextWrapperOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<RichTextWrapperWhereInput>;
};


export type QueryRichTextWrappersConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<RichTextWrapperOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<RichTextWrapperWhereInput>;
};


export type QueryScheduledOperationArgs = {
  locales?: Array<Locale>;
  stage?: Stage;
  where: ScheduledOperationWhereUniqueInput;
};


export type QueryScheduledOperationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<ScheduledOperationOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<ScheduledOperationWhereInput>;
};


export type QueryScheduledOperationsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<ScheduledOperationOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<ScheduledOperationWhereInput>;
};


export type QueryScheduledReleaseArgs = {
  locales?: Array<Locale>;
  stage?: Stage;
  where: ScheduledReleaseWhereUniqueInput;
};


export type QueryScheduledReleasesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<ScheduledReleaseOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<ScheduledReleaseWhereInput>;
};


export type QueryScheduledReleasesConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<ScheduledReleaseOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<ScheduledReleaseWhereInput>;
};


export type QueryServiceArgs = {
  locales?: Array<Locale>;
  stage?: Stage;
  where: ServiceWhereUniqueInput;
};


export type QueryServiceVersionArgs = {
  where: VersionWhereInput;
};


export type QueryServicesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<ServiceOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<ServiceWhereInput>;
};


export type QueryServicesConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<ServiceOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<ServiceWhereInput>;
};


export type QuerySponsorArgs = {
  locales?: Array<Locale>;
  stage?: Stage;
  where: SponsorWhereUniqueInput;
};


export type QuerySponsorVersionArgs = {
  where: VersionWhereInput;
};


export type QuerySponsorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<SponsorOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<SponsorWhereInput>;
};


export type QuerySponsorsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<SponsorOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<SponsorWhereInput>;
};


export type QueryUserArgs = {
  locales?: Array<Locale>;
  stage?: Stage;
  where: UserWhereUniqueInput;
};


export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<UserOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<UserWhereInput>;
};


export type QueryUsersConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: Array<Locale>;
  orderBy?: InputMaybe<UserOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  stage?: Stage;
  where?: InputMaybe<UserWhereInput>;
};

/** Representing a RGBA color value: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgb()_and_rgba() */
export type Rgba = {
  __typename?: 'RGBA';
  a: Scalars['RGBATransparency'];
  b: Scalars['RGBAHue'];
  g: Scalars['RGBAHue'];
  r: Scalars['RGBAHue'];
};

/** Input type representing a RGBA color value: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgb()_and_rgba() */
export type RgbaInput = {
  a: Scalars['RGBATransparency'];
  b: Scalars['RGBAHue'];
  g: Scalars['RGBAHue'];
  r: Scalars['RGBAHue'];
};

/** Custom type representing a rich text value comprising of raw rich text ast, html, markdown and text values */
export type RichText = {
  __typename?: 'RichText';
  /** Returns HTMl representation */
  html: Scalars['String'];
  /** Returns Markdown representation */
  markdown: Scalars['String'];
  /** Returns AST representation */
  raw: Scalars['RichTextAST'];
  /** Returns plain-text contents of RichText */
  text: Scalars['String'];
};

export type RichTextWrapper = Node & {
  __typename?: 'RichTextWrapper';
  container?: Maybe<Container>;
  /** The time the document was created */
  createdAt: Scalars['DateTime'];
  /** User that created this document */
  createdBy?: Maybe<User>;
  /** Get the document in other stages */
  documentInStages: Array<RichTextWrapper>;
  /** List of RichTextWrapper versions */
  history: Array<Version>;
  /** The unique identifier */
  id: Scalars['ID'];
  /** The time the document was published. Null on documents in draft stage. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** User that last published this document */
  publishedBy?: Maybe<User>;
  scheduledIn: Array<ScheduledOperation>;
  /** System stage field */
  stage: Stage;
  style?: Maybe<Style>;
  /** The time the document was updated */
  updatedAt: Scalars['DateTime'];
  /** User that last updated this document */
  updatedBy?: Maybe<User>;
  value: RichTextWrapperValueRichText;
};


export type RichTextWrapperContainerArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type RichTextWrapperCreatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type RichTextWrapperDocumentInStagesArgs = {
  includeCurrent?: Scalars['Boolean'];
  inheritLocale?: Scalars['Boolean'];
  stages?: Array<Stage>;
};


export type RichTextWrapperHistoryArgs = {
  limit?: Scalars['Int'];
  skip?: Scalars['Int'];
  stageOverride?: InputMaybe<Stage>;
};


export type RichTextWrapperPublishedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type RichTextWrapperScheduledInArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ScheduledOperationWhereInput>;
};


export type RichTextWrapperStyleArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type RichTextWrapperUpdatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};

export type RichTextWrapperConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: RichTextWrapperWhereUniqueInput;
};

/** A connection to a list of items. */
export type RichTextWrapperConnection = {
  __typename?: 'RichTextWrapperConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<RichTextWrapperEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type RichTextWrapperCreateInput = {
  container?: InputMaybe<ContainerCreateOneInlineInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  style?: InputMaybe<StyleCreateOneInlineInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  value: Scalars['RichTextAST'];
};

export type RichTextWrapperCreateManyInlineInput = {
  /** Connect multiple existing RichTextWrapper documents */
  connect?: InputMaybe<Array<RichTextWrapperWhereUniqueInput>>;
  /** Create and connect multiple existing RichTextWrapper documents */
  create?: InputMaybe<Array<RichTextWrapperCreateInput>>;
};

export type RichTextWrapperCreateOneInlineInput = {
  /** Connect one existing RichTextWrapper document */
  connect?: InputMaybe<RichTextWrapperWhereUniqueInput>;
  /** Create and connect one RichTextWrapper document */
  create?: InputMaybe<RichTextWrapperCreateInput>;
};

/** An edge in a connection. */
export type RichTextWrapperEdge = {
  __typename?: 'RichTextWrapperEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: RichTextWrapper;
};

/** Identifies documents */
export type RichTextWrapperManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<RichTextWrapperWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<RichTextWrapperWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<RichTextWrapperWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  container?: InputMaybe<ContainerWhereInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  style?: InputMaybe<StyleWhereInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

export enum RichTextWrapperOrderByInput {
  CreatedAtAsc = 'createdAt_ASC',
  CreatedAtDesc = 'createdAt_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  PublishedAtAsc = 'publishedAt_ASC',
  PublishedAtDesc = 'publishedAt_DESC',
  UpdatedAtAsc = 'updatedAt_ASC',
  UpdatedAtDesc = 'updatedAt_DESC'
}

export type RichTextWrapperUpdateInput = {
  container?: InputMaybe<ContainerUpdateOneInlineInput>;
  style?: InputMaybe<StyleUpdateOneInlineInput>;
  value?: InputMaybe<Scalars['RichTextAST']>;
};

export type RichTextWrapperUpdateManyInlineInput = {
  /** Connect multiple existing RichTextWrapper documents */
  connect?: InputMaybe<Array<RichTextWrapperConnectInput>>;
  /** Create and connect multiple RichTextWrapper documents */
  create?: InputMaybe<Array<RichTextWrapperCreateInput>>;
  /** Delete multiple RichTextWrapper documents */
  delete?: InputMaybe<Array<RichTextWrapperWhereUniqueInput>>;
  /** Disconnect multiple RichTextWrapper documents */
  disconnect?: InputMaybe<Array<RichTextWrapperWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing RichTextWrapper documents */
  set?: InputMaybe<Array<RichTextWrapperWhereUniqueInput>>;
  /** Update multiple RichTextWrapper documents */
  update?: InputMaybe<Array<RichTextWrapperUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple RichTextWrapper documents */
  upsert?: InputMaybe<Array<RichTextWrapperUpsertWithNestedWhereUniqueInput>>;
};

export type RichTextWrapperUpdateManyInput = {
  value?: InputMaybe<Scalars['RichTextAST']>;
};

export type RichTextWrapperUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: RichTextWrapperUpdateManyInput;
  /** Document search */
  where: RichTextWrapperWhereInput;
};

export type RichTextWrapperUpdateOneInlineInput = {
  /** Connect existing RichTextWrapper document */
  connect?: InputMaybe<RichTextWrapperWhereUniqueInput>;
  /** Create and connect one RichTextWrapper document */
  create?: InputMaybe<RichTextWrapperCreateInput>;
  /** Delete currently connected RichTextWrapper document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected RichTextWrapper document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single RichTextWrapper document */
  update?: InputMaybe<RichTextWrapperUpdateWithNestedWhereUniqueInput>;
  /** Upsert single RichTextWrapper document */
  upsert?: InputMaybe<RichTextWrapperUpsertWithNestedWhereUniqueInput>;
};

export type RichTextWrapperUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: RichTextWrapperUpdateInput;
  /** Unique document search */
  where: RichTextWrapperWhereUniqueInput;
};

export type RichTextWrapperUpsertInput = {
  /** Create document if it didn't exist */
  create: RichTextWrapperCreateInput;
  /** Update document if it exists */
  update: RichTextWrapperUpdateInput;
};

export type RichTextWrapperUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: RichTextWrapperUpsertInput;
  /** Unique document search */
  where: RichTextWrapperWhereUniqueInput;
};

export type RichTextWrapperValueRichText = {
  __typename?: 'RichTextWrapperValueRichText';
  /** Returns HTMl representation */
  html: Scalars['String'];
  json: Scalars['RichTextAST'];
  /** Returns Markdown representation */
  markdown: Scalars['String'];
  /** @deprecated Please use the 'json' field */
  raw: Scalars['RichTextAST'];
  references: Array<RichTextWrapperValueRichTextEmbeddedTypes>;
  /** Returns plain-text contents of RichText */
  text: Scalars['String'];
};

export type RichTextWrapperValueRichTextEmbeddedTypes = Button;

/** Identifies documents */
export type RichTextWrapperWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<RichTextWrapperWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<RichTextWrapperWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<RichTextWrapperWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  container?: InputMaybe<ContainerWhereInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  style?: InputMaybe<StyleWhereInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

/** References RichTextWrapper record uniquely */
export type RichTextWrapperWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

/** Scheduled Operation system model */
export type ScheduledOperation = Node & {
  __typename?: 'ScheduledOperation';
  affectedDocuments: Array<ScheduledOperationAffectedDocument>;
  /** The time the document was created */
  createdAt: Scalars['DateTime'];
  /** User that created this document */
  createdBy?: Maybe<User>;
  /** Operation description */
  description?: Maybe<Scalars['String']>;
  /** Get the document in other stages */
  documentInStages: Array<ScheduledOperation>;
  /** Operation error message */
  errorMessage?: Maybe<Scalars['String']>;
  /** The unique identifier */
  id: Scalars['ID'];
  /** The time the document was published. Null on documents in draft stage. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** User that last published this document */
  publishedBy?: Maybe<User>;
  /** Raw operation payload including all details, this field is subject to change */
  rawPayload: Scalars['Json'];
  /** The release this operation is scheduled for */
  release?: Maybe<ScheduledRelease>;
  /** System stage field */
  stage: Stage;
  /** operation Status */
  status: ScheduledOperationStatus;
  /** The time the document was updated */
  updatedAt: Scalars['DateTime'];
  /** User that last updated this document */
  updatedBy?: Maybe<User>;
};


/** Scheduled Operation system model */
export type ScheduledOperationAffectedDocumentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
};


/** Scheduled Operation system model */
export type ScheduledOperationCreatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


/** Scheduled Operation system model */
export type ScheduledOperationDocumentInStagesArgs = {
  includeCurrent?: Scalars['Boolean'];
  inheritLocale?: Scalars['Boolean'];
  stages?: Array<Stage>;
};


/** Scheduled Operation system model */
export type ScheduledOperationPublishedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


/** Scheduled Operation system model */
export type ScheduledOperationReleaseArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


/** Scheduled Operation system model */
export type ScheduledOperationUpdatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};

export type ScheduledOperationAffectedDocument = Asset | Button | Card | ContactCard | Container | Event | Form | Layout | Page | Person | Project | ProjectCategory | RichTextWrapper | Service | Sponsor;

export type ScheduledOperationConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: ScheduledOperationWhereUniqueInput;
};

/** A connection to a list of items. */
export type ScheduledOperationConnection = {
  __typename?: 'ScheduledOperationConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<ScheduledOperationEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type ScheduledOperationCreateManyInlineInput = {
  /** Connect multiple existing ScheduledOperation documents */
  connect?: InputMaybe<Array<ScheduledOperationWhereUniqueInput>>;
};

export type ScheduledOperationCreateOneInlineInput = {
  /** Connect one existing ScheduledOperation document */
  connect?: InputMaybe<ScheduledOperationWhereUniqueInput>;
};

/** An edge in a connection. */
export type ScheduledOperationEdge = {
  __typename?: 'ScheduledOperationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: ScheduledOperation;
};

/** Identifies documents */
export type ScheduledOperationManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<ScheduledOperationWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<ScheduledOperationWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<ScheduledOperationWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  description?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  description_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  description_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  description_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  description_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  description_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  description_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  description_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  description_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  description_starts_with?: InputMaybe<Scalars['String']>;
  errorMessage?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  errorMessage_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  errorMessage_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  errorMessage_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  errorMessage_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  errorMessage_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  errorMessage_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  errorMessage_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  errorMessage_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  errorMessage_starts_with?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  release?: InputMaybe<ScheduledReleaseWhereInput>;
  status?: InputMaybe<ScheduledOperationStatus>;
  /** All values that are contained in given list. */
  status_in?: InputMaybe<Array<InputMaybe<ScheduledOperationStatus>>>;
  /** All values that are not equal to given value. */
  status_not?: InputMaybe<ScheduledOperationStatus>;
  /** All values that are not contained in given list. */
  status_not_in?: InputMaybe<Array<InputMaybe<ScheduledOperationStatus>>>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

export enum ScheduledOperationOrderByInput {
  CreatedAtAsc = 'createdAt_ASC',
  CreatedAtDesc = 'createdAt_DESC',
  DescriptionAsc = 'description_ASC',
  DescriptionDesc = 'description_DESC',
  ErrorMessageAsc = 'errorMessage_ASC',
  ErrorMessageDesc = 'errorMessage_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  PublishedAtAsc = 'publishedAt_ASC',
  PublishedAtDesc = 'publishedAt_DESC',
  StatusAsc = 'status_ASC',
  StatusDesc = 'status_DESC',
  UpdatedAtAsc = 'updatedAt_ASC',
  UpdatedAtDesc = 'updatedAt_DESC'
}

/** System Scheduled Operation Status */
export enum ScheduledOperationStatus {
  Canceled = 'CANCELED',
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Pending = 'PENDING'
}

export type ScheduledOperationUpdateManyInlineInput = {
  /** Connect multiple existing ScheduledOperation documents */
  connect?: InputMaybe<Array<ScheduledOperationConnectInput>>;
  /** Disconnect multiple ScheduledOperation documents */
  disconnect?: InputMaybe<Array<ScheduledOperationWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing ScheduledOperation documents */
  set?: InputMaybe<Array<ScheduledOperationWhereUniqueInput>>;
};

export type ScheduledOperationUpdateOneInlineInput = {
  /** Connect existing ScheduledOperation document */
  connect?: InputMaybe<ScheduledOperationWhereUniqueInput>;
  /** Disconnect currently connected ScheduledOperation document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
};

/** Identifies documents */
export type ScheduledOperationWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<ScheduledOperationWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<ScheduledOperationWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<ScheduledOperationWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  description?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  description_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  description_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  description_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  description_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  description_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  description_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  description_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  description_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  description_starts_with?: InputMaybe<Scalars['String']>;
  errorMessage?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  errorMessage_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  errorMessage_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  errorMessage_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  errorMessage_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  errorMessage_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  errorMessage_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  errorMessage_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  errorMessage_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  errorMessage_starts_with?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  release?: InputMaybe<ScheduledReleaseWhereInput>;
  status?: InputMaybe<ScheduledOperationStatus>;
  /** All values that are contained in given list. */
  status_in?: InputMaybe<Array<InputMaybe<ScheduledOperationStatus>>>;
  /** All values that are not equal to given value. */
  status_not?: InputMaybe<ScheduledOperationStatus>;
  /** All values that are not contained in given list. */
  status_not_in?: InputMaybe<Array<InputMaybe<ScheduledOperationStatus>>>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

/** References ScheduledOperation record uniquely */
export type ScheduledOperationWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

/** Scheduled Release system model */
export type ScheduledRelease = Node & {
  __typename?: 'ScheduledRelease';
  /** The time the document was created */
  createdAt: Scalars['DateTime'];
  /** User that created this document */
  createdBy?: Maybe<User>;
  /** Release description */
  description?: Maybe<Scalars['String']>;
  /** Get the document in other stages */
  documentInStages: Array<ScheduledRelease>;
  /** Release error message */
  errorMessage?: Maybe<Scalars['String']>;
  /** The unique identifier */
  id: Scalars['ID'];
  /** Whether scheduled release should be run */
  isActive: Scalars['Boolean'];
  /** Whether scheduled release is implicit */
  isImplicit: Scalars['Boolean'];
  /** Operations to run with this release */
  operations: Array<ScheduledOperation>;
  /** The time the document was published. Null on documents in draft stage. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** User that last published this document */
  publishedBy?: Maybe<User>;
  /** Release date and time */
  releaseAt?: Maybe<Scalars['DateTime']>;
  /** System stage field */
  stage: Stage;
  /** Release Status */
  status: ScheduledReleaseStatus;
  /** Release Title */
  title?: Maybe<Scalars['String']>;
  /** The time the document was updated */
  updatedAt: Scalars['DateTime'];
  /** User that last updated this document */
  updatedBy?: Maybe<User>;
};


/** Scheduled Release system model */
export type ScheduledReleaseCreatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


/** Scheduled Release system model */
export type ScheduledReleaseDocumentInStagesArgs = {
  includeCurrent?: Scalars['Boolean'];
  inheritLocale?: Scalars['Boolean'];
  stages?: Array<Stage>;
};


/** Scheduled Release system model */
export type ScheduledReleaseOperationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  orderBy?: InputMaybe<ScheduledOperationOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ScheduledOperationWhereInput>;
};


/** Scheduled Release system model */
export type ScheduledReleasePublishedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


/** Scheduled Release system model */
export type ScheduledReleaseUpdatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};

export type ScheduledReleaseConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: ScheduledReleaseWhereUniqueInput;
};

/** A connection to a list of items. */
export type ScheduledReleaseConnection = {
  __typename?: 'ScheduledReleaseConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<ScheduledReleaseEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type ScheduledReleaseCreateInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  description?: InputMaybe<Scalars['String']>;
  errorMessage?: InputMaybe<Scalars['String']>;
  isActive?: InputMaybe<Scalars['Boolean']>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type ScheduledReleaseCreateManyInlineInput = {
  /** Connect multiple existing ScheduledRelease documents */
  connect?: InputMaybe<Array<ScheduledReleaseWhereUniqueInput>>;
  /** Create and connect multiple existing ScheduledRelease documents */
  create?: InputMaybe<Array<ScheduledReleaseCreateInput>>;
};

export type ScheduledReleaseCreateOneInlineInput = {
  /** Connect one existing ScheduledRelease document */
  connect?: InputMaybe<ScheduledReleaseWhereUniqueInput>;
  /** Create and connect one ScheduledRelease document */
  create?: InputMaybe<ScheduledReleaseCreateInput>;
};

/** An edge in a connection. */
export type ScheduledReleaseEdge = {
  __typename?: 'ScheduledReleaseEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: ScheduledRelease;
};

/** Identifies documents */
export type ScheduledReleaseManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<ScheduledReleaseWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<ScheduledReleaseWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<ScheduledReleaseWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  description?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  description_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  description_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  description_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  description_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  description_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  description_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  description_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  description_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  description_starts_with?: InputMaybe<Scalars['String']>;
  errorMessage?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  errorMessage_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  errorMessage_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  errorMessage_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  errorMessage_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  errorMessage_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  errorMessage_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  errorMessage_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  errorMessage_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  errorMessage_starts_with?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  isActive?: InputMaybe<Scalars['Boolean']>;
  /** All values that are not equal to given value. */
  isActive_not?: InputMaybe<Scalars['Boolean']>;
  isImplicit?: InputMaybe<Scalars['Boolean']>;
  /** All values that are not equal to given value. */
  isImplicit_not?: InputMaybe<Scalars['Boolean']>;
  operations_every?: InputMaybe<ScheduledOperationWhereInput>;
  operations_none?: InputMaybe<ScheduledOperationWhereInput>;
  operations_some?: InputMaybe<ScheduledOperationWhereInput>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  releaseAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  releaseAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  releaseAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  releaseAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  releaseAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  releaseAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  releaseAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  status?: InputMaybe<ScheduledReleaseStatus>;
  /** All values that are contained in given list. */
  status_in?: InputMaybe<Array<InputMaybe<ScheduledReleaseStatus>>>;
  /** All values that are not equal to given value. */
  status_not?: InputMaybe<ScheduledReleaseStatus>;
  /** All values that are not contained in given list. */
  status_not_in?: InputMaybe<Array<InputMaybe<ScheduledReleaseStatus>>>;
  title?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  title_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  title_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  title_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  title_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  title_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  title_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  title_starts_with?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

export enum ScheduledReleaseOrderByInput {
  CreatedAtAsc = 'createdAt_ASC',
  CreatedAtDesc = 'createdAt_DESC',
  DescriptionAsc = 'description_ASC',
  DescriptionDesc = 'description_DESC',
  ErrorMessageAsc = 'errorMessage_ASC',
  ErrorMessageDesc = 'errorMessage_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  IsActiveAsc = 'isActive_ASC',
  IsActiveDesc = 'isActive_DESC',
  IsImplicitAsc = 'isImplicit_ASC',
  IsImplicitDesc = 'isImplicit_DESC',
  PublishedAtAsc = 'publishedAt_ASC',
  PublishedAtDesc = 'publishedAt_DESC',
  ReleaseAtAsc = 'releaseAt_ASC',
  ReleaseAtDesc = 'releaseAt_DESC',
  StatusAsc = 'status_ASC',
  StatusDesc = 'status_DESC',
  TitleAsc = 'title_ASC',
  TitleDesc = 'title_DESC',
  UpdatedAtAsc = 'updatedAt_ASC',
  UpdatedAtDesc = 'updatedAt_DESC'
}

/** System Scheduled Release Status */
export enum ScheduledReleaseStatus {
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Pending = 'PENDING'
}

export type ScheduledReleaseUpdateInput = {
  description?: InputMaybe<Scalars['String']>;
  errorMessage?: InputMaybe<Scalars['String']>;
  isActive?: InputMaybe<Scalars['Boolean']>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  title?: InputMaybe<Scalars['String']>;
};

export type ScheduledReleaseUpdateManyInlineInput = {
  /** Connect multiple existing ScheduledRelease documents */
  connect?: InputMaybe<Array<ScheduledReleaseConnectInput>>;
  /** Create and connect multiple ScheduledRelease documents */
  create?: InputMaybe<Array<ScheduledReleaseCreateInput>>;
  /** Delete multiple ScheduledRelease documents */
  delete?: InputMaybe<Array<ScheduledReleaseWhereUniqueInput>>;
  /** Disconnect multiple ScheduledRelease documents */
  disconnect?: InputMaybe<Array<ScheduledReleaseWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing ScheduledRelease documents */
  set?: InputMaybe<Array<ScheduledReleaseWhereUniqueInput>>;
  /** Update multiple ScheduledRelease documents */
  update?: InputMaybe<Array<ScheduledReleaseUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple ScheduledRelease documents */
  upsert?: InputMaybe<Array<ScheduledReleaseUpsertWithNestedWhereUniqueInput>>;
};

export type ScheduledReleaseUpdateManyInput = {
  description?: InputMaybe<Scalars['String']>;
  errorMessage?: InputMaybe<Scalars['String']>;
  isActive?: InputMaybe<Scalars['Boolean']>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  title?: InputMaybe<Scalars['String']>;
};

export type ScheduledReleaseUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: ScheduledReleaseUpdateManyInput;
  /** Document search */
  where: ScheduledReleaseWhereInput;
};

export type ScheduledReleaseUpdateOneInlineInput = {
  /** Connect existing ScheduledRelease document */
  connect?: InputMaybe<ScheduledReleaseWhereUniqueInput>;
  /** Create and connect one ScheduledRelease document */
  create?: InputMaybe<ScheduledReleaseCreateInput>;
  /** Delete currently connected ScheduledRelease document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected ScheduledRelease document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single ScheduledRelease document */
  update?: InputMaybe<ScheduledReleaseUpdateWithNestedWhereUniqueInput>;
  /** Upsert single ScheduledRelease document */
  upsert?: InputMaybe<ScheduledReleaseUpsertWithNestedWhereUniqueInput>;
};

export type ScheduledReleaseUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: ScheduledReleaseUpdateInput;
  /** Unique document search */
  where: ScheduledReleaseWhereUniqueInput;
};

export type ScheduledReleaseUpsertInput = {
  /** Create document if it didn't exist */
  create: ScheduledReleaseCreateInput;
  /** Update document if it exists */
  update: ScheduledReleaseUpdateInput;
};

export type ScheduledReleaseUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: ScheduledReleaseUpsertInput;
  /** Unique document search */
  where: ScheduledReleaseWhereUniqueInput;
};

/** Identifies documents */
export type ScheduledReleaseWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<ScheduledReleaseWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<ScheduledReleaseWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<ScheduledReleaseWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  description?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  description_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  description_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  description_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  description_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  description_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  description_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  description_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  description_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  description_starts_with?: InputMaybe<Scalars['String']>;
  errorMessage?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  errorMessage_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  errorMessage_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  errorMessage_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  errorMessage_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  errorMessage_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  errorMessage_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  errorMessage_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  errorMessage_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  errorMessage_starts_with?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  isActive?: InputMaybe<Scalars['Boolean']>;
  /** All values that are not equal to given value. */
  isActive_not?: InputMaybe<Scalars['Boolean']>;
  isImplicit?: InputMaybe<Scalars['Boolean']>;
  /** All values that are not equal to given value. */
  isImplicit_not?: InputMaybe<Scalars['Boolean']>;
  operations_every?: InputMaybe<ScheduledOperationWhereInput>;
  operations_none?: InputMaybe<ScheduledOperationWhereInput>;
  operations_some?: InputMaybe<ScheduledOperationWhereInput>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  releaseAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  releaseAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  releaseAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  releaseAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  releaseAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  releaseAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  releaseAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  releaseAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  status?: InputMaybe<ScheduledReleaseStatus>;
  /** All values that are contained in given list. */
  status_in?: InputMaybe<Array<InputMaybe<ScheduledReleaseStatus>>>;
  /** All values that are not equal to given value. */
  status_not?: InputMaybe<ScheduledReleaseStatus>;
  /** All values that are not contained in given list. */
  status_not_in?: InputMaybe<Array<InputMaybe<ScheduledReleaseStatus>>>;
  title?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  title_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  title_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  title_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  title_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  title_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  title_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  title_starts_with?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

/** References ScheduledRelease record uniquely */
export type ScheduledReleaseWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export type Section = {
  __typename?: 'Section';
  description?: Maybe<Scalars['String']>;
  /** The unique identifier */
  id: Scalars['ID'];
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<Section>;
  /** System stage field */
  stage: Stage;
  title: Scalars['String'];
};


export type SectionLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};

export type SectionConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: SectionWhereUniqueInput;
};

/** A connection to a list of items. */
export type SectionConnection = {
  __typename?: 'SectionConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<SectionEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type SectionCreateInput = {
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<SectionCreateLocalizationsInput>;
  /** title input for default locale (en) */
  title: Scalars['String'];
};

export type SectionCreateLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
  title: Scalars['String'];
};

export type SectionCreateLocalizationInput = {
  /** Localization input */
  data: SectionCreateLocalizationDataInput;
  locale: Locale;
};

export type SectionCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<SectionCreateLocalizationInput>>;
};

export type SectionCreateManyInlineInput = {
  /** Create and connect multiple existing Section documents */
  create?: InputMaybe<Array<SectionCreateInput>>;
};

export type SectionCreateOneInlineInput = {
  /** Create and connect one Section document */
  create?: InputMaybe<SectionCreateInput>;
};

export type SectionCreateWithPositionInput = {
  /** Document to create */
  data: SectionCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type SectionEdge = {
  __typename?: 'SectionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Section;
};

/** Identifies documents */
export type SectionManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<SectionWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<SectionWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<SectionWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
};

export enum SectionOrderByInput {
  DescriptionAsc = 'description_ASC',
  DescriptionDesc = 'description_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  TitleAsc = 'title_ASC',
  TitleDesc = 'title_DESC'
}

export type SectionParent = Page;

export type SectionParentConnectInput = {
  Page?: InputMaybe<PageConnectInput>;
};

export type SectionParentCreateInput = {
  Page?: InputMaybe<PageCreateInput>;
};

export type SectionParentCreateManyInlineInput = {
  /** Connect multiple existing SectionParent documents */
  connect?: InputMaybe<Array<SectionParentWhereUniqueInput>>;
  /** Create and connect multiple existing SectionParent documents */
  create?: InputMaybe<Array<SectionParentCreateInput>>;
};

export type SectionParentCreateOneInlineInput = {
  /** Connect one existing SectionParent document */
  connect?: InputMaybe<SectionParentWhereUniqueInput>;
  /** Create and connect one SectionParent document */
  create?: InputMaybe<SectionParentCreateInput>;
};

export type SectionParentUpdateInput = {
  Page?: InputMaybe<PageUpdateInput>;
};

export type SectionParentUpdateManyInlineInput = {
  /** Connect multiple existing SectionParent documents */
  connect?: InputMaybe<Array<SectionParentConnectInput>>;
  /** Create and connect multiple SectionParent documents */
  create?: InputMaybe<Array<SectionParentCreateInput>>;
  /** Delete multiple SectionParent documents */
  delete?: InputMaybe<Array<SectionParentWhereUniqueInput>>;
  /** Disconnect multiple SectionParent documents */
  disconnect?: InputMaybe<Array<SectionParentWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing SectionParent documents */
  set?: InputMaybe<Array<SectionParentWhereUniqueInput>>;
  /** Update multiple SectionParent documents */
  update?: InputMaybe<Array<SectionParentUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple SectionParent documents */
  upsert?: InputMaybe<Array<SectionParentUpsertWithNestedWhereUniqueInput>>;
};

export type SectionParentUpdateManyWithNestedWhereInput = {
  Page?: InputMaybe<PageUpdateManyWithNestedWhereInput>;
};

export type SectionParentUpdateOneInlineInput = {
  /** Connect existing SectionParent document */
  connect?: InputMaybe<SectionParentWhereUniqueInput>;
  /** Create and connect one SectionParent document */
  create?: InputMaybe<SectionParentCreateInput>;
  /** Delete currently connected SectionParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected SectionParent document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single SectionParent document */
  update?: InputMaybe<SectionParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single SectionParent document */
  upsert?: InputMaybe<SectionParentUpsertWithNestedWhereUniqueInput>;
};

export type SectionParentUpdateWithNestedWhereUniqueInput = {
  Page?: InputMaybe<PageUpdateWithNestedWhereUniqueInput>;
};

export type SectionParentUpsertWithNestedWhereUniqueInput = {
  Page?: InputMaybe<PageUpsertWithNestedWhereUniqueInput>;
};

export type SectionParentWhereInput = {
  Page?: InputMaybe<PageWhereInput>;
};

export type SectionParentWhereUniqueInput = {
  Page?: InputMaybe<PageWhereUniqueInput>;
};

export type SectionUpdateInput = {
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  /** Manage document localizations */
  localizations?: InputMaybe<SectionUpdateLocalizationsInput>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
};

export type SectionUpdateLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export type SectionUpdateLocalizationInput = {
  data: SectionUpdateLocalizationDataInput;
  locale: Locale;
};

export type SectionUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<SectionCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<SectionUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<SectionUpsertLocalizationInput>>;
};

export type SectionUpdateManyInlineInput = {
  /** Create and connect multiple Section component instances */
  create?: InputMaybe<Array<SectionCreateWithPositionInput>>;
  /** Delete multiple Section documents */
  delete?: InputMaybe<Array<SectionWhereUniqueInput>>;
  /** Update multiple Section component instances */
  update?: InputMaybe<Array<SectionUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple Section component instances */
  upsert?: InputMaybe<Array<SectionUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type SectionUpdateManyInput = {
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  /** Optional updates to localizations */
  localizations?: InputMaybe<SectionUpdateManyLocalizationsInput>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
};

export type SectionUpdateManyLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export type SectionUpdateManyLocalizationInput = {
  data: SectionUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type SectionUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<SectionUpdateManyLocalizationInput>>;
};

export type SectionUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: SectionUpdateManyInput;
  /** Document search */
  where: SectionWhereInput;
};

export type SectionUpdateOneInlineInput = {
  /** Create and connect one Section document */
  create?: InputMaybe<SectionCreateInput>;
  /** Delete currently connected Section document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single Section document */
  update?: InputMaybe<SectionUpdateWithNestedWhereUniqueInput>;
  /** Upsert single Section document */
  upsert?: InputMaybe<SectionUpsertWithNestedWhereUniqueInput>;
};

export type SectionUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<SectionUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: SectionWhereUniqueInput;
};

export type SectionUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: SectionUpdateInput;
  /** Unique document search */
  where: SectionWhereUniqueInput;
};

export type SectionUpsertInput = {
  /** Create document if it didn't exist */
  create: SectionCreateInput;
  /** Update document if it exists */
  update: SectionUpdateInput;
};

export type SectionUpsertLocalizationInput = {
  create: SectionCreateLocalizationDataInput;
  locale: Locale;
  update: SectionUpdateLocalizationDataInput;
};

export type SectionUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<SectionUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: SectionWhereUniqueInput;
};

export type SectionUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: SectionUpsertInput;
  /** Unique document search */
  where: SectionWhereUniqueInput;
};

/** Identifies documents */
export type SectionWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<SectionWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<SectionWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<SectionWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  description_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  description_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  description_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  description_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  description_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  description_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  description_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  description_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  description_starts_with?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  title?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  title_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  title_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  title_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  title_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  title_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  title_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  title_starts_with?: InputMaybe<Scalars['String']>;
};

/** References Section record uniquely */
export type SectionWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export type SectionWithImage = {
  __typename?: 'SectionWithImage';
  description?: Maybe<Scalars['String']>;
  /** The unique identifier */
  id: Scalars['ID'];
  image: Asset;
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<SectionWithImage>;
  /** System stage field */
  stage: Stage;
  title: Scalars['String'];
};


export type SectionWithImageImageArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type SectionWithImageLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};

export type SectionWithImageConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: SectionWithImageWhereUniqueInput;
};

/** A connection to a list of items. */
export type SectionWithImageConnection = {
  __typename?: 'SectionWithImageConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<SectionWithImageEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type SectionWithImageCreateInput = {
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  image: AssetCreateOneInlineInput;
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<SectionWithImageCreateLocalizationsInput>;
  /** title input for default locale (en) */
  title: Scalars['String'];
};

export type SectionWithImageCreateLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
  title: Scalars['String'];
};

export type SectionWithImageCreateLocalizationInput = {
  /** Localization input */
  data: SectionWithImageCreateLocalizationDataInput;
  locale: Locale;
};

export type SectionWithImageCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<SectionWithImageCreateLocalizationInput>>;
};

export type SectionWithImageCreateManyInlineInput = {
  /** Create and connect multiple existing SectionWithImage documents */
  create?: InputMaybe<Array<SectionWithImageCreateInput>>;
};

export type SectionWithImageCreateOneInlineInput = {
  /** Create and connect one SectionWithImage document */
  create?: InputMaybe<SectionWithImageCreateInput>;
};

export type SectionWithImageCreateWithPositionInput = {
  /** Document to create */
  data: SectionWithImageCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type SectionWithImageEdge = {
  __typename?: 'SectionWithImageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: SectionWithImage;
};

/** Identifies documents */
export type SectionWithImageManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<SectionWithImageWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<SectionWithImageWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<SectionWithImageWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  image?: InputMaybe<AssetWhereInput>;
};

export enum SectionWithImageOrderByInput {
  DescriptionAsc = 'description_ASC',
  DescriptionDesc = 'description_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  TitleAsc = 'title_ASC',
  TitleDesc = 'title_DESC'
}

export type SectionWithImageParent = Page;

export type SectionWithImageParentConnectInput = {
  Page?: InputMaybe<PageConnectInput>;
};

export type SectionWithImageParentCreateInput = {
  Page?: InputMaybe<PageCreateInput>;
};

export type SectionWithImageParentCreateManyInlineInput = {
  /** Connect multiple existing SectionWithImageParent documents */
  connect?: InputMaybe<Array<SectionWithImageParentWhereUniqueInput>>;
  /** Create and connect multiple existing SectionWithImageParent documents */
  create?: InputMaybe<Array<SectionWithImageParentCreateInput>>;
};

export type SectionWithImageParentCreateOneInlineInput = {
  /** Connect one existing SectionWithImageParent document */
  connect?: InputMaybe<SectionWithImageParentWhereUniqueInput>;
  /** Create and connect one SectionWithImageParent document */
  create?: InputMaybe<SectionWithImageParentCreateInput>;
};

export type SectionWithImageParentUpdateInput = {
  Page?: InputMaybe<PageUpdateInput>;
};

export type SectionWithImageParentUpdateManyInlineInput = {
  /** Connect multiple existing SectionWithImageParent documents */
  connect?: InputMaybe<Array<SectionWithImageParentConnectInput>>;
  /** Create and connect multiple SectionWithImageParent documents */
  create?: InputMaybe<Array<SectionWithImageParentCreateInput>>;
  /** Delete multiple SectionWithImageParent documents */
  delete?: InputMaybe<Array<SectionWithImageParentWhereUniqueInput>>;
  /** Disconnect multiple SectionWithImageParent documents */
  disconnect?: InputMaybe<Array<SectionWithImageParentWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing SectionWithImageParent documents */
  set?: InputMaybe<Array<SectionWithImageParentWhereUniqueInput>>;
  /** Update multiple SectionWithImageParent documents */
  update?: InputMaybe<Array<SectionWithImageParentUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple SectionWithImageParent documents */
  upsert?: InputMaybe<Array<SectionWithImageParentUpsertWithNestedWhereUniqueInput>>;
};

export type SectionWithImageParentUpdateManyWithNestedWhereInput = {
  Page?: InputMaybe<PageUpdateManyWithNestedWhereInput>;
};

export type SectionWithImageParentUpdateOneInlineInput = {
  /** Connect existing SectionWithImageParent document */
  connect?: InputMaybe<SectionWithImageParentWhereUniqueInput>;
  /** Create and connect one SectionWithImageParent document */
  create?: InputMaybe<SectionWithImageParentCreateInput>;
  /** Delete currently connected SectionWithImageParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected SectionWithImageParent document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single SectionWithImageParent document */
  update?: InputMaybe<SectionWithImageParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single SectionWithImageParent document */
  upsert?: InputMaybe<SectionWithImageParentUpsertWithNestedWhereUniqueInput>;
};

export type SectionWithImageParentUpdateWithNestedWhereUniqueInput = {
  Page?: InputMaybe<PageUpdateWithNestedWhereUniqueInput>;
};

export type SectionWithImageParentUpsertWithNestedWhereUniqueInput = {
  Page?: InputMaybe<PageUpsertWithNestedWhereUniqueInput>;
};

export type SectionWithImageParentWhereInput = {
  Page?: InputMaybe<PageWhereInput>;
};

export type SectionWithImageParentWhereUniqueInput = {
  Page?: InputMaybe<PageWhereUniqueInput>;
};

export type SectionWithImageUpdateInput = {
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<AssetUpdateOneInlineInput>;
  /** Manage document localizations */
  localizations?: InputMaybe<SectionWithImageUpdateLocalizationsInput>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
};

export type SectionWithImageUpdateLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export type SectionWithImageUpdateLocalizationInput = {
  data: SectionWithImageUpdateLocalizationDataInput;
  locale: Locale;
};

export type SectionWithImageUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<SectionWithImageCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<SectionWithImageUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<SectionWithImageUpsertLocalizationInput>>;
};

export type SectionWithImageUpdateManyInlineInput = {
  /** Create and connect multiple SectionWithImage component instances */
  create?: InputMaybe<Array<SectionWithImageCreateWithPositionInput>>;
  /** Delete multiple SectionWithImage documents */
  delete?: InputMaybe<Array<SectionWithImageWhereUniqueInput>>;
  /** Update multiple SectionWithImage component instances */
  update?: InputMaybe<Array<SectionWithImageUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple SectionWithImage component instances */
  upsert?: InputMaybe<Array<SectionWithImageUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type SectionWithImageUpdateManyInput = {
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  /** Optional updates to localizations */
  localizations?: InputMaybe<SectionWithImageUpdateManyLocalizationsInput>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
};

export type SectionWithImageUpdateManyLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export type SectionWithImageUpdateManyLocalizationInput = {
  data: SectionWithImageUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type SectionWithImageUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<SectionWithImageUpdateManyLocalizationInput>>;
};

export type SectionWithImageUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: SectionWithImageUpdateManyInput;
  /** Document search */
  where: SectionWithImageWhereInput;
};

export type SectionWithImageUpdateOneInlineInput = {
  /** Create and connect one SectionWithImage document */
  create?: InputMaybe<SectionWithImageCreateInput>;
  /** Delete currently connected SectionWithImage document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single SectionWithImage document */
  update?: InputMaybe<SectionWithImageUpdateWithNestedWhereUniqueInput>;
  /** Upsert single SectionWithImage document */
  upsert?: InputMaybe<SectionWithImageUpsertWithNestedWhereUniqueInput>;
};

export type SectionWithImageUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<SectionWithImageUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: SectionWithImageWhereUniqueInput;
};

export type SectionWithImageUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: SectionWithImageUpdateInput;
  /** Unique document search */
  where: SectionWithImageWhereUniqueInput;
};

export type SectionWithImageUpsertInput = {
  /** Create document if it didn't exist */
  create: SectionWithImageCreateInput;
  /** Update document if it exists */
  update: SectionWithImageUpdateInput;
};

export type SectionWithImageUpsertLocalizationInput = {
  create: SectionWithImageCreateLocalizationDataInput;
  locale: Locale;
  update: SectionWithImageUpdateLocalizationDataInput;
};

export type SectionWithImageUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<SectionWithImageUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: SectionWithImageWhereUniqueInput;
};

export type SectionWithImageUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: SectionWithImageUpsertInput;
  /** Unique document search */
  where: SectionWithImageWhereUniqueInput;
};

/** Identifies documents */
export type SectionWithImageWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<SectionWithImageWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<SectionWithImageWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<SectionWithImageWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  description_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  description_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  description_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  description_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  description_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  description_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  description_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  description_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  description_starts_with?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  image?: InputMaybe<AssetWhereInput>;
  title?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  title_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  title_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  title_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  title_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  title_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  title_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  title_starts_with?: InputMaybe<Scalars['String']>;
};

/** References SectionWithImage record uniquely */
export type SectionWithImageWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

/** This component is used to improve search engine indexing. Describe as much as possible all valuable information for the page. Also, give as many keywords as possible for the content of the page as well as a nice image. */
export type Seo = {
  __typename?: 'Seo';
  /** give a detailed description of the information contained on this page. This is very important for search engine optimization. The more relevant keywords are present in the description the better the page has to be referenced  */
  description: Array<Scalars['String']>;
  /** The unique identifier */
  id: Scalars['ID'];
  /** this image is useful for sharing. Put a nice image here so that when someone shares this page the image will be used. The more beautiful the image, the higher the chance that someone will be interested in clicking on it. */
  image?: Maybe<Asset>;
  /** System stage field */
  stage: Stage;
  /** The title of the page associated with this SEO */
  title?: Maybe<Scalars['String']>;
};


/** This component is used to improve search engine indexing. Describe as much as possible all valuable information for the page. Also, give as many keywords as possible for the content of the page as well as a nice image. */
export type SeoImageArgs = {
  locales?: InputMaybe<Array<Locale>>;
};

export type SeoConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: SeoWhereUniqueInput;
};

/** A connection to a list of items. */
export type SeoConnection = {
  __typename?: 'SeoConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<SeoEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type SeoCreateInput = {
  description?: InputMaybe<Array<Scalars['String']>>;
  image?: InputMaybe<AssetCreateOneInlineInput>;
  title?: InputMaybe<Scalars['String']>;
};

export type SeoCreateManyInlineInput = {
  /** Create and connect multiple existing Seo documents */
  create?: InputMaybe<Array<SeoCreateInput>>;
};

export type SeoCreateOneInlineInput = {
  /** Create and connect one Seo document */
  create?: InputMaybe<SeoCreateInput>;
};

export type SeoCreateWithPositionInput = {
  /** Document to create */
  data: SeoCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type SeoEdge = {
  __typename?: 'SeoEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Seo;
};

/** Identifies documents */
export type SeoManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<SeoWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<SeoWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<SeoWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  /** Matches if the field array contains *all* items provided to the filter and order does match */
  description?: InputMaybe<Array<Scalars['String']>>;
  /** Matches if the field array contains *all* items provided to the filter */
  description_contains_all?: InputMaybe<Array<Scalars['String']>>;
  /** Matches if the field array does not contain any of the items provided to the filter */
  description_contains_none?: InputMaybe<Array<Scalars['String']>>;
  /** Matches if the field array contains at least one item provided to the filter */
  description_contains_some?: InputMaybe<Array<Scalars['String']>>;
  /** Matches if the field array does not contains *all* items provided to the filter or order does not match */
  description_not?: InputMaybe<Array<Scalars['String']>>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  image?: InputMaybe<AssetWhereInput>;
  title?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  title_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  title_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  title_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  title_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  title_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  title_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  title_starts_with?: InputMaybe<Scalars['String']>;
};

export enum SeoOrderByInput {
  DescriptionAsc = 'description_ASC',
  DescriptionDesc = 'description_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  TitleAsc = 'title_ASC',
  TitleDesc = 'title_DESC'
}

export type SeoParent = Page;

export type SeoParentConnectInput = {
  Page?: InputMaybe<PageConnectInput>;
};

export type SeoParentCreateInput = {
  Page?: InputMaybe<PageCreateInput>;
};

export type SeoParentCreateManyInlineInput = {
  /** Connect multiple existing SeoParent documents */
  connect?: InputMaybe<Array<SeoParentWhereUniqueInput>>;
  /** Create and connect multiple existing SeoParent documents */
  create?: InputMaybe<Array<SeoParentCreateInput>>;
};

export type SeoParentCreateOneInlineInput = {
  /** Connect one existing SeoParent document */
  connect?: InputMaybe<SeoParentWhereUniqueInput>;
  /** Create and connect one SeoParent document */
  create?: InputMaybe<SeoParentCreateInput>;
};

export type SeoParentUpdateInput = {
  Page?: InputMaybe<PageUpdateInput>;
};

export type SeoParentUpdateManyInlineInput = {
  /** Connect multiple existing SeoParent documents */
  connect?: InputMaybe<Array<SeoParentConnectInput>>;
  /** Create and connect multiple SeoParent documents */
  create?: InputMaybe<Array<SeoParentCreateInput>>;
  /** Delete multiple SeoParent documents */
  delete?: InputMaybe<Array<SeoParentWhereUniqueInput>>;
  /** Disconnect multiple SeoParent documents */
  disconnect?: InputMaybe<Array<SeoParentWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing SeoParent documents */
  set?: InputMaybe<Array<SeoParentWhereUniqueInput>>;
  /** Update multiple SeoParent documents */
  update?: InputMaybe<Array<SeoParentUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple SeoParent documents */
  upsert?: InputMaybe<Array<SeoParentUpsertWithNestedWhereUniqueInput>>;
};

export type SeoParentUpdateManyWithNestedWhereInput = {
  Page?: InputMaybe<PageUpdateManyWithNestedWhereInput>;
};

export type SeoParentUpdateOneInlineInput = {
  /** Connect existing SeoParent document */
  connect?: InputMaybe<SeoParentWhereUniqueInput>;
  /** Create and connect one SeoParent document */
  create?: InputMaybe<SeoParentCreateInput>;
  /** Delete currently connected SeoParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected SeoParent document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single SeoParent document */
  update?: InputMaybe<SeoParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single SeoParent document */
  upsert?: InputMaybe<SeoParentUpsertWithNestedWhereUniqueInput>;
};

export type SeoParentUpdateWithNestedWhereUniqueInput = {
  Page?: InputMaybe<PageUpdateWithNestedWhereUniqueInput>;
};

export type SeoParentUpsertWithNestedWhereUniqueInput = {
  Page?: InputMaybe<PageUpsertWithNestedWhereUniqueInput>;
};

export type SeoParentWhereInput = {
  Page?: InputMaybe<PageWhereInput>;
};

export type SeoParentWhereUniqueInput = {
  Page?: InputMaybe<PageWhereUniqueInput>;
};

export type SeoUpdateInput = {
  description?: InputMaybe<Array<Scalars['String']>>;
  image?: InputMaybe<AssetUpdateOneInlineInput>;
  title?: InputMaybe<Scalars['String']>;
};

export type SeoUpdateManyInlineInput = {
  /** Create and connect multiple Seo component instances */
  create?: InputMaybe<Array<SeoCreateWithPositionInput>>;
  /** Delete multiple Seo documents */
  delete?: InputMaybe<Array<SeoWhereUniqueInput>>;
  /** Update multiple Seo component instances */
  update?: InputMaybe<Array<SeoUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple Seo component instances */
  upsert?: InputMaybe<Array<SeoUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type SeoUpdateManyInput = {
  description?: InputMaybe<Array<Scalars['String']>>;
  title?: InputMaybe<Scalars['String']>;
};

export type SeoUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: SeoUpdateManyInput;
  /** Document search */
  where: SeoWhereInput;
};

export type SeoUpdateOneInlineInput = {
  /** Create and connect one Seo document */
  create?: InputMaybe<SeoCreateInput>;
  /** Delete currently connected Seo document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single Seo document */
  update?: InputMaybe<SeoUpdateWithNestedWhereUniqueInput>;
  /** Upsert single Seo document */
  upsert?: InputMaybe<SeoUpsertWithNestedWhereUniqueInput>;
};

export type SeoUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<SeoUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: SeoWhereUniqueInput;
};

export type SeoUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: SeoUpdateInput;
  /** Unique document search */
  where: SeoWhereUniqueInput;
};

export type SeoUpsertInput = {
  /** Create document if it didn't exist */
  create: SeoCreateInput;
  /** Update document if it exists */
  update: SeoUpdateInput;
};

export type SeoUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<SeoUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: SeoWhereUniqueInput;
};

export type SeoUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: SeoUpsertInput;
  /** Unique document search */
  where: SeoWhereUniqueInput;
};

/** Identifies documents */
export type SeoWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<SeoWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<SeoWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<SeoWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  /** Matches if the field array contains *all* items provided to the filter and order does match */
  description?: InputMaybe<Array<Scalars['String']>>;
  /** Matches if the field array contains *all* items provided to the filter */
  description_contains_all?: InputMaybe<Array<Scalars['String']>>;
  /** Matches if the field array does not contain any of the items provided to the filter */
  description_contains_none?: InputMaybe<Array<Scalars['String']>>;
  /** Matches if the field array contains at least one item provided to the filter */
  description_contains_some?: InputMaybe<Array<Scalars['String']>>;
  /** Matches if the field array does not contains *all* items provided to the filter or order does not match */
  description_not?: InputMaybe<Array<Scalars['String']>>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  image?: InputMaybe<AssetWhereInput>;
  title?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  title_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  title_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  title_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  title_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  title_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  title_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  title_starts_with?: InputMaybe<Scalars['String']>;
};

/** References Seo record uniquely */
export type SeoWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export type Service = Node & {
  __typename?: 'Service';
  card?: Maybe<Card>;
  /** The time the document was created */
  createdAt: Scalars['DateTime'];
  /** User that created this document */
  createdBy?: Maybe<User>;
  description: Scalars['String'];
  /** Get the document in other stages */
  documentInStages: Array<Service>;
  /** List of Service versions */
  history: Array<Version>;
  icon?: Maybe<Icons>;
  /** The unique identifier */
  id: Scalars['ID'];
  imageIcon?: Maybe<Asset>;
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<Service>;
  /** The time the document was published. Null on documents in draft stage. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** User that last published this document */
  publishedBy?: Maybe<User>;
  scheduledIn: Array<ScheduledOperation>;
  /** System stage field */
  stage: Stage;
  title: Scalars['String'];
  /** The time the document was updated */
  updatedAt: Scalars['DateTime'];
  /** User that last updated this document */
  updatedBy?: Maybe<User>;
};


export type ServiceCardArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type ServiceCreatedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type ServiceCreatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type ServiceDocumentInStagesArgs = {
  includeCurrent?: Scalars['Boolean'];
  inheritLocale?: Scalars['Boolean'];
  stages?: Array<Stage>;
};


export type ServiceHistoryArgs = {
  limit?: Scalars['Int'];
  skip?: Scalars['Int'];
  stageOverride?: InputMaybe<Stage>;
};


export type ServiceImageIconArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type ServiceLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};


export type ServicePublishedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type ServicePublishedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type ServiceScheduledInArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ScheduledOperationWhereInput>;
};


export type ServiceUpdatedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type ServiceUpdatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};

export type ServiceCard = {
  __typename?: 'ServiceCard';
  description: Scalars['String'];
  icon: Icons;
  /** The unique identifier */
  id: Scalars['ID'];
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<ServiceCard>;
  /** System stage field */
  stage: Stage;
  title: Scalars['String'];
};


export type ServiceCardLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};

/** A connection to a list of items. */
export type ServiceCardConnection = {
  __typename?: 'ServiceCardConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<ServiceCardEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type ServiceCardCreateInput = {
  /** description input for default locale (en) */
  description: Scalars['String'];
  icon: Icons;
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<ServiceCardCreateLocalizationsInput>;
  title: Scalars['String'];
};

export type ServiceCardCreateLocalizationDataInput = {
  description: Scalars['String'];
};

export type ServiceCardCreateLocalizationInput = {
  /** Localization input */
  data: ServiceCardCreateLocalizationDataInput;
  locale: Locale;
};

export type ServiceCardCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<ServiceCardCreateLocalizationInput>>;
};

export type ServiceCardCreateWithPositionInput = {
  /** Document to create */
  data: ServiceCardCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type ServiceCardEdge = {
  __typename?: 'ServiceCardEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: ServiceCard;
};

/** Identifies documents */
export type ServiceCardManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<ServiceCardWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<ServiceCardWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<ServiceCardWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  icon?: InputMaybe<Icons>;
  /** All values that are contained in given list. */
  icon_in?: InputMaybe<Array<InputMaybe<Icons>>>;
  /** All values that are not equal to given value. */
  icon_not?: InputMaybe<Icons>;
  /** All values that are not contained in given list. */
  icon_not_in?: InputMaybe<Array<InputMaybe<Icons>>>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  title?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  title_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  title_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  title_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  title_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  title_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  title_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  title_starts_with?: InputMaybe<Scalars['String']>;
};

export enum ServiceCardOrderByInput {
  DescriptionAsc = 'description_ASC',
  DescriptionDesc = 'description_DESC',
  IconAsc = 'icon_ASC',
  IconDesc = 'icon_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  TitleAsc = 'title_ASC',
  TitleDesc = 'title_DESC'
}

export type ServiceCardUpdateInput = {
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  icon?: InputMaybe<Icons>;
  /** Manage document localizations */
  localizations?: InputMaybe<ServiceCardUpdateLocalizationsInput>;
  title?: InputMaybe<Scalars['String']>;
};

export type ServiceCardUpdateLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
};

export type ServiceCardUpdateLocalizationInput = {
  data: ServiceCardUpdateLocalizationDataInput;
  locale: Locale;
};

export type ServiceCardUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<ServiceCardCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<ServiceCardUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<ServiceCardUpsertLocalizationInput>>;
};

export type ServiceCardUpdateManyInput = {
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  icon?: InputMaybe<Icons>;
  /** Optional updates to localizations */
  localizations?: InputMaybe<ServiceCardUpdateManyLocalizationsInput>;
  title?: InputMaybe<Scalars['String']>;
};

export type ServiceCardUpdateManyLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
};

export type ServiceCardUpdateManyLocalizationInput = {
  data: ServiceCardUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type ServiceCardUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<ServiceCardUpdateManyLocalizationInput>>;
};

export type ServiceCardUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: ServiceCardUpdateManyInput;
  /** Document search */
  where: ServiceCardWhereInput;
};

export type ServiceCardUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<ServiceCardUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: ServiceCardWhereUniqueInput;
};

export type ServiceCardUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: ServiceCardUpdateInput;
  /** Unique document search */
  where: ServiceCardWhereUniqueInput;
};

export type ServiceCardUpsertInput = {
  /** Create document if it didn't exist */
  create: ServiceCardCreateInput;
  /** Update document if it exists */
  update: ServiceCardUpdateInput;
};

export type ServiceCardUpsertLocalizationInput = {
  create: ServiceCardCreateLocalizationDataInput;
  locale: Locale;
  update: ServiceCardUpdateLocalizationDataInput;
};

export type ServiceCardUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<ServiceCardUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: ServiceCardWhereUniqueInput;
};

export type ServiceCardUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: ServiceCardUpsertInput;
  /** Unique document search */
  where: ServiceCardWhereUniqueInput;
};

/** Identifies documents */
export type ServiceCardWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<ServiceCardWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<ServiceCardWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<ServiceCardWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  description_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  description_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  description_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  description_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  description_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  description_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  description_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  description_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  description_starts_with?: InputMaybe<Scalars['String']>;
  icon?: InputMaybe<Icons>;
  /** All values that are contained in given list. */
  icon_in?: InputMaybe<Array<InputMaybe<Icons>>>;
  /** All values that are not equal to given value. */
  icon_not?: InputMaybe<Icons>;
  /** All values that are not contained in given list. */
  icon_not_in?: InputMaybe<Array<InputMaybe<Icons>>>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  title?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  title_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  title_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  title_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  title_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  title_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  title_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  title_starts_with?: InputMaybe<Scalars['String']>;
};

/** References ServiceCard record uniquely */
export type ServiceCardWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export type ServiceConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: ServiceWhereUniqueInput;
};

/** A connection to a list of items. */
export type ServiceConnection = {
  __typename?: 'ServiceConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<ServiceEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type ServiceCreateInput = {
  card?: InputMaybe<CardCreateOneInlineInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** description input for default locale (en) */
  description: Scalars['String'];
  icon?: InputMaybe<Icons>;
  imageIcon?: InputMaybe<AssetCreateOneInlineInput>;
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<ServiceCreateLocalizationsInput>;
  /** title input for default locale (en) */
  title: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type ServiceCreateLocalizationDataInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  description: Scalars['String'];
  title: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type ServiceCreateLocalizationInput = {
  /** Localization input */
  data: ServiceCreateLocalizationDataInput;
  locale: Locale;
};

export type ServiceCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<ServiceCreateLocalizationInput>>;
};

export type ServiceCreateManyInlineInput = {
  /** Connect multiple existing Service documents */
  connect?: InputMaybe<Array<ServiceWhereUniqueInput>>;
  /** Create and connect multiple existing Service documents */
  create?: InputMaybe<Array<ServiceCreateInput>>;
};

export type ServiceCreateOneInlineInput = {
  /** Connect one existing Service document */
  connect?: InputMaybe<ServiceWhereUniqueInput>;
  /** Create and connect one Service document */
  create?: InputMaybe<ServiceCreateInput>;
};

/** An edge in a connection. */
export type ServiceEdge = {
  __typename?: 'ServiceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Service;
};

/** Identifies documents */
export type ServiceManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<ServiceWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<ServiceWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<ServiceWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  card?: InputMaybe<CardWhereInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  icon?: InputMaybe<Icons>;
  /** All values that are contained in given list. */
  icon_in?: InputMaybe<Array<InputMaybe<Icons>>>;
  /** All values that are not equal to given value. */
  icon_not?: InputMaybe<Icons>;
  /** All values that are not contained in given list. */
  icon_not_in?: InputMaybe<Array<InputMaybe<Icons>>>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  imageIcon?: InputMaybe<AssetWhereInput>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

export enum ServiceOrderByInput {
  CreatedAtAsc = 'createdAt_ASC',
  CreatedAtDesc = 'createdAt_DESC',
  DescriptionAsc = 'description_ASC',
  DescriptionDesc = 'description_DESC',
  IconAsc = 'icon_ASC',
  IconDesc = 'icon_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  PublishedAtAsc = 'publishedAt_ASC',
  PublishedAtDesc = 'publishedAt_DESC',
  TitleAsc = 'title_ASC',
  TitleDesc = 'title_DESC',
  UpdatedAtAsc = 'updatedAt_ASC',
  UpdatedAtDesc = 'updatedAt_DESC'
}

export type ServiceUpdateInput = {
  card?: InputMaybe<CardUpdateOneInlineInput>;
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  icon?: InputMaybe<Icons>;
  imageIcon?: InputMaybe<AssetUpdateOneInlineInput>;
  /** Manage document localizations */
  localizations?: InputMaybe<ServiceUpdateLocalizationsInput>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
};

export type ServiceUpdateLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export type ServiceUpdateLocalizationInput = {
  data: ServiceUpdateLocalizationDataInput;
  locale: Locale;
};

export type ServiceUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<ServiceCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<ServiceUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<ServiceUpsertLocalizationInput>>;
};

export type ServiceUpdateManyInlineInput = {
  /** Connect multiple existing Service documents */
  connect?: InputMaybe<Array<ServiceConnectInput>>;
  /** Create and connect multiple Service documents */
  create?: InputMaybe<Array<ServiceCreateInput>>;
  /** Delete multiple Service documents */
  delete?: InputMaybe<Array<ServiceWhereUniqueInput>>;
  /** Disconnect multiple Service documents */
  disconnect?: InputMaybe<Array<ServiceWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing Service documents */
  set?: InputMaybe<Array<ServiceWhereUniqueInput>>;
  /** Update multiple Service documents */
  update?: InputMaybe<Array<ServiceUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple Service documents */
  upsert?: InputMaybe<Array<ServiceUpsertWithNestedWhereUniqueInput>>;
};

export type ServiceUpdateManyInput = {
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  icon?: InputMaybe<Icons>;
  /** Optional updates to localizations */
  localizations?: InputMaybe<ServiceUpdateManyLocalizationsInput>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
};

export type ServiceUpdateManyLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

export type ServiceUpdateManyLocalizationInput = {
  data: ServiceUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type ServiceUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<ServiceUpdateManyLocalizationInput>>;
};

export type ServiceUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: ServiceUpdateManyInput;
  /** Document search */
  where: ServiceWhereInput;
};

export type ServiceUpdateOneInlineInput = {
  /** Connect existing Service document */
  connect?: InputMaybe<ServiceWhereUniqueInput>;
  /** Create and connect one Service document */
  create?: InputMaybe<ServiceCreateInput>;
  /** Delete currently connected Service document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected Service document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single Service document */
  update?: InputMaybe<ServiceUpdateWithNestedWhereUniqueInput>;
  /** Upsert single Service document */
  upsert?: InputMaybe<ServiceUpsertWithNestedWhereUniqueInput>;
};

export type ServiceUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: ServiceUpdateInput;
  /** Unique document search */
  where: ServiceWhereUniqueInput;
};

export type ServiceUpsertInput = {
  /** Create document if it didn't exist */
  create: ServiceCreateInput;
  /** Update document if it exists */
  update: ServiceUpdateInput;
};

export type ServiceUpsertLocalizationInput = {
  create: ServiceCreateLocalizationDataInput;
  locale: Locale;
  update: ServiceUpdateLocalizationDataInput;
};

export type ServiceUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: ServiceUpsertInput;
  /** Unique document search */
  where: ServiceWhereUniqueInput;
};

/** Identifies documents */
export type ServiceWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<ServiceWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<ServiceWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<ServiceWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  card?: InputMaybe<CardWhereInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  description?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  description_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  description_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  description_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  description_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  description_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  description_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  description_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  description_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  description_starts_with?: InputMaybe<Scalars['String']>;
  icon?: InputMaybe<Icons>;
  /** All values that are contained in given list. */
  icon_in?: InputMaybe<Array<InputMaybe<Icons>>>;
  /** All values that are not equal to given value. */
  icon_not?: InputMaybe<Icons>;
  /** All values that are not contained in given list. */
  icon_not_in?: InputMaybe<Array<InputMaybe<Icons>>>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  imageIcon?: InputMaybe<AssetWhereInput>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  title?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  title_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  title_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  title_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  title_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  title_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  title_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  title_starts_with?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

/** References Service record uniquely */
export type ServiceWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export type SocialLink = {
  __typename?: 'SocialLink';
  /** The unique identifier */
  id: Scalars['ID'];
  /** System stage field */
  stage: Stage;
  url?: Maybe<Scalars['String']>;
};

export type SocialLinkConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: SocialLinkWhereUniqueInput;
};

/** A connection to a list of items. */
export type SocialLinkConnection = {
  __typename?: 'SocialLinkConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<SocialLinkEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type SocialLinkCreateInput = {
  url?: InputMaybe<Scalars['String']>;
};

export type SocialLinkCreateManyInlineInput = {
  /** Create and connect multiple existing SocialLink documents */
  create?: InputMaybe<Array<SocialLinkCreateInput>>;
};

export type SocialLinkCreateOneInlineInput = {
  /** Create and connect one SocialLink document */
  create?: InputMaybe<SocialLinkCreateInput>;
};

export type SocialLinkCreateWithPositionInput = {
  /** Document to create */
  data: SocialLinkCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type SocialLinkEdge = {
  __typename?: 'SocialLinkEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: SocialLink;
};

/** Identifies documents */
export type SocialLinkManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<SocialLinkWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<SocialLinkWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<SocialLinkWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  url?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  url_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  url_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  url_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  url_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  url_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  url_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  url_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  url_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  url_starts_with?: InputMaybe<Scalars['String']>;
};

export enum SocialLinkOrderByInput {
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  UrlAsc = 'url_ASC',
  UrlDesc = 'url_DESC'
}

export type SocialLinkParent = ContactCard;

export type SocialLinkParentConnectInput = {
  ContactCard?: InputMaybe<ContactCardConnectInput>;
};

export type SocialLinkParentCreateInput = {
  ContactCard?: InputMaybe<ContactCardCreateInput>;
};

export type SocialLinkParentCreateManyInlineInput = {
  /** Connect multiple existing SocialLinkParent documents */
  connect?: InputMaybe<Array<SocialLinkParentWhereUniqueInput>>;
  /** Create and connect multiple existing SocialLinkParent documents */
  create?: InputMaybe<Array<SocialLinkParentCreateInput>>;
};

export type SocialLinkParentCreateOneInlineInput = {
  /** Connect one existing SocialLinkParent document */
  connect?: InputMaybe<SocialLinkParentWhereUniqueInput>;
  /** Create and connect one SocialLinkParent document */
  create?: InputMaybe<SocialLinkParentCreateInput>;
};

export type SocialLinkParentUpdateInput = {
  ContactCard?: InputMaybe<ContactCardUpdateInput>;
};

export type SocialLinkParentUpdateManyInlineInput = {
  /** Connect multiple existing SocialLinkParent documents */
  connect?: InputMaybe<Array<SocialLinkParentConnectInput>>;
  /** Create and connect multiple SocialLinkParent documents */
  create?: InputMaybe<Array<SocialLinkParentCreateInput>>;
  /** Delete multiple SocialLinkParent documents */
  delete?: InputMaybe<Array<SocialLinkParentWhereUniqueInput>>;
  /** Disconnect multiple SocialLinkParent documents */
  disconnect?: InputMaybe<Array<SocialLinkParentWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing SocialLinkParent documents */
  set?: InputMaybe<Array<SocialLinkParentWhereUniqueInput>>;
  /** Update multiple SocialLinkParent documents */
  update?: InputMaybe<Array<SocialLinkParentUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple SocialLinkParent documents */
  upsert?: InputMaybe<Array<SocialLinkParentUpsertWithNestedWhereUniqueInput>>;
};

export type SocialLinkParentUpdateManyWithNestedWhereInput = {
  ContactCard?: InputMaybe<ContactCardUpdateManyWithNestedWhereInput>;
};

export type SocialLinkParentUpdateOneInlineInput = {
  /** Connect existing SocialLinkParent document */
  connect?: InputMaybe<SocialLinkParentWhereUniqueInput>;
  /** Create and connect one SocialLinkParent document */
  create?: InputMaybe<SocialLinkParentCreateInput>;
  /** Delete currently connected SocialLinkParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected SocialLinkParent document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single SocialLinkParent document */
  update?: InputMaybe<SocialLinkParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single SocialLinkParent document */
  upsert?: InputMaybe<SocialLinkParentUpsertWithNestedWhereUniqueInput>;
};

export type SocialLinkParentUpdateWithNestedWhereUniqueInput = {
  ContactCard?: InputMaybe<ContactCardUpdateWithNestedWhereUniqueInput>;
};

export type SocialLinkParentUpsertWithNestedWhereUniqueInput = {
  ContactCard?: InputMaybe<ContactCardUpsertWithNestedWhereUniqueInput>;
};

export type SocialLinkParentWhereInput = {
  ContactCard?: InputMaybe<ContactCardWhereInput>;
};

export type SocialLinkParentWhereUniqueInput = {
  ContactCard?: InputMaybe<ContactCardWhereUniqueInput>;
};

export type SocialLinkUpdateInput = {
  url?: InputMaybe<Scalars['String']>;
};

export type SocialLinkUpdateManyInlineInput = {
  /** Create and connect multiple SocialLink component instances */
  create?: InputMaybe<Array<SocialLinkCreateWithPositionInput>>;
  /** Delete multiple SocialLink documents */
  delete?: InputMaybe<Array<SocialLinkWhereUniqueInput>>;
  /** Update multiple SocialLink component instances */
  update?: InputMaybe<Array<SocialLinkUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple SocialLink component instances */
  upsert?: InputMaybe<Array<SocialLinkUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type SocialLinkUpdateManyInput = {
  /** No fields in updateMany data input */
  _?: InputMaybe<Scalars['String']>;
};

export type SocialLinkUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: SocialLinkUpdateManyInput;
  /** Document search */
  where: SocialLinkWhereInput;
};

export type SocialLinkUpdateOneInlineInput = {
  /** Create and connect one SocialLink document */
  create?: InputMaybe<SocialLinkCreateInput>;
  /** Delete currently connected SocialLink document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single SocialLink document */
  update?: InputMaybe<SocialLinkUpdateWithNestedWhereUniqueInput>;
  /** Upsert single SocialLink document */
  upsert?: InputMaybe<SocialLinkUpsertWithNestedWhereUniqueInput>;
};

export type SocialLinkUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<SocialLinkUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: SocialLinkWhereUniqueInput;
};

export type SocialLinkUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: SocialLinkUpdateInput;
  /** Unique document search */
  where: SocialLinkWhereUniqueInput;
};

export type SocialLinkUpsertInput = {
  /** Create document if it didn't exist */
  create: SocialLinkCreateInput;
  /** Update document if it exists */
  update: SocialLinkUpdateInput;
};

export type SocialLinkUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<SocialLinkUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: SocialLinkWhereUniqueInput;
};

export type SocialLinkUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: SocialLinkUpsertInput;
  /** Unique document search */
  where: SocialLinkWhereUniqueInput;
};

/** Identifies documents */
export type SocialLinkWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<SocialLinkWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<SocialLinkWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<SocialLinkWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  url?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  url_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  url_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  url_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  url_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  url_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  url_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  url_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  url_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  url_starts_with?: InputMaybe<Scalars['String']>;
};

/** References SocialLink record uniquely */
export type SocialLinkWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
  url?: InputMaybe<Scalars['String']>;
};

export type Sponsor = Node & {
  __typename?: 'Sponsor';
  card?: Maybe<Card>;
  /** The time the document was created */
  createdAt: Scalars['DateTime'];
  /** User that created this document */
  createdBy?: Maybe<User>;
  description: Scalars['String'];
  /** Get the document in other stages */
  documentInStages: Array<Sponsor>;
  /** List of Sponsor versions */
  history: Array<Version>;
  /** The unique identifier */
  id: Scalars['ID'];
  link?: Maybe<Scalars['String']>;
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<Sponsor>;
  logo?: Maybe<Asset>;
  name: Scalars['String'];
  /** The time the document was published. Null on documents in draft stage. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** User that last published this document */
  publishedBy?: Maybe<User>;
  scheduledIn: Array<ScheduledOperation>;
  /** System stage field */
  stage: Stage;
  /** The time the document was updated */
  updatedAt: Scalars['DateTime'];
  /** User that last updated this document */
  updatedBy?: Maybe<User>;
};


export type SponsorCardArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type SponsorCreatedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type SponsorCreatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type SponsorDocumentInStagesArgs = {
  includeCurrent?: Scalars['Boolean'];
  inheritLocale?: Scalars['Boolean'];
  stages?: Array<Stage>;
};


export type SponsorHistoryArgs = {
  limit?: Scalars['Int'];
  skip?: Scalars['Int'];
  stageOverride?: InputMaybe<Stage>;
};


export type SponsorLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};


export type SponsorLogoArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type SponsorPublishedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type SponsorPublishedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};


export type SponsorScheduledInArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ScheduledOperationWhereInput>;
};


export type SponsorUpdatedAtArgs = {
  variation?: SystemDateTimeFieldVariation;
};


export type SponsorUpdatedByArgs = {
  locales?: InputMaybe<Array<Locale>>;
};

export type SponsorConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: SponsorWhereUniqueInput;
};

/** A connection to a list of items. */
export type SponsorConnection = {
  __typename?: 'SponsorConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<SponsorEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type SponsorCreateInput = {
  card?: InputMaybe<CardCreateOneInlineInput>;
  cl6fggxxu2e5t01uncqom1jn7?: InputMaybe<SponsorSectionCreateManyInlineInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** description input for default locale (en) */
  description: Scalars['String'];
  link?: InputMaybe<Scalars['String']>;
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<SponsorCreateLocalizationsInput>;
  logo?: InputMaybe<AssetCreateOneInlineInput>;
  name: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type SponsorCreateLocalizationDataInput = {
  createdAt?: InputMaybe<Scalars['DateTime']>;
  description: Scalars['String'];
  updatedAt?: InputMaybe<Scalars['DateTime']>;
};

export type SponsorCreateLocalizationInput = {
  /** Localization input */
  data: SponsorCreateLocalizationDataInput;
  locale: Locale;
};

export type SponsorCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<SponsorCreateLocalizationInput>>;
};

export type SponsorCreateManyInlineInput = {
  /** Connect multiple existing Sponsor documents */
  connect?: InputMaybe<Array<SponsorWhereUniqueInput>>;
  /** Create and connect multiple existing Sponsor documents */
  create?: InputMaybe<Array<SponsorCreateInput>>;
};

export type SponsorCreateOneInlineInput = {
  /** Connect one existing Sponsor document */
  connect?: InputMaybe<SponsorWhereUniqueInput>;
  /** Create and connect one Sponsor document */
  create?: InputMaybe<SponsorCreateInput>;
};

/** An edge in a connection. */
export type SponsorEdge = {
  __typename?: 'SponsorEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Sponsor;
};

/** Identifies documents */
export type SponsorManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<SponsorWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<SponsorWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<SponsorWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  card?: InputMaybe<CardWhereInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  link?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  link_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  link_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  link_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  link_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  link_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  link_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  link_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  link_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  link_starts_with?: InputMaybe<Scalars['String']>;
  logo?: InputMaybe<AssetWhereInput>;
  name?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  name_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  name_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  name_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  name_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  name_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  name_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  name_starts_with?: InputMaybe<Scalars['String']>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

export enum SponsorOrderByInput {
  CreatedAtAsc = 'createdAt_ASC',
  CreatedAtDesc = 'createdAt_DESC',
  DescriptionAsc = 'description_ASC',
  DescriptionDesc = 'description_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  LinkAsc = 'link_ASC',
  LinkDesc = 'link_DESC',
  NameAsc = 'name_ASC',
  NameDesc = 'name_DESC',
  PublishedAtAsc = 'publishedAt_ASC',
  PublishedAtDesc = 'publishedAt_DESC',
  UpdatedAtAsc = 'updatedAt_ASC',
  UpdatedAtDesc = 'updatedAt_DESC'
}

export type SponsorSection = {
  __typename?: 'SponsorSection';
  /** The unique identifier */
  id: Scalars['ID'];
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<SponsorSection>;
  sponsors: Array<Sponsor>;
  /** System stage field */
  stage: Stage;
  title: Scalars['String'];
};


export type SponsorSectionLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};


export type SponsorSectionSponsorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  orderBy?: InputMaybe<SponsorOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<SponsorWhereInput>;
};

export type SponsorSectionConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: SponsorSectionWhereUniqueInput;
};

/** A connection to a list of items. */
export type SponsorSectionConnection = {
  __typename?: 'SponsorSectionConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<SponsorSectionEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type SponsorSectionCreateInput = {
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<SponsorSectionCreateLocalizationsInput>;
  sponsors?: InputMaybe<SponsorCreateManyInlineInput>;
  /** title input for default locale (en) */
  title: Scalars['String'];
};

export type SponsorSectionCreateLocalizationDataInput = {
  title: Scalars['String'];
};

export type SponsorSectionCreateLocalizationInput = {
  /** Localization input */
  data: SponsorSectionCreateLocalizationDataInput;
  locale: Locale;
};

export type SponsorSectionCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<SponsorSectionCreateLocalizationInput>>;
};

export type SponsorSectionCreateManyInlineInput = {
  /** Create and connect multiple existing SponsorSection documents */
  create?: InputMaybe<Array<SponsorSectionCreateInput>>;
};

export type SponsorSectionCreateOneInlineInput = {
  /** Create and connect one SponsorSection document */
  create?: InputMaybe<SponsorSectionCreateInput>;
};

export type SponsorSectionCreateWithPositionInput = {
  /** Document to create */
  data: SponsorSectionCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type SponsorSectionEdge = {
  __typename?: 'SponsorSectionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: SponsorSection;
};

/** Identifies documents */
export type SponsorSectionManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<SponsorSectionWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<SponsorSectionWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<SponsorSectionWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  sponsors_every?: InputMaybe<SponsorWhereInput>;
  sponsors_none?: InputMaybe<SponsorWhereInput>;
  sponsors_some?: InputMaybe<SponsorWhereInput>;
};

export enum SponsorSectionOrderByInput {
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  TitleAsc = 'title_ASC',
  TitleDesc = 'title_DESC'
}

export type SponsorSectionParent = Page;

export type SponsorSectionParentConnectInput = {
  Page?: InputMaybe<PageConnectInput>;
};

export type SponsorSectionParentCreateInput = {
  Page?: InputMaybe<PageCreateInput>;
};

export type SponsorSectionParentCreateManyInlineInput = {
  /** Connect multiple existing SponsorSectionParent documents */
  connect?: InputMaybe<Array<SponsorSectionParentWhereUniqueInput>>;
  /** Create and connect multiple existing SponsorSectionParent documents */
  create?: InputMaybe<Array<SponsorSectionParentCreateInput>>;
};

export type SponsorSectionParentCreateOneInlineInput = {
  /** Connect one existing SponsorSectionParent document */
  connect?: InputMaybe<SponsorSectionParentWhereUniqueInput>;
  /** Create and connect one SponsorSectionParent document */
  create?: InputMaybe<SponsorSectionParentCreateInput>;
};

export type SponsorSectionParentUpdateInput = {
  Page?: InputMaybe<PageUpdateInput>;
};

export type SponsorSectionParentUpdateManyInlineInput = {
  /** Connect multiple existing SponsorSectionParent documents */
  connect?: InputMaybe<Array<SponsorSectionParentConnectInput>>;
  /** Create and connect multiple SponsorSectionParent documents */
  create?: InputMaybe<Array<SponsorSectionParentCreateInput>>;
  /** Delete multiple SponsorSectionParent documents */
  delete?: InputMaybe<Array<SponsorSectionParentWhereUniqueInput>>;
  /** Disconnect multiple SponsorSectionParent documents */
  disconnect?: InputMaybe<Array<SponsorSectionParentWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing SponsorSectionParent documents */
  set?: InputMaybe<Array<SponsorSectionParentWhereUniqueInput>>;
  /** Update multiple SponsorSectionParent documents */
  update?: InputMaybe<Array<SponsorSectionParentUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple SponsorSectionParent documents */
  upsert?: InputMaybe<Array<SponsorSectionParentUpsertWithNestedWhereUniqueInput>>;
};

export type SponsorSectionParentUpdateManyWithNestedWhereInput = {
  Page?: InputMaybe<PageUpdateManyWithNestedWhereInput>;
};

export type SponsorSectionParentUpdateOneInlineInput = {
  /** Connect existing SponsorSectionParent document */
  connect?: InputMaybe<SponsorSectionParentWhereUniqueInput>;
  /** Create and connect one SponsorSectionParent document */
  create?: InputMaybe<SponsorSectionParentCreateInput>;
  /** Delete currently connected SponsorSectionParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected SponsorSectionParent document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single SponsorSectionParent document */
  update?: InputMaybe<SponsorSectionParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single SponsorSectionParent document */
  upsert?: InputMaybe<SponsorSectionParentUpsertWithNestedWhereUniqueInput>;
};

export type SponsorSectionParentUpdateWithNestedWhereUniqueInput = {
  Page?: InputMaybe<PageUpdateWithNestedWhereUniqueInput>;
};

export type SponsorSectionParentUpsertWithNestedWhereUniqueInput = {
  Page?: InputMaybe<PageUpsertWithNestedWhereUniqueInput>;
};

export type SponsorSectionParentWhereInput = {
  Page?: InputMaybe<PageWhereInput>;
};

export type SponsorSectionParentWhereUniqueInput = {
  Page?: InputMaybe<PageWhereUniqueInput>;
};

export type SponsorSectionUpdateInput = {
  /** Manage document localizations */
  localizations?: InputMaybe<SponsorSectionUpdateLocalizationsInput>;
  sponsors?: InputMaybe<SponsorUpdateManyInlineInput>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
};

export type SponsorSectionUpdateLocalizationDataInput = {
  title?: InputMaybe<Scalars['String']>;
};

export type SponsorSectionUpdateLocalizationInput = {
  data: SponsorSectionUpdateLocalizationDataInput;
  locale: Locale;
};

export type SponsorSectionUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<SponsorSectionCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<SponsorSectionUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<SponsorSectionUpsertLocalizationInput>>;
};

export type SponsorSectionUpdateManyInlineInput = {
  /** Create and connect multiple SponsorSection component instances */
  create?: InputMaybe<Array<SponsorSectionCreateWithPositionInput>>;
  /** Delete multiple SponsorSection documents */
  delete?: InputMaybe<Array<SponsorSectionWhereUniqueInput>>;
  /** Update multiple SponsorSection component instances */
  update?: InputMaybe<Array<SponsorSectionUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple SponsorSection component instances */
  upsert?: InputMaybe<Array<SponsorSectionUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type SponsorSectionUpdateManyInput = {
  /** Optional updates to localizations */
  localizations?: InputMaybe<SponsorSectionUpdateManyLocalizationsInput>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
};

export type SponsorSectionUpdateManyLocalizationDataInput = {
  title?: InputMaybe<Scalars['String']>;
};

export type SponsorSectionUpdateManyLocalizationInput = {
  data: SponsorSectionUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type SponsorSectionUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<SponsorSectionUpdateManyLocalizationInput>>;
};

export type SponsorSectionUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: SponsorSectionUpdateManyInput;
  /** Document search */
  where: SponsorSectionWhereInput;
};

export type SponsorSectionUpdateOneInlineInput = {
  /** Create and connect one SponsorSection document */
  create?: InputMaybe<SponsorSectionCreateInput>;
  /** Delete currently connected SponsorSection document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single SponsorSection document */
  update?: InputMaybe<SponsorSectionUpdateWithNestedWhereUniqueInput>;
  /** Upsert single SponsorSection document */
  upsert?: InputMaybe<SponsorSectionUpsertWithNestedWhereUniqueInput>;
};

export type SponsorSectionUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<SponsorSectionUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: SponsorSectionWhereUniqueInput;
};

export type SponsorSectionUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: SponsorSectionUpdateInput;
  /** Unique document search */
  where: SponsorSectionWhereUniqueInput;
};

export type SponsorSectionUpsertInput = {
  /** Create document if it didn't exist */
  create: SponsorSectionCreateInput;
  /** Update document if it exists */
  update: SponsorSectionUpdateInput;
};

export type SponsorSectionUpsertLocalizationInput = {
  create: SponsorSectionCreateLocalizationDataInput;
  locale: Locale;
  update: SponsorSectionUpdateLocalizationDataInput;
};

export type SponsorSectionUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<SponsorSectionUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: SponsorSectionWhereUniqueInput;
};

export type SponsorSectionUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: SponsorSectionUpsertInput;
  /** Unique document search */
  where: SponsorSectionWhereUniqueInput;
};

/** Identifies documents */
export type SponsorSectionWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<SponsorSectionWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<SponsorSectionWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<SponsorSectionWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  sponsors_every?: InputMaybe<SponsorWhereInput>;
  sponsors_none?: InputMaybe<SponsorWhereInput>;
  sponsors_some?: InputMaybe<SponsorWhereInput>;
  title?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  title_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  title_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  title_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  title_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  title_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  title_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  title_starts_with?: InputMaybe<Scalars['String']>;
};

/** References SponsorSection record uniquely */
export type SponsorSectionWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export type SponsorUpdateInput = {
  card?: InputMaybe<CardUpdateOneInlineInput>;
  cl6fggxxu2e5t01uncqom1jn7?: InputMaybe<SponsorSectionUpdateManyInlineInput>;
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  link?: InputMaybe<Scalars['String']>;
  /** Manage document localizations */
  localizations?: InputMaybe<SponsorUpdateLocalizationsInput>;
  logo?: InputMaybe<AssetUpdateOneInlineInput>;
  name?: InputMaybe<Scalars['String']>;
};

export type SponsorUpdateLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
};

export type SponsorUpdateLocalizationInput = {
  data: SponsorUpdateLocalizationDataInput;
  locale: Locale;
};

export type SponsorUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<SponsorCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<SponsorUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<SponsorUpsertLocalizationInput>>;
};

export type SponsorUpdateManyInlineInput = {
  /** Connect multiple existing Sponsor documents */
  connect?: InputMaybe<Array<SponsorConnectInput>>;
  /** Create and connect multiple Sponsor documents */
  create?: InputMaybe<Array<SponsorCreateInput>>;
  /** Delete multiple Sponsor documents */
  delete?: InputMaybe<Array<SponsorWhereUniqueInput>>;
  /** Disconnect multiple Sponsor documents */
  disconnect?: InputMaybe<Array<SponsorWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing Sponsor documents */
  set?: InputMaybe<Array<SponsorWhereUniqueInput>>;
  /** Update multiple Sponsor documents */
  update?: InputMaybe<Array<SponsorUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple Sponsor documents */
  upsert?: InputMaybe<Array<SponsorUpsertWithNestedWhereUniqueInput>>;
};

export type SponsorUpdateManyInput = {
  /** description input for default locale (en) */
  description?: InputMaybe<Scalars['String']>;
  /** Optional updates to localizations */
  localizations?: InputMaybe<SponsorUpdateManyLocalizationsInput>;
};

export type SponsorUpdateManyLocalizationDataInput = {
  description?: InputMaybe<Scalars['String']>;
};

export type SponsorUpdateManyLocalizationInput = {
  data: SponsorUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type SponsorUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<SponsorUpdateManyLocalizationInput>>;
};

export type SponsorUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: SponsorUpdateManyInput;
  /** Document search */
  where: SponsorWhereInput;
};

export type SponsorUpdateOneInlineInput = {
  /** Connect existing Sponsor document */
  connect?: InputMaybe<SponsorWhereUniqueInput>;
  /** Create and connect one Sponsor document */
  create?: InputMaybe<SponsorCreateInput>;
  /** Delete currently connected Sponsor document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected Sponsor document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single Sponsor document */
  update?: InputMaybe<SponsorUpdateWithNestedWhereUniqueInput>;
  /** Upsert single Sponsor document */
  upsert?: InputMaybe<SponsorUpsertWithNestedWhereUniqueInput>;
};

export type SponsorUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: SponsorUpdateInput;
  /** Unique document search */
  where: SponsorWhereUniqueInput;
};

export type SponsorUpsertInput = {
  /** Create document if it didn't exist */
  create: SponsorCreateInput;
  /** Update document if it exists */
  update: SponsorUpdateInput;
};

export type SponsorUpsertLocalizationInput = {
  create: SponsorCreateLocalizationDataInput;
  locale: Locale;
  update: SponsorUpdateLocalizationDataInput;
};

export type SponsorUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: SponsorUpsertInput;
  /** Unique document search */
  where: SponsorWhereUniqueInput;
};

/** Identifies documents */
export type SponsorWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<SponsorWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<SponsorWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<SponsorWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  card?: InputMaybe<CardWhereInput>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  createdBy?: InputMaybe<UserWhereInput>;
  description?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  description_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  description_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  description_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  description_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  description_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  description_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  description_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  description_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  description_starts_with?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  link?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  link_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  link_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  link_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  link_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  link_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  link_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  link_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  link_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  link_starts_with?: InputMaybe<Scalars['String']>;
  logo?: InputMaybe<AssetWhereInput>;
  name?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  name_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  name_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  name_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  name_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  name_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  name_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  name_starts_with?: InputMaybe<Scalars['String']>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  publishedBy?: InputMaybe<UserWhereInput>;
  scheduledIn_every?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_none?: InputMaybe<ScheduledOperationWhereInput>;
  scheduledIn_some?: InputMaybe<ScheduledOperationWhereInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedBy?: InputMaybe<UserWhereInput>;
};

/** References Sponsor record uniquely */
export type SponsorWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
  link?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
};

/** Stage system enumeration */
export enum Stage {
  /** The Draft is the default stage for all your content. */
  Draft = 'DRAFT',
  /** The Published stage is where you can publish your content to. */
  Published = 'PUBLISHED'
}

/** The model is used to add style to specific components. This model is made up of some basic style properties and the possibility to add custom CSS style using tailwindcss. */
export type Style = {
  __typename?: 'Style';
  bgColor?: Maybe<Color>;
  classNames?: Maybe<Scalars['String']>;
  color?: Maybe<Color>;
  /** The unique identifier */
  id: Scalars['ID'];
  /** System stage field */
  stage: Stage;
};

export type StyleConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: StyleWhereUniqueInput;
};

/** A connection to a list of items. */
export type StyleConnection = {
  __typename?: 'StyleConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<StyleEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type StyleCreateInput = {
  bgColor?: InputMaybe<ColorInput>;
  classNames?: InputMaybe<Scalars['String']>;
  color?: InputMaybe<ColorInput>;
};

export type StyleCreateManyInlineInput = {
  /** Create and connect multiple existing Style documents */
  create?: InputMaybe<Array<StyleCreateInput>>;
};

export type StyleCreateOneInlineInput = {
  /** Create and connect one Style document */
  create?: InputMaybe<StyleCreateInput>;
};

export type StyleCreateWithPositionInput = {
  /** Document to create */
  data: StyleCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type StyleEdge = {
  __typename?: 'StyleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Style;
};

/** Identifies documents */
export type StyleManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<StyleWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<StyleWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<StyleWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  classNames?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  classNames_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  classNames_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  classNames_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  classNames_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  classNames_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  classNames_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  classNames_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  classNames_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  classNames_starts_with?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
};

export enum StyleOrderByInput {
  ClassNamesAsc = 'classNames_ASC',
  ClassNamesDesc = 'classNames_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC'
}

export type StyleParent = Container | MdText | RichTextWrapper | Text | Title;

export type StyleParentConnectInput = {
  Container?: InputMaybe<ContainerConnectInput>;
  MdText?: InputMaybe<MdTextConnectInput>;
  RichTextWrapper?: InputMaybe<RichTextWrapperConnectInput>;
  Text?: InputMaybe<TextConnectInput>;
  Title?: InputMaybe<TitleConnectInput>;
};

export type StyleParentCreateInput = {
  Container?: InputMaybe<ContainerCreateInput>;
  MdText?: InputMaybe<MdTextCreateInput>;
  RichTextWrapper?: InputMaybe<RichTextWrapperCreateInput>;
  Text?: InputMaybe<TextCreateInput>;
  Title?: InputMaybe<TitleCreateInput>;
};

export type StyleParentCreateManyInlineInput = {
  /** Connect multiple existing StyleParent documents */
  connect?: InputMaybe<Array<StyleParentWhereUniqueInput>>;
  /** Create and connect multiple existing StyleParent documents */
  create?: InputMaybe<Array<StyleParentCreateInput>>;
};

export type StyleParentCreateOneInlineInput = {
  /** Connect one existing StyleParent document */
  connect?: InputMaybe<StyleParentWhereUniqueInput>;
  /** Create and connect one StyleParent document */
  create?: InputMaybe<StyleParentCreateInput>;
};

export type StyleParentUpdateInput = {
  Container?: InputMaybe<ContainerUpdateInput>;
  MdText?: InputMaybe<MdTextUpdateInput>;
  RichTextWrapper?: InputMaybe<RichTextWrapperUpdateInput>;
  Text?: InputMaybe<TextUpdateInput>;
  Title?: InputMaybe<TitleUpdateInput>;
};

export type StyleParentUpdateManyInlineInput = {
  /** Connect multiple existing StyleParent documents */
  connect?: InputMaybe<Array<StyleParentConnectInput>>;
  /** Create and connect multiple StyleParent documents */
  create?: InputMaybe<Array<StyleParentCreateInput>>;
  /** Delete multiple StyleParent documents */
  delete?: InputMaybe<Array<StyleParentWhereUniqueInput>>;
  /** Disconnect multiple StyleParent documents */
  disconnect?: InputMaybe<Array<StyleParentWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing StyleParent documents */
  set?: InputMaybe<Array<StyleParentWhereUniqueInput>>;
  /** Update multiple StyleParent documents */
  update?: InputMaybe<Array<StyleParentUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple StyleParent documents */
  upsert?: InputMaybe<Array<StyleParentUpsertWithNestedWhereUniqueInput>>;
};

export type StyleParentUpdateManyWithNestedWhereInput = {
  Container?: InputMaybe<ContainerUpdateManyWithNestedWhereInput>;
  MdText?: InputMaybe<MdTextUpdateManyWithNestedWhereInput>;
  RichTextWrapper?: InputMaybe<RichTextWrapperUpdateManyWithNestedWhereInput>;
  Text?: InputMaybe<TextUpdateManyWithNestedWhereInput>;
  Title?: InputMaybe<TitleUpdateManyWithNestedWhereInput>;
};

export type StyleParentUpdateOneInlineInput = {
  /** Connect existing StyleParent document */
  connect?: InputMaybe<StyleParentWhereUniqueInput>;
  /** Create and connect one StyleParent document */
  create?: InputMaybe<StyleParentCreateInput>;
  /** Delete currently connected StyleParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected StyleParent document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single StyleParent document */
  update?: InputMaybe<StyleParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single StyleParent document */
  upsert?: InputMaybe<StyleParentUpsertWithNestedWhereUniqueInput>;
};

export type StyleParentUpdateWithNestedWhereUniqueInput = {
  Container?: InputMaybe<ContainerUpdateWithNestedWhereUniqueInput>;
  MdText?: InputMaybe<MdTextUpdateWithNestedWhereUniqueInput>;
  RichTextWrapper?: InputMaybe<RichTextWrapperUpdateWithNestedWhereUniqueInput>;
  Text?: InputMaybe<TextUpdateWithNestedWhereUniqueInput>;
  Title?: InputMaybe<TitleUpdateWithNestedWhereUniqueInput>;
};

export type StyleParentUpsertWithNestedWhereUniqueInput = {
  Container?: InputMaybe<ContainerUpsertWithNestedWhereUniqueInput>;
  MdText?: InputMaybe<MdTextUpsertWithNestedWhereUniqueInput>;
  RichTextWrapper?: InputMaybe<RichTextWrapperUpsertWithNestedWhereUniqueInput>;
  Text?: InputMaybe<TextUpsertWithNestedWhereUniqueInput>;
  Title?: InputMaybe<TitleUpsertWithNestedWhereUniqueInput>;
};

export type StyleParentWhereInput = {
  Container?: InputMaybe<ContainerWhereInput>;
  MdText?: InputMaybe<MdTextWhereInput>;
  RichTextWrapper?: InputMaybe<RichTextWrapperWhereInput>;
  Text?: InputMaybe<TextWhereInput>;
  Title?: InputMaybe<TitleWhereInput>;
};

export type StyleParentWhereUniqueInput = {
  Container?: InputMaybe<ContainerWhereUniqueInput>;
  MdText?: InputMaybe<MdTextWhereUniqueInput>;
  RichTextWrapper?: InputMaybe<RichTextWrapperWhereUniqueInput>;
  Text?: InputMaybe<TextWhereUniqueInput>;
  Title?: InputMaybe<TitleWhereUniqueInput>;
};

export type StyleUpdateInput = {
  bgColor?: InputMaybe<ColorInput>;
  classNames?: InputMaybe<Scalars['String']>;
  color?: InputMaybe<ColorInput>;
};

export type StyleUpdateManyInlineInput = {
  /** Create and connect multiple Style component instances */
  create?: InputMaybe<Array<StyleCreateWithPositionInput>>;
  /** Delete multiple Style documents */
  delete?: InputMaybe<Array<StyleWhereUniqueInput>>;
  /** Update multiple Style component instances */
  update?: InputMaybe<Array<StyleUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple Style component instances */
  upsert?: InputMaybe<Array<StyleUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type StyleUpdateManyInput = {
  bgColor?: InputMaybe<ColorInput>;
  classNames?: InputMaybe<Scalars['String']>;
  color?: InputMaybe<ColorInput>;
};

export type StyleUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: StyleUpdateManyInput;
  /** Document search */
  where: StyleWhereInput;
};

export type StyleUpdateOneInlineInput = {
  /** Create and connect one Style document */
  create?: InputMaybe<StyleCreateInput>;
  /** Delete currently connected Style document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single Style document */
  update?: InputMaybe<StyleUpdateWithNestedWhereUniqueInput>;
  /** Upsert single Style document */
  upsert?: InputMaybe<StyleUpsertWithNestedWhereUniqueInput>;
};

export type StyleUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<StyleUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: StyleWhereUniqueInput;
};

export type StyleUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: StyleUpdateInput;
  /** Unique document search */
  where: StyleWhereUniqueInput;
};

export type StyleUpsertInput = {
  /** Create document if it didn't exist */
  create: StyleCreateInput;
  /** Update document if it exists */
  update: StyleUpdateInput;
};

export type StyleUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<StyleUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: StyleWhereUniqueInput;
};

export type StyleUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: StyleUpsertInput;
  /** Unique document search */
  where: StyleWhereUniqueInput;
};

/** Identifies documents */
export type StyleWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<StyleWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<StyleWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<StyleWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  classNames?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  classNames_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  classNames_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  classNames_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  classNames_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  classNames_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  classNames_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  classNames_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  classNames_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  classNames_starts_with?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
};

/** References Style record uniquely */
export type StyleWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export enum SystemDateTimeFieldVariation {
  Base = 'BASE',
  Combined = 'COMBINED',
  Localization = 'LOCALIZATION'
}

export type TeamSection = {
  __typename?: 'TeamSection';
  /** The unique identifier */
  id: Scalars['ID'];
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<TeamSection>;
  people: Array<Person>;
  /** System stage field */
  stage: Stage;
  title: Scalars['String'];
};


export type TeamSectionLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};


export type TeamSectionPeopleArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  locales?: InputMaybe<Array<Locale>>;
  orderBy?: InputMaybe<PersonOrderByInput>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PersonWhereInput>;
};

export type TeamSectionConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: TeamSectionWhereUniqueInput;
};

/** A connection to a list of items. */
export type TeamSectionConnection = {
  __typename?: 'TeamSectionConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<TeamSectionEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type TeamSectionCreateInput = {
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<TeamSectionCreateLocalizationsInput>;
  people?: InputMaybe<PersonCreateManyInlineInput>;
  /** title input for default locale (en) */
  title: Scalars['String'];
};

export type TeamSectionCreateLocalizationDataInput = {
  title: Scalars['String'];
};

export type TeamSectionCreateLocalizationInput = {
  /** Localization input */
  data: TeamSectionCreateLocalizationDataInput;
  locale: Locale;
};

export type TeamSectionCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<TeamSectionCreateLocalizationInput>>;
};

export type TeamSectionCreateManyInlineInput = {
  /** Create and connect multiple existing TeamSection documents */
  create?: InputMaybe<Array<TeamSectionCreateInput>>;
};

export type TeamSectionCreateOneInlineInput = {
  /** Create and connect one TeamSection document */
  create?: InputMaybe<TeamSectionCreateInput>;
};

export type TeamSectionCreateWithPositionInput = {
  /** Document to create */
  data: TeamSectionCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type TeamSectionEdge = {
  __typename?: 'TeamSectionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: TeamSection;
};

/** Identifies documents */
export type TeamSectionManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<TeamSectionWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<TeamSectionWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<TeamSectionWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  people_every?: InputMaybe<PersonWhereInput>;
  people_none?: InputMaybe<PersonWhereInput>;
  people_some?: InputMaybe<PersonWhereInput>;
};

export enum TeamSectionOrderByInput {
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  TitleAsc = 'title_ASC',
  TitleDesc = 'title_DESC'
}

export type TeamSectionParent = Page;

export type TeamSectionParentConnectInput = {
  Page?: InputMaybe<PageConnectInput>;
};

export type TeamSectionParentCreateInput = {
  Page?: InputMaybe<PageCreateInput>;
};

export type TeamSectionParentCreateManyInlineInput = {
  /** Connect multiple existing TeamSectionParent documents */
  connect?: InputMaybe<Array<TeamSectionParentWhereUniqueInput>>;
  /** Create and connect multiple existing TeamSectionParent documents */
  create?: InputMaybe<Array<TeamSectionParentCreateInput>>;
};

export type TeamSectionParentCreateOneInlineInput = {
  /** Connect one existing TeamSectionParent document */
  connect?: InputMaybe<TeamSectionParentWhereUniqueInput>;
  /** Create and connect one TeamSectionParent document */
  create?: InputMaybe<TeamSectionParentCreateInput>;
};

export type TeamSectionParentUpdateInput = {
  Page?: InputMaybe<PageUpdateInput>;
};

export type TeamSectionParentUpdateManyInlineInput = {
  /** Connect multiple existing TeamSectionParent documents */
  connect?: InputMaybe<Array<TeamSectionParentConnectInput>>;
  /** Create and connect multiple TeamSectionParent documents */
  create?: InputMaybe<Array<TeamSectionParentCreateInput>>;
  /** Delete multiple TeamSectionParent documents */
  delete?: InputMaybe<Array<TeamSectionParentWhereUniqueInput>>;
  /** Disconnect multiple TeamSectionParent documents */
  disconnect?: InputMaybe<Array<TeamSectionParentWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing TeamSectionParent documents */
  set?: InputMaybe<Array<TeamSectionParentWhereUniqueInput>>;
  /** Update multiple TeamSectionParent documents */
  update?: InputMaybe<Array<TeamSectionParentUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple TeamSectionParent documents */
  upsert?: InputMaybe<Array<TeamSectionParentUpsertWithNestedWhereUniqueInput>>;
};

export type TeamSectionParentUpdateManyWithNestedWhereInput = {
  Page?: InputMaybe<PageUpdateManyWithNestedWhereInput>;
};

export type TeamSectionParentUpdateOneInlineInput = {
  /** Connect existing TeamSectionParent document */
  connect?: InputMaybe<TeamSectionParentWhereUniqueInput>;
  /** Create and connect one TeamSectionParent document */
  create?: InputMaybe<TeamSectionParentCreateInput>;
  /** Delete currently connected TeamSectionParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected TeamSectionParent document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single TeamSectionParent document */
  update?: InputMaybe<TeamSectionParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single TeamSectionParent document */
  upsert?: InputMaybe<TeamSectionParentUpsertWithNestedWhereUniqueInput>;
};

export type TeamSectionParentUpdateWithNestedWhereUniqueInput = {
  Page?: InputMaybe<PageUpdateWithNestedWhereUniqueInput>;
};

export type TeamSectionParentUpsertWithNestedWhereUniqueInput = {
  Page?: InputMaybe<PageUpsertWithNestedWhereUniqueInput>;
};

export type TeamSectionParentWhereInput = {
  Page?: InputMaybe<PageWhereInput>;
};

export type TeamSectionParentWhereUniqueInput = {
  Page?: InputMaybe<PageWhereUniqueInput>;
};

export type TeamSectionUpdateInput = {
  /** Manage document localizations */
  localizations?: InputMaybe<TeamSectionUpdateLocalizationsInput>;
  people?: InputMaybe<PersonUpdateManyInlineInput>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
};

export type TeamSectionUpdateLocalizationDataInput = {
  title?: InputMaybe<Scalars['String']>;
};

export type TeamSectionUpdateLocalizationInput = {
  data: TeamSectionUpdateLocalizationDataInput;
  locale: Locale;
};

export type TeamSectionUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<TeamSectionCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<TeamSectionUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<TeamSectionUpsertLocalizationInput>>;
};

export type TeamSectionUpdateManyInlineInput = {
  /** Create and connect multiple TeamSection component instances */
  create?: InputMaybe<Array<TeamSectionCreateWithPositionInput>>;
  /** Delete multiple TeamSection documents */
  delete?: InputMaybe<Array<TeamSectionWhereUniqueInput>>;
  /** Update multiple TeamSection component instances */
  update?: InputMaybe<Array<TeamSectionUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple TeamSection component instances */
  upsert?: InputMaybe<Array<TeamSectionUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type TeamSectionUpdateManyInput = {
  /** Optional updates to localizations */
  localizations?: InputMaybe<TeamSectionUpdateManyLocalizationsInput>;
  /** title input for default locale (en) */
  title?: InputMaybe<Scalars['String']>;
};

export type TeamSectionUpdateManyLocalizationDataInput = {
  title?: InputMaybe<Scalars['String']>;
};

export type TeamSectionUpdateManyLocalizationInput = {
  data: TeamSectionUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type TeamSectionUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<TeamSectionUpdateManyLocalizationInput>>;
};

export type TeamSectionUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: TeamSectionUpdateManyInput;
  /** Document search */
  where: TeamSectionWhereInput;
};

export type TeamSectionUpdateOneInlineInput = {
  /** Create and connect one TeamSection document */
  create?: InputMaybe<TeamSectionCreateInput>;
  /** Delete currently connected TeamSection document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single TeamSection document */
  update?: InputMaybe<TeamSectionUpdateWithNestedWhereUniqueInput>;
  /** Upsert single TeamSection document */
  upsert?: InputMaybe<TeamSectionUpsertWithNestedWhereUniqueInput>;
};

export type TeamSectionUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<TeamSectionUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: TeamSectionWhereUniqueInput;
};

export type TeamSectionUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: TeamSectionUpdateInput;
  /** Unique document search */
  where: TeamSectionWhereUniqueInput;
};

export type TeamSectionUpsertInput = {
  /** Create document if it didn't exist */
  create: TeamSectionCreateInput;
  /** Update document if it exists */
  update: TeamSectionUpdateInput;
};

export type TeamSectionUpsertLocalizationInput = {
  create: TeamSectionCreateLocalizationDataInput;
  locale: Locale;
  update: TeamSectionUpdateLocalizationDataInput;
};

export type TeamSectionUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<TeamSectionUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: TeamSectionWhereUniqueInput;
};

export type TeamSectionUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: TeamSectionUpsertInput;
  /** Unique document search */
  where: TeamSectionWhereUniqueInput;
};

/** Identifies documents */
export type TeamSectionWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<TeamSectionWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<TeamSectionWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<TeamSectionWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  people_every?: InputMaybe<PersonWhereInput>;
  people_none?: InputMaybe<PersonWhereInput>;
  people_some?: InputMaybe<PersonWhereInput>;
  title?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  title_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  title_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  title_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  title_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  title_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  title_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  title_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  title_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  title_starts_with?: InputMaybe<Scalars['String']>;
};

/** References TeamSection record uniquely */
export type TeamSectionWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export type Text = {
  __typename?: 'Text';
  /** The unique identifier */
  id: Scalars['ID'];
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<Text>;
  /** System stage field */
  stage: Stage;
  style?: Maybe<Style>;
  value: Scalars['String'];
};


export type TextLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};


export type TextStyleArgs = {
  locales?: InputMaybe<Array<Locale>>;
};

export type TextConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: TextWhereUniqueInput;
};

/** A connection to a list of items. */
export type TextConnection = {
  __typename?: 'TextConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<TextEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type TextCreateInput = {
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<TextCreateLocalizationsInput>;
  style?: InputMaybe<StyleCreateOneInlineInput>;
  /** value input for default locale (en) */
  value: Scalars['String'];
};

export type TextCreateLocalizationDataInput = {
  value: Scalars['String'];
};

export type TextCreateLocalizationInput = {
  /** Localization input */
  data: TextCreateLocalizationDataInput;
  locale: Locale;
};

export type TextCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<TextCreateLocalizationInput>>;
};

export type TextCreateManyInlineInput = {
  /** Create and connect multiple existing Text documents */
  create?: InputMaybe<Array<TextCreateInput>>;
};

export type TextCreateOneInlineInput = {
  /** Create and connect one Text document */
  create?: InputMaybe<TextCreateInput>;
};

export type TextCreateWithPositionInput = {
  /** Document to create */
  data: TextCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type TextEdge = {
  __typename?: 'TextEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Text;
};

/** Identifies documents */
export type TextManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<TextWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<TextWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<TextWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  style?: InputMaybe<StyleWhereInput>;
};

export enum TextOrderByInput {
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  ValueAsc = 'value_ASC',
  ValueDesc = 'value_DESC'
}

export type TextParent = Container;

export type TextParentConnectInput = {
  Container?: InputMaybe<ContainerConnectInput>;
};

export type TextParentCreateInput = {
  Container?: InputMaybe<ContainerCreateInput>;
};

export type TextParentCreateManyInlineInput = {
  /** Connect multiple existing TextParent documents */
  connect?: InputMaybe<Array<TextParentWhereUniqueInput>>;
  /** Create and connect multiple existing TextParent documents */
  create?: InputMaybe<Array<TextParentCreateInput>>;
};

export type TextParentCreateOneInlineInput = {
  /** Connect one existing TextParent document */
  connect?: InputMaybe<TextParentWhereUniqueInput>;
  /** Create and connect one TextParent document */
  create?: InputMaybe<TextParentCreateInput>;
};

export type TextParentUpdateInput = {
  Container?: InputMaybe<ContainerUpdateInput>;
};

export type TextParentUpdateManyInlineInput = {
  /** Connect multiple existing TextParent documents */
  connect?: InputMaybe<Array<TextParentConnectInput>>;
  /** Create and connect multiple TextParent documents */
  create?: InputMaybe<Array<TextParentCreateInput>>;
  /** Delete multiple TextParent documents */
  delete?: InputMaybe<Array<TextParentWhereUniqueInput>>;
  /** Disconnect multiple TextParent documents */
  disconnect?: InputMaybe<Array<TextParentWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing TextParent documents */
  set?: InputMaybe<Array<TextParentWhereUniqueInput>>;
  /** Update multiple TextParent documents */
  update?: InputMaybe<Array<TextParentUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple TextParent documents */
  upsert?: InputMaybe<Array<TextParentUpsertWithNestedWhereUniqueInput>>;
};

export type TextParentUpdateManyWithNestedWhereInput = {
  Container?: InputMaybe<ContainerUpdateManyWithNestedWhereInput>;
};

export type TextParentUpdateOneInlineInput = {
  /** Connect existing TextParent document */
  connect?: InputMaybe<TextParentWhereUniqueInput>;
  /** Create and connect one TextParent document */
  create?: InputMaybe<TextParentCreateInput>;
  /** Delete currently connected TextParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected TextParent document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single TextParent document */
  update?: InputMaybe<TextParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single TextParent document */
  upsert?: InputMaybe<TextParentUpsertWithNestedWhereUniqueInput>;
};

export type TextParentUpdateWithNestedWhereUniqueInput = {
  Container?: InputMaybe<ContainerUpdateWithNestedWhereUniqueInput>;
};

export type TextParentUpsertWithNestedWhereUniqueInput = {
  Container?: InputMaybe<ContainerUpsertWithNestedWhereUniqueInput>;
};

export type TextParentWhereInput = {
  Container?: InputMaybe<ContainerWhereInput>;
};

export type TextParentWhereUniqueInput = {
  Container?: InputMaybe<ContainerWhereUniqueInput>;
};

export type TextUpdateInput = {
  /** Manage document localizations */
  localizations?: InputMaybe<TextUpdateLocalizationsInput>;
  style?: InputMaybe<StyleUpdateOneInlineInput>;
  /** value input for default locale (en) */
  value?: InputMaybe<Scalars['String']>;
};

export type TextUpdateLocalizationDataInput = {
  value?: InputMaybe<Scalars['String']>;
};

export type TextUpdateLocalizationInput = {
  data: TextUpdateLocalizationDataInput;
  locale: Locale;
};

export type TextUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<TextCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<TextUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<TextUpsertLocalizationInput>>;
};

export type TextUpdateManyInlineInput = {
  /** Create and connect multiple Text component instances */
  create?: InputMaybe<Array<TextCreateWithPositionInput>>;
  /** Delete multiple Text documents */
  delete?: InputMaybe<Array<TextWhereUniqueInput>>;
  /** Update multiple Text component instances */
  update?: InputMaybe<Array<TextUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple Text component instances */
  upsert?: InputMaybe<Array<TextUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type TextUpdateManyInput = {
  /** Optional updates to localizations */
  localizations?: InputMaybe<TextUpdateManyLocalizationsInput>;
  /** value input for default locale (en) */
  value?: InputMaybe<Scalars['String']>;
};

export type TextUpdateManyLocalizationDataInput = {
  value?: InputMaybe<Scalars['String']>;
};

export type TextUpdateManyLocalizationInput = {
  data: TextUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type TextUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<TextUpdateManyLocalizationInput>>;
};

export type TextUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: TextUpdateManyInput;
  /** Document search */
  where: TextWhereInput;
};

export type TextUpdateOneInlineInput = {
  /** Create and connect one Text document */
  create?: InputMaybe<TextCreateInput>;
  /** Delete currently connected Text document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single Text document */
  update?: InputMaybe<TextUpdateWithNestedWhereUniqueInput>;
  /** Upsert single Text document */
  upsert?: InputMaybe<TextUpsertWithNestedWhereUniqueInput>;
};

export type TextUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<TextUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: TextWhereUniqueInput;
};

export type TextUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: TextUpdateInput;
  /** Unique document search */
  where: TextWhereUniqueInput;
};

export type TextUpsertInput = {
  /** Create document if it didn't exist */
  create: TextCreateInput;
  /** Update document if it exists */
  update: TextUpdateInput;
};

export type TextUpsertLocalizationInput = {
  create: TextCreateLocalizationDataInput;
  locale: Locale;
  update: TextUpdateLocalizationDataInput;
};

export type TextUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<TextUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: TextWhereUniqueInput;
};

export type TextUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: TextUpsertInput;
  /** Unique document search */
  where: TextWhereUniqueInput;
};

/** Identifies documents */
export type TextWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<TextWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<TextWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<TextWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  style?: InputMaybe<StyleWhereInput>;
  value?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  value_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  value_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  value_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  value_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  value_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  value_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  value_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  value_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  value_starts_with?: InputMaybe<Scalars['String']>;
};

/** References Text record uniquely */
export type TextWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export enum Theme {
  Primary = 'PRIMARY',
  Secondary = 'SECONDARY'
}

export type Title = {
  __typename?: 'Title';
  /** The unique identifier */
  id: Scalars['ID'];
  /** System Locale field */
  locale: Locale;
  /** Get the other localizations for this document */
  localizations: Array<Title>;
  /** System stage field */
  stage: Stage;
  style?: Maybe<Style>;
  value: Scalars['String'];
  withUnderline?: Maybe<Scalars['Boolean']>;
};


export type TitleLocalizationsArgs = {
  includeCurrent?: Scalars['Boolean'];
  locales?: Array<Locale>;
};


export type TitleStyleArgs = {
  locales?: InputMaybe<Array<Locale>>;
};

export type TitleConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: TitleWhereUniqueInput;
};

/** A connection to a list of items. */
export type TitleConnection = {
  __typename?: 'TitleConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<TitleEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type TitleCreateInput = {
  /** Inline mutations for managing document localizations excluding the default locale */
  localizations?: InputMaybe<TitleCreateLocalizationsInput>;
  style?: InputMaybe<StyleCreateOneInlineInput>;
  /** value input for default locale (en) */
  value: Scalars['String'];
  withUnderline?: InputMaybe<Scalars['Boolean']>;
};

export type TitleCreateLocalizationDataInput = {
  value: Scalars['String'];
};

export type TitleCreateLocalizationInput = {
  /** Localization input */
  data: TitleCreateLocalizationDataInput;
  locale: Locale;
};

export type TitleCreateLocalizationsInput = {
  /** Create localizations for the newly-created document */
  create?: InputMaybe<Array<TitleCreateLocalizationInput>>;
};

export type TitleCreateManyInlineInput = {
  /** Create and connect multiple existing Title documents */
  create?: InputMaybe<Array<TitleCreateInput>>;
};

export type TitleCreateOneInlineInput = {
  /** Create and connect one Title document */
  create?: InputMaybe<TitleCreateInput>;
};

export type TitleCreateWithPositionInput = {
  /** Document to create */
  data: TitleCreateInput;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
};

/** An edge in a connection. */
export type TitleEdge = {
  __typename?: 'TitleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Title;
};

/** Identifies documents */
export type TitleManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<TitleWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<TitleWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<TitleWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  style?: InputMaybe<StyleWhereInput>;
  withUnderline?: InputMaybe<Scalars['Boolean']>;
  /** All values that are not equal to given value. */
  withUnderline_not?: InputMaybe<Scalars['Boolean']>;
};

export enum TitleOrderByInput {
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  ValueAsc = 'value_ASC',
  ValueDesc = 'value_DESC',
  WithUnderlineAsc = 'withUnderline_ASC',
  WithUnderlineDesc = 'withUnderline_DESC'
}

export type TitleParent = Container;

export type TitleParentConnectInput = {
  Container?: InputMaybe<ContainerConnectInput>;
};

export type TitleParentCreateInput = {
  Container?: InputMaybe<ContainerCreateInput>;
};

export type TitleParentCreateManyInlineInput = {
  /** Connect multiple existing TitleParent documents */
  connect?: InputMaybe<Array<TitleParentWhereUniqueInput>>;
  /** Create and connect multiple existing TitleParent documents */
  create?: InputMaybe<Array<TitleParentCreateInput>>;
};

export type TitleParentCreateOneInlineInput = {
  /** Connect one existing TitleParent document */
  connect?: InputMaybe<TitleParentWhereUniqueInput>;
  /** Create and connect one TitleParent document */
  create?: InputMaybe<TitleParentCreateInput>;
};

export type TitleParentUpdateInput = {
  Container?: InputMaybe<ContainerUpdateInput>;
};

export type TitleParentUpdateManyInlineInput = {
  /** Connect multiple existing TitleParent documents */
  connect?: InputMaybe<Array<TitleParentConnectInput>>;
  /** Create and connect multiple TitleParent documents */
  create?: InputMaybe<Array<TitleParentCreateInput>>;
  /** Delete multiple TitleParent documents */
  delete?: InputMaybe<Array<TitleParentWhereUniqueInput>>;
  /** Disconnect multiple TitleParent documents */
  disconnect?: InputMaybe<Array<TitleParentWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing TitleParent documents */
  set?: InputMaybe<Array<TitleParentWhereUniqueInput>>;
  /** Update multiple TitleParent documents */
  update?: InputMaybe<Array<TitleParentUpdateWithNestedWhereUniqueInput>>;
  /** Upsert multiple TitleParent documents */
  upsert?: InputMaybe<Array<TitleParentUpsertWithNestedWhereUniqueInput>>;
};

export type TitleParentUpdateManyWithNestedWhereInput = {
  Container?: InputMaybe<ContainerUpdateManyWithNestedWhereInput>;
};

export type TitleParentUpdateOneInlineInput = {
  /** Connect existing TitleParent document */
  connect?: InputMaybe<TitleParentWhereUniqueInput>;
  /** Create and connect one TitleParent document */
  create?: InputMaybe<TitleParentCreateInput>;
  /** Delete currently connected TitleParent document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Disconnect currently connected TitleParent document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
  /** Update single TitleParent document */
  update?: InputMaybe<TitleParentUpdateWithNestedWhereUniqueInput>;
  /** Upsert single TitleParent document */
  upsert?: InputMaybe<TitleParentUpsertWithNestedWhereUniqueInput>;
};

export type TitleParentUpdateWithNestedWhereUniqueInput = {
  Container?: InputMaybe<ContainerUpdateWithNestedWhereUniqueInput>;
};

export type TitleParentUpsertWithNestedWhereUniqueInput = {
  Container?: InputMaybe<ContainerUpsertWithNestedWhereUniqueInput>;
};

export type TitleParentWhereInput = {
  Container?: InputMaybe<ContainerWhereInput>;
};

export type TitleParentWhereUniqueInput = {
  Container?: InputMaybe<ContainerWhereUniqueInput>;
};

export type TitleUpdateInput = {
  /** Manage document localizations */
  localizations?: InputMaybe<TitleUpdateLocalizationsInput>;
  style?: InputMaybe<StyleUpdateOneInlineInput>;
  /** value input for default locale (en) */
  value?: InputMaybe<Scalars['String']>;
  withUnderline?: InputMaybe<Scalars['Boolean']>;
};

export type TitleUpdateLocalizationDataInput = {
  value?: InputMaybe<Scalars['String']>;
};

export type TitleUpdateLocalizationInput = {
  data: TitleUpdateLocalizationDataInput;
  locale: Locale;
};

export type TitleUpdateLocalizationsInput = {
  /** Localizations to create */
  create?: InputMaybe<Array<TitleCreateLocalizationInput>>;
  /** Localizations to delete */
  delete?: InputMaybe<Array<Locale>>;
  /** Localizations to update */
  update?: InputMaybe<Array<TitleUpdateLocalizationInput>>;
  upsert?: InputMaybe<Array<TitleUpsertLocalizationInput>>;
};

export type TitleUpdateManyInlineInput = {
  /** Create and connect multiple Title component instances */
  create?: InputMaybe<Array<TitleCreateWithPositionInput>>;
  /** Delete multiple Title documents */
  delete?: InputMaybe<Array<TitleWhereUniqueInput>>;
  /** Update multiple Title component instances */
  update?: InputMaybe<Array<TitleUpdateWithNestedWhereUniqueAndPositionInput>>;
  /** Upsert multiple Title component instances */
  upsert?: InputMaybe<Array<TitleUpsertWithNestedWhereUniqueAndPositionInput>>;
};

export type TitleUpdateManyInput = {
  /** Optional updates to localizations */
  localizations?: InputMaybe<TitleUpdateManyLocalizationsInput>;
  /** value input for default locale (en) */
  value?: InputMaybe<Scalars['String']>;
  withUnderline?: InputMaybe<Scalars['Boolean']>;
};

export type TitleUpdateManyLocalizationDataInput = {
  value?: InputMaybe<Scalars['String']>;
};

export type TitleUpdateManyLocalizationInput = {
  data: TitleUpdateManyLocalizationDataInput;
  locale: Locale;
};

export type TitleUpdateManyLocalizationsInput = {
  /** Localizations to update */
  update?: InputMaybe<Array<TitleUpdateManyLocalizationInput>>;
};

export type TitleUpdateManyWithNestedWhereInput = {
  /** Update many input */
  data: TitleUpdateManyInput;
  /** Document search */
  where: TitleWhereInput;
};

export type TitleUpdateOneInlineInput = {
  /** Create and connect one Title document */
  create?: InputMaybe<TitleCreateInput>;
  /** Delete currently connected Title document */
  delete?: InputMaybe<Scalars['Boolean']>;
  /** Update single Title document */
  update?: InputMaybe<TitleUpdateWithNestedWhereUniqueInput>;
  /** Upsert single Title document */
  upsert?: InputMaybe<TitleUpsertWithNestedWhereUniqueInput>;
};

export type TitleUpdateWithNestedWhereUniqueAndPositionInput = {
  /** Document to update */
  data?: InputMaybe<TitleUpdateInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: TitleWhereUniqueInput;
};

export type TitleUpdateWithNestedWhereUniqueInput = {
  /** Document to update */
  data: TitleUpdateInput;
  /** Unique document search */
  where: TitleWhereUniqueInput;
};

export type TitleUpsertInput = {
  /** Create document if it didn't exist */
  create: TitleCreateInput;
  /** Update document if it exists */
  update: TitleUpdateInput;
};

export type TitleUpsertLocalizationInput = {
  create: TitleCreateLocalizationDataInput;
  locale: Locale;
  update: TitleUpdateLocalizationDataInput;
};

export type TitleUpsertWithNestedWhereUniqueAndPositionInput = {
  /** Document to upsert */
  data?: InputMaybe<TitleUpsertInput>;
  /** Position in the list of existing component instances, will default to appending at the end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Unique component instance search */
  where: TitleWhereUniqueInput;
};

export type TitleUpsertWithNestedWhereUniqueInput = {
  /** Upsert data */
  data: TitleUpsertInput;
  /** Unique document search */
  where: TitleWhereUniqueInput;
};

/** Identifies documents */
export type TitleWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<TitleWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<TitleWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<TitleWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  style?: InputMaybe<StyleWhereInput>;
  value?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  value_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  value_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  value_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  value_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  value_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  value_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  value_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  value_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  value_starts_with?: InputMaybe<Scalars['String']>;
  withUnderline?: InputMaybe<Scalars['Boolean']>;
  /** All values that are not equal to given value. */
  withUnderline_not?: InputMaybe<Scalars['Boolean']>;
};

/** References Title record uniquely */
export type TitleWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export type UnpublishLocaleInput = {
  /** Locales to unpublish */
  locale: Locale;
  /** Stages to unpublish selected locales from */
  stages: Array<Stage>;
};

/** User system model */
export type User = Node & {
  __typename?: 'User';
  /** The time the document was created */
  createdAt: Scalars['DateTime'];
  /** Get the document in other stages */
  documentInStages: Array<User>;
  /** The unique identifier */
  id: Scalars['ID'];
  /** Flag to determine if user is active or not */
  isActive: Scalars['Boolean'];
  /** User Kind. Can be either MEMBER, PAT or PUBLIC */
  kind: UserKind;
  /** The username */
  name: Scalars['String'];
  /** Profile Picture url */
  picture?: Maybe<Scalars['String']>;
  /** The time the document was published. Null on documents in draft stage. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** System stage field */
  stage: Stage;
  /** The time the document was updated */
  updatedAt: Scalars['DateTime'];
};


/** User system model */
export type UserDocumentInStagesArgs = {
  includeCurrent?: Scalars['Boolean'];
  inheritLocale?: Scalars['Boolean'];
  stages?: Array<Stage>;
};

export type UserConnectInput = {
  /** Allow to specify document position in list of connected documents, will default to appending at end of list */
  position?: InputMaybe<ConnectPositionInput>;
  /** Document to connect */
  where: UserWhereUniqueInput;
};

/** A connection to a list of items. */
export type UserConnection = {
  __typename?: 'UserConnection';
  aggregate: Aggregate;
  /** A list of edges. */
  edges: Array<UserEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type UserCreateManyInlineInput = {
  /** Connect multiple existing User documents */
  connect?: InputMaybe<Array<UserWhereUniqueInput>>;
};

export type UserCreateOneInlineInput = {
  /** Connect one existing User document */
  connect?: InputMaybe<UserWhereUniqueInput>;
};

/** An edge in a connection. */
export type UserEdge = {
  __typename?: 'UserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: User;
};

/** System User Kind */
export enum UserKind {
  Member = 'MEMBER',
  Pat = 'PAT',
  Public = 'PUBLIC',
  Webhook = 'WEBHOOK'
}

/** Identifies documents */
export type UserManyWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<UserWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<UserWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<UserWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  isActive?: InputMaybe<Scalars['Boolean']>;
  /** All values that are not equal to given value. */
  isActive_not?: InputMaybe<Scalars['Boolean']>;
  kind?: InputMaybe<UserKind>;
  /** All values that are contained in given list. */
  kind_in?: InputMaybe<Array<InputMaybe<UserKind>>>;
  /** All values that are not equal to given value. */
  kind_not?: InputMaybe<UserKind>;
  /** All values that are not contained in given list. */
  kind_not_in?: InputMaybe<Array<InputMaybe<UserKind>>>;
  name?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  name_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  name_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  name_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  name_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  name_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  name_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  name_starts_with?: InputMaybe<Scalars['String']>;
  picture?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  picture_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  picture_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  picture_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  picture_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  picture_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  picture_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  picture_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  picture_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  picture_starts_with?: InputMaybe<Scalars['String']>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
};

export enum UserOrderByInput {
  CreatedAtAsc = 'createdAt_ASC',
  CreatedAtDesc = 'createdAt_DESC',
  IdAsc = 'id_ASC',
  IdDesc = 'id_DESC',
  IsActiveAsc = 'isActive_ASC',
  IsActiveDesc = 'isActive_DESC',
  KindAsc = 'kind_ASC',
  KindDesc = 'kind_DESC',
  NameAsc = 'name_ASC',
  NameDesc = 'name_DESC',
  PictureAsc = 'picture_ASC',
  PictureDesc = 'picture_DESC',
  PublishedAtAsc = 'publishedAt_ASC',
  PublishedAtDesc = 'publishedAt_DESC',
  UpdatedAtAsc = 'updatedAt_ASC',
  UpdatedAtDesc = 'updatedAt_DESC'
}

export type UserUpdateManyInlineInput = {
  /** Connect multiple existing User documents */
  connect?: InputMaybe<Array<UserConnectInput>>;
  /** Disconnect multiple User documents */
  disconnect?: InputMaybe<Array<UserWhereUniqueInput>>;
  /** Override currently-connected documents with multiple existing User documents */
  set?: InputMaybe<Array<UserWhereUniqueInput>>;
};

export type UserUpdateOneInlineInput = {
  /** Connect existing User document */
  connect?: InputMaybe<UserWhereUniqueInput>;
  /** Disconnect currently connected User document */
  disconnect?: InputMaybe<Scalars['Boolean']>;
};

/** Identifies documents */
export type UserWhereInput = {
  /** Logical AND on all given filters. */
  AND?: InputMaybe<Array<UserWhereInput>>;
  /** Logical NOT on all given filters combined by AND. */
  NOT?: InputMaybe<Array<UserWhereInput>>;
  /** Logical OR on all given filters. */
  OR?: InputMaybe<Array<UserWhereInput>>;
  /** Contains search across all appropriate fields. */
  _search?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  createdAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  createdAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  createdAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  createdAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  createdAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  createdAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  createdAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  id?: InputMaybe<Scalars['ID']>;
  /** All values containing the given string. */
  id_contains?: InputMaybe<Scalars['ID']>;
  /** All values ending with the given string. */
  id_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are contained in given list. */
  id_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values that are not equal to given value. */
  id_not?: InputMaybe<Scalars['ID']>;
  /** All values not containing the given string. */
  id_not_contains?: InputMaybe<Scalars['ID']>;
  /** All values not ending with the given string */
  id_not_ends_with?: InputMaybe<Scalars['ID']>;
  /** All values that are not contained in given list. */
  id_not_in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** All values not starting with the given string. */
  id_not_starts_with?: InputMaybe<Scalars['ID']>;
  /** All values starting with the given string. */
  id_starts_with?: InputMaybe<Scalars['ID']>;
  isActive?: InputMaybe<Scalars['Boolean']>;
  /** All values that are not equal to given value. */
  isActive_not?: InputMaybe<Scalars['Boolean']>;
  kind?: InputMaybe<UserKind>;
  /** All values that are contained in given list. */
  kind_in?: InputMaybe<Array<InputMaybe<UserKind>>>;
  /** All values that are not equal to given value. */
  kind_not?: InputMaybe<UserKind>;
  /** All values that are not contained in given list. */
  kind_not_in?: InputMaybe<Array<InputMaybe<UserKind>>>;
  name?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  name_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  name_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  name_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  name_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  name_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  name_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  name_starts_with?: InputMaybe<Scalars['String']>;
  picture?: InputMaybe<Scalars['String']>;
  /** All values containing the given string. */
  picture_contains?: InputMaybe<Scalars['String']>;
  /** All values ending with the given string. */
  picture_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are contained in given list. */
  picture_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values that are not equal to given value. */
  picture_not?: InputMaybe<Scalars['String']>;
  /** All values not containing the given string. */
  picture_not_contains?: InputMaybe<Scalars['String']>;
  /** All values not ending with the given string */
  picture_not_ends_with?: InputMaybe<Scalars['String']>;
  /** All values that are not contained in given list. */
  picture_not_in?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** All values not starting with the given string. */
  picture_not_starts_with?: InputMaybe<Scalars['String']>;
  /** All values starting with the given string. */
  picture_starts_with?: InputMaybe<Scalars['String']>;
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  publishedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  publishedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  publishedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  publishedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  publishedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  publishedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  publishedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  updatedAt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than the given value. */
  updatedAt_gt?: InputMaybe<Scalars['DateTime']>;
  /** All values greater than or equal the given value. */
  updatedAt_gte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are contained in given list. */
  updatedAt_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
  /** All values less than the given value. */
  updatedAt_lt?: InputMaybe<Scalars['DateTime']>;
  /** All values less than or equal the given value. */
  updatedAt_lte?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not equal to given value. */
  updatedAt_not?: InputMaybe<Scalars['DateTime']>;
  /** All values that are not contained in given list. */
  updatedAt_not_in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']>>>;
};

/** References User record uniquely */
export type UserWhereUniqueInput = {
  id?: InputMaybe<Scalars['ID']>;
};

export type Version = {
  __typename?: 'Version';
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  revision: Scalars['Int'];
  stage: Stage;
};

export type VersionWhereInput = {
  id: Scalars['ID'];
  revision: Scalars['Int'];
  stage: Stage;
};

export enum _FilterKind {
  And = 'AND',
  Not = 'NOT',
  Or = 'OR',
  Contains = 'contains',
  ContainsAll = 'contains_all',
  ContainsNone = 'contains_none',
  ContainsSome = 'contains_some',
  EndsWith = 'ends_with',
  Eq = 'eq',
  EqNot = 'eq_not',
  Gt = 'gt',
  Gte = 'gte',
  In = 'in',
  Lt = 'lt',
  Lte = 'lte',
  NotContains = 'not_contains',
  NotEndsWith = 'not_ends_with',
  NotIn = 'not_in',
  NotStartsWith = 'not_starts_with',
  RelationalEvery = 'relational_every',
  RelationalNone = 'relational_none',
  RelationalSingle = 'relational_single',
  RelationalSome = 'relational_some',
  Search = 'search',
  StartsWith = 'starts_with'
}

export enum _MutationInputFieldKind {
  Enum = 'enum',
  Relation = 'relation',
  RichText = 'richText',
  RichTextWithEmbeds = 'richTextWithEmbeds',
  Scalar = 'scalar',
  Union = 'union',
  Virtual = 'virtual'
}

export enum _MutationKind {
  Create = 'create',
  Delete = 'delete',
  DeleteMany = 'deleteMany',
  Publish = 'publish',
  PublishMany = 'publishMany',
  SchedulePublish = 'schedulePublish',
  ScheduleUnpublish = 'scheduleUnpublish',
  Unpublish = 'unpublish',
  UnpublishMany = 'unpublishMany',
  Update = 'update',
  UpdateMany = 'updateMany',
  Upsert = 'upsert'
}

export enum _OrderDirection {
  Asc = 'asc',
  Desc = 'desc'
}

export enum _RelationInputCardinality {
  Many = 'many',
  One = 'one'
}

export enum _RelationInputKind {
  Create = 'create',
  Update = 'update'
}

export enum _RelationKind {
  Regular = 'regular',
  Union = 'union'
}

export enum _SystemDateTimeFieldVariation {
  Base = 'base',
  Combined = 'combined',
  Localization = 'localization'
}

export type GetEventsSlugsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetEventsSlugsQuery = { __typename?: 'Query', data: Array<{ __typename?: 'Event', slug?: string | null }> };

export type GetSingleEventQueryVariables = Exact<{
  locale: Locale;
  slug: Scalars['String'];
}>;


export type GetSingleEventQuery = { __typename?: 'Query', data?: { __typename?: 'Event', slug?: string | null, id: string, title: string, details: string, startDate: any, endDate: any, image: { __typename?: 'Asset', url: string, width?: number | null, height?: number | null }, description: { __typename?: 'RichText', raw: any } } | null };

export type GetEventsQueryVariables = Exact<{
  locale: Locale;
}>;


export type GetEventsQuery = { __typename?: 'Query', data: Array<{ __typename?: 'Event', slug?: string | null, id: string, title: string, details: string, startDate: any, endDate: any, image: { __typename?: 'Asset', url: string, width?: number | null, height?: number | null } }> };

export type GetPageByIdQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type GetPageByIdQuery = { __typename?: 'Query', data?: { __typename?: 'Page', id: string } | null };

export type GetLayoutByLocalQueryVariables = Exact<{
  locale: Locale;
}>;


export type GetLayoutByLocalQuery = { __typename?: 'Query', data: Array<{ __typename?: 'Layout', navigation?: { __typename?: 'Navigation', logo?: { __typename?: 'Asset', url: string } | null, links: Array<{ __typename?: 'Page', label: string, href: string }>, buttons: Array<{ __typename?: 'Button', label: string, href?: string | null }> } | null, footer?: { __typename?: 'Footer', title?: string | null, description?: string | null, columns: Array<{ __typename?: 'OldColumn', id: string, title?: string | null, pages: Array<{ __typename?: 'Page', id: string, slug: string, label: string }>, contactCard?: { __typename?: 'ContactCard', id: string, email: string, phoneNumber: string, address: Array<string>, socials: Array<{ __typename?: 'SocialLink', url?: string | null }> } | null }>, secondaryLinks: Array<{ __typename?: 'Link', id: string, href: string, label: string, isExternal?: boolean | null }> } | null }> };

export type GetPagesSlugQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPagesSlugQuery = { __typename?: 'Query', data: Array<{ __typename?: 'Page', slug: string }> };

export type GetPageBySlugQueryVariables = Exact<{
  slug: Scalars['String'];
  locale: Locale;
}>;


export type GetPageBySlugQuery = { __typename?: 'Query', data?: { __typename?: 'Page', id: string, slug: string, title: string, navigationLabel: string, blocs: Array<{ __typename?: 'AssociationProfileSection', id: string, slogan?: string | null, typename: 'AssociationProfileSection', backgroundImage?: { __typename?: 'Asset', url: string } | null, facts: Array<{ __typename?: 'Fact', id: string, title: string, description: string }> } | { __typename?: 'Carousel', id: string, typename: 'Carousel', slides: Array<{ __typename?: 'CarouselSlide', id: string, description?: string | null, title: string, ctas?: { __typename?: 'Link', id: string, isExternal?: boolean | null, label: string, href: string } | { __typename?: 'OldButton' } | null, image: { __typename?: 'Asset', url: string } }> } | { __typename?: 'Grid', id: string, title: string, description?: string | null, typename: 'Grid', bgColor?: { __typename?: 'Color', css: string } | null, children: Array<{ __typename?: 'Event', id: string, title: string, details: string, startDate: any, endDate: any, typename: 'Event' } | { __typename?: 'Person', id: string, name: string, position?: string | null, typename: 'Person', photo?: { __typename?: 'Asset', url: string } | null } | { __typename?: 'Service', id: string, title: string, description: string, icon?: Icons | null, typename: 'Service' } | { __typename?: 'Sponsor', id: string, name: string, description: string, link?: string | null, typename: 'Sponsor', logo?: { __typename?: 'Asset', url: string } | null }> } | { __typename?: 'Hero', id: string, title: string, description?: string | null, typename: 'Hero', image: { __typename?: 'Asset', url: string } } | { __typename?: 'JoinUsSection', id: string, description?: string | null, title: string, typename: 'JoinUsSection', bgColor?: { __typename?: 'Color', hex: any } | null, ctas: Array<{ __typename?: 'OldButton', id: string, label?: string | null }> } | { __typename?: 'OldColumn' } | { __typename?: 'ProjectsContainer', id: string, typename: 'ProjectsContainer', projects: Array<{ __typename?: 'Project', id: string, slug: string, name: string, details: string, image?: { __typename?: 'Asset', url: string } | null }> } | { __typename?: 'Section', id: string, title: string, description?: string | null, typename: 'Section' } | { __typename?: 'SectionWithImage', id: string, title: string, description?: string | null, typename: 'SectionWithImage', image: { __typename?: 'Asset', url: string } } | { __typename?: 'SponsorSection', id: string, title: string, typename: 'SponsorSection', sponsors: Array<{ __typename?: 'Sponsor', id: string, name: string, description: string, link?: string | null, logo?: { __typename?: 'Asset', url: string, width?: number | null, height?: number | null } | null }> } | { __typename?: 'TeamSection', id: string, title: string, typename: 'TeamSection', people: Array<{ __typename?: 'Person', id: string, name: string, position?: string | null, photo?: { __typename?: 'Asset', url: string } | null }> }> } | null };

export type GetProjectQueryVariables = Exact<{ [key: string]: never; }>;


export type GetProjectQuery = { __typename?: 'Query', data: Array<{ __typename?: 'Project', id: string, slug: string, name: string, details: string, image?: { __typename?: 'Asset', url: string } | null }> };


export const GetEventsSlugsDocument = `
    query GetEventsSlugs {
  data: events {
    slug
  }
}
    `;
export const useGetEventsSlugsQuery = <
      TData = GetEventsSlugsQuery,
      TError = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      variables?: GetEventsSlugsQueryVariables,
      options?: UseQueryOptions<GetEventsSlugsQuery, TError, TData>
    ) =>
    useQuery<GetEventsSlugsQuery, TError, TData>(
      variables === undefined ? ['GetEventsSlugs'] : ['GetEventsSlugs', variables],
      fetcher<GetEventsSlugsQuery, GetEventsSlugsQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, GetEventsSlugsDocument, variables),
      options
    );
export const GetSingleEventDocument = `
    query GetSingleEvent($locale: Locale!, $slug: String!) {
  data: event(locales: [$locale], where: {slug: $slug}) {
    slug
    id
    title
    details
    startDate
    endDate
    image {
      url
      width
      height
    }
    description {
      raw
    }
  }
}
    `;
export const useGetSingleEventQuery = <
      TData = GetSingleEventQuery,
      TError = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      variables: GetSingleEventQueryVariables,
      options?: UseQueryOptions<GetSingleEventQuery, TError, TData>
    ) =>
    useQuery<GetSingleEventQuery, TError, TData>(
      ['GetSingleEvent', variables],
      fetcher<GetSingleEventQuery, GetSingleEventQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, GetSingleEventDocument, variables),
      options
    );
export const GetEventsDocument = `
    query GetEvents($locale: Locale!) {
  data: events(locales: [$locale]) {
    slug
    id
    title
    details
    startDate
    endDate
    image {
      url
      width
      height
    }
  }
}
    `;
export const useGetEventsQuery = <
      TData = GetEventsQuery,
      TError = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      variables: GetEventsQueryVariables,
      options?: UseQueryOptions<GetEventsQuery, TError, TData>
    ) =>
    useQuery<GetEventsQuery, TError, TData>(
      ['GetEvents', variables],
      fetcher<GetEventsQuery, GetEventsQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, GetEventsDocument, variables),
      options
    );
export const GetPageByIdDocument = `
    query GetPageById($id: ID!) {
  data: page(where: {id: $id}) {
    id
  }
}
    `;
export const useGetPageByIdQuery = <
      TData = GetPageByIdQuery,
      TError = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      variables: GetPageByIdQueryVariables,
      options?: UseQueryOptions<GetPageByIdQuery, TError, TData>
    ) =>
    useQuery<GetPageByIdQuery, TError, TData>(
      ['GetPageById', variables],
      fetcher<GetPageByIdQuery, GetPageByIdQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, GetPageByIdDocument, variables),
      options
    );
export const GetLayoutByLocalDocument = `
    query GetLayoutByLocal($locale: Locale!) {
  data: layouts {
    navigation(locales: [$locale]) {
      logo {
        url
      }
      links: pages {
        label: navigationLabel
        href: slug
      }
      buttons: ctas {
        label
        href
      }
    }
    footer(locales: en) {
      title
      description
      columns {
        id
        title
        pages {
          id
          slug
          label: navigationLabel
        }
        contactCard {
          id
          email
          phoneNumber
          address
          socials {
            url
          }
        }
      }
      secondaryLinks {
        id
        href
        label
        isExternal
      }
    }
  }
}
    `;
export const useGetLayoutByLocalQuery = <
      TData = GetLayoutByLocalQuery,
      TError = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      variables: GetLayoutByLocalQueryVariables,
      options?: UseQueryOptions<GetLayoutByLocalQuery, TError, TData>
    ) =>
    useQuery<GetLayoutByLocalQuery, TError, TData>(
      ['GetLayoutByLocal', variables],
      fetcher<GetLayoutByLocalQuery, GetLayoutByLocalQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, GetLayoutByLocalDocument, variables),
      options
    );
export const GetPagesSlugDocument = `
    query GetPagesSlug {
  data: pages(where: {slug_not_in: ["home", "projects", "events"]}) {
    slug
  }
}
    `;
export const useGetPagesSlugQuery = <
      TData = GetPagesSlugQuery,
      TError = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      variables?: GetPagesSlugQueryVariables,
      options?: UseQueryOptions<GetPagesSlugQuery, TError, TData>
    ) =>
    useQuery<GetPagesSlugQuery, TError, TData>(
      variables === undefined ? ['GetPagesSlug'] : ['GetPagesSlug', variables],
      fetcher<GetPagesSlugQuery, GetPagesSlugQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, GetPagesSlugDocument, variables),
      options
    );
export const GetPageBySlugDocument = `
    query GetPageBySlug($slug: String!, $locale: Locale!) {
  data: page(locales: [$locale], where: {slug: $slug}) {
    id
    slug
    title
    navigationLabel
    blocs(locales: [$locale]) {
      ... on Carousel {
        typename: __typename
        id
        slides {
          id
          description
          title
          ctas {
            ... on Link {
              id
              isExternal
              label
              href
            }
          }
          image(locales: en) {
            url
          }
        }
      }
      ... on Section {
        typename: __typename
        id
        title
        description
      }
      ... on ProjectsContainer {
        typename: __typename
        id
        projects(locales: [$locale]) {
          id
          slug
          name
          details
          image(locales: en) {
            url
          }
        }
      }
      ... on Hero {
        typename: __typename
        id
        title
        description
        image(locales: en) {
          url
        }
      }
      ... on SectionWithImage {
        typename: __typename
        id
        image(locales: en) {
          url
        }
        title
        description
      }
      ... on AssociationProfileSection {
        typename: __typename
        id
        backgroundImage(locales: en) {
          url
        }
        slogan
        facts {
          id
          title
          description
        }
      }
      ... on JoinUsSection {
        typename: __typename
        id
        bgColor {
          hex
        }
        description
        title
        ctas {
          id
          label
        }
      }
      ... on TeamSection {
        typename: __typename
        id
        title
        people(locales: en) {
          id
          name
          position
          photo {
            url
          }
        }
      }
      ... on SponsorSection {
        typename: __typename
        id
        title
        sponsors {
          id
          name
          description
          link
          logo {
            url
            width
            height
          }
        }
      }
      ... on Grid {
        typename: __typename
        id
        title
        description
        bgColor {
          css
        }
        children(locales: [$locale]) {
          typename: __typename
          ... on Service {
            id
            title
            description
            icon
          }
          ... on Event {
            id
            title
            details
            startDate
            endDate
          }
          ... on Person {
            id
            name
            position
            photo {
              url
            }
          }
          ... on Sponsor {
            id
            name
            description
            link
            logo {
              url
            }
          }
        }
      }
    }
  }
}
    `;
export const useGetPageBySlugQuery = <
      TData = GetPageBySlugQuery,
      TError = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      variables: GetPageBySlugQueryVariables,
      options?: UseQueryOptions<GetPageBySlugQuery, TError, TData>
    ) =>
    useQuery<GetPageBySlugQuery, TError, TData>(
      ['GetPageBySlug', variables],
      fetcher<GetPageBySlugQuery, GetPageBySlugQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, GetPageBySlugDocument, variables),
      options
    );
export const GetProjectDocument = `
    query GetProject {
  data: projects {
    id
    slug
    name
    details
    image(locales: [en]) {
      url
    }
  }
}
    `;
export const useGetProjectQuery = <
      TData = GetProjectQuery,
      TError = unknown
    >(
      dataSource: { endpoint: string, fetchParams?: RequestInit },
      variables?: GetProjectQueryVariables,
      options?: UseQueryOptions<GetProjectQuery, TError, TData>
    ) =>
    useQuery<GetProjectQuery, TError, TData>(
      variables === undefined ? ['GetProject'] : ['GetProject', variables],
      fetcher<GetProjectQuery, GetProjectQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, GetProjectDocument, variables),
      options
    );